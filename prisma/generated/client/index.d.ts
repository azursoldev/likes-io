
/**
 * Client
**/

import * as runtime from './runtime/binary.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Upsell
 * 
 */
export type Upsell = $Result.DefaultSelection<Prisma.$UpsellPayload>
/**
 * Model SocialProfile
 * 
 */
export type SocialProfile = $Result.DefaultSelection<Prisma.$SocialProfilePayload>
/**
 * Model SocialProof
 * 
 */
export type SocialProof = $Result.DefaultSelection<Prisma.$SocialProofPayload>
/**
 * Model AdminSettings
 * 
 */
export type AdminSettings = $Result.DefaultSelection<Prisma.$AdminSettingsPayload>
/**
 * Model HomepageContent
 * 
 */
export type HomepageContent = $Result.DefaultSelection<Prisma.$HomepageContentPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model HeroSocialUpdate
 * 
 */
export type HeroSocialUpdate = $Result.DefaultSelection<Prisma.$HeroSocialUpdatePayload>
/**
 * Model PromoBar
 * 
 */
export type PromoBar = $Result.DefaultSelection<Prisma.$PromoBarPayload>
/**
 * Model FeaturedOn
 * 
 */
export type FeaturedOn = $Result.DefaultSelection<Prisma.$FeaturedOnPayload>
/**
 * Model FeaturedOnPageLink
 * 
 */
export type FeaturedOnPageLink = $Result.DefaultSelection<Prisma.$FeaturedOnPageLinkPayload>
/**
 * Model PlatformSection
 * 
 */
export type PlatformSection = $Result.DefaultSelection<Prisma.$PlatformSectionPayload>
/**
 * Model GetStartedContent
 * 
 */
export type GetStartedContent = $Result.DefaultSelection<Prisma.$GetStartedContentPayload>
/**
 * Model InfluenceSection
 * 
 */
export type InfluenceSection = $Result.DefaultSelection<Prisma.$InfluenceSectionPayload>
/**
 * Model AdvantageSection
 * 
 */
export type AdvantageSection = $Result.DefaultSelection<Prisma.$AdvantageSectionPayload>
/**
 * Model QuickStartSection
 * 
 */
export type QuickStartSection = $Result.DefaultSelection<Prisma.$QuickStartSectionPayload>
/**
 * Model ServicePageContent
 * 
 */
export type ServicePageContent = $Result.DefaultSelection<Prisma.$ServicePageContentPayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model LegalPage
 * 
 */
export type LegalPage = $Result.DefaultSelection<Prisma.$LegalPagePayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model BellNotification
 * 
 */
export type BellNotification = $Result.DefaultSelection<Prisma.$BellNotificationPayload>
/**
 * Model BannerMessage
 * 
 */
export type BannerMessage = $Result.DefaultSelection<Prisma.$BannerMessagePayload>
/**
 * Model IconAsset
 * 
 */
export type IconAsset = $Result.DefaultSelection<Prisma.$IconAssetPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model CouponRedemption
 * 
 */
export type CouponRedemption = $Result.DefaultSelection<Prisma.$CouponRedemptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Platform: {
  INSTAGRAM: 'INSTAGRAM',
  TIKTOK: 'TIKTOK',
  YOUTUBE: 'YOUTUBE',
  REVIEWS: 'REVIEWS'
};

export type Platform = (typeof Platform)[keyof typeof Platform]


export const ServiceType: {
  LIKES: 'LIKES',
  FOLLOWERS: 'FOLLOWERS',
  VIEWS: 'VIEWS',
  SUBSCRIBERS: 'SUBSCRIBERS'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const OrderStatus: {
  PENDING_PAYMENT: 'PENDING_PAYMENT',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentGateway: {
  CHECKOUT_COM: 'CHECKOUT_COM',
  BIGPAYME: 'BIGPAYME',
  CRYPTOMUS: 'CRYPTOMUS',
  MYFATOORAH: 'MYFATOORAH'
};

export type PaymentGateway = (typeof PaymentGateway)[keyof typeof PaymentGateway]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const DiscountType: {
  PERCENT: 'PERCENT',
  FIXED: 'FIXED'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const CouponType: {
  PERCENT: 'PERCENT',
  FIXED: 'FIXED'
};

export type CouponType = (typeof CouponType)[keyof typeof CouponType]


export const CouponStatus: {
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED'
};

export type CouponStatus = (typeof CouponStatus)[keyof typeof CouponStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Platform = $Enums.Platform

export const Platform: typeof $Enums.Platform

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentGateway = $Enums.PaymentGateway

export const PaymentGateway: typeof $Enums.PaymentGateway

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type CouponType = $Enums.CouponType

export const CouponType: typeof $Enums.CouponType

export type CouponStatus = $Enums.CouponStatus

export const CouponStatus: typeof $Enums.CouponStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => $Utils.JsPromise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.upsell`: Exposes CRUD operations for the **Upsell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Upsells
    * const upsells = await prisma.upsell.findMany()
    * ```
    */
  get upsell(): Prisma.UpsellDelegate<ExtArgs>;

  /**
   * `prisma.socialProfile`: Exposes CRUD operations for the **SocialProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialProfiles
    * const socialProfiles = await prisma.socialProfile.findMany()
    * ```
    */
  get socialProfile(): Prisma.SocialProfileDelegate<ExtArgs>;

  /**
   * `prisma.socialProof`: Exposes CRUD operations for the **SocialProof** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialProofs
    * const socialProofs = await prisma.socialProof.findMany()
    * ```
    */
  get socialProof(): Prisma.SocialProofDelegate<ExtArgs>;

  /**
   * `prisma.adminSettings`: Exposes CRUD operations for the **AdminSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSettings
    * const adminSettings = await prisma.adminSettings.findMany()
    * ```
    */
  get adminSettings(): Prisma.AdminSettingsDelegate<ExtArgs>;

  /**
   * `prisma.homepageContent`: Exposes CRUD operations for the **HomepageContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomepageContents
    * const homepageContents = await prisma.homepageContent.findMany()
    * ```
    */
  get homepageContent(): Prisma.HomepageContentDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.heroSocialUpdate`: Exposes CRUD operations for the **HeroSocialUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroSocialUpdates
    * const heroSocialUpdates = await prisma.heroSocialUpdate.findMany()
    * ```
    */
  get heroSocialUpdate(): Prisma.HeroSocialUpdateDelegate<ExtArgs>;

  /**
   * `prisma.promoBar`: Exposes CRUD operations for the **PromoBar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoBars
    * const promoBars = await prisma.promoBar.findMany()
    * ```
    */
  get promoBar(): Prisma.PromoBarDelegate<ExtArgs>;

  /**
   * `prisma.featuredOn`: Exposes CRUD operations for the **FeaturedOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedOns
    * const featuredOns = await prisma.featuredOn.findMany()
    * ```
    */
  get featuredOn(): Prisma.FeaturedOnDelegate<ExtArgs>;

  /**
   * `prisma.featuredOnPageLink`: Exposes CRUD operations for the **FeaturedOnPageLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedOnPageLinks
    * const featuredOnPageLinks = await prisma.featuredOnPageLink.findMany()
    * ```
    */
  get featuredOnPageLink(): Prisma.FeaturedOnPageLinkDelegate<ExtArgs>;

  /**
   * `prisma.platformSection`: Exposes CRUD operations for the **PlatformSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformSections
    * const platformSections = await prisma.platformSection.findMany()
    * ```
    */
  get platformSection(): Prisma.PlatformSectionDelegate<ExtArgs>;

  /**
   * `prisma.getStartedContent`: Exposes CRUD operations for the **GetStartedContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GetStartedContents
    * const getStartedContents = await prisma.getStartedContent.findMany()
    * ```
    */
  get getStartedContent(): Prisma.GetStartedContentDelegate<ExtArgs>;

  /**
   * `prisma.influenceSection`: Exposes CRUD operations for the **InfluenceSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InfluenceSections
    * const influenceSections = await prisma.influenceSection.findMany()
    * ```
    */
  get influenceSection(): Prisma.InfluenceSectionDelegate<ExtArgs>;

  /**
   * `prisma.advantageSection`: Exposes CRUD operations for the **AdvantageSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdvantageSections
    * const advantageSections = await prisma.advantageSection.findMany()
    * ```
    */
  get advantageSection(): Prisma.AdvantageSectionDelegate<ExtArgs>;

  /**
   * `prisma.quickStartSection`: Exposes CRUD operations for the **QuickStartSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuickStartSections
    * const quickStartSections = await prisma.quickStartSection.findMany()
    * ```
    */
  get quickStartSection(): Prisma.QuickStartSectionDelegate<ExtArgs>;

  /**
   * `prisma.servicePageContent`: Exposes CRUD operations for the **ServicePageContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePageContents
    * const servicePageContents = await prisma.servicePageContent.findMany()
    * ```
    */
  get servicePageContent(): Prisma.ServicePageContentDelegate<ExtArgs>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs>;

  /**
   * `prisma.legalPage`: Exposes CRUD operations for the **LegalPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LegalPages
    * const legalPages = await prisma.legalPage.findMany()
    * ```
    */
  get legalPage(): Prisma.LegalPageDelegate<ExtArgs>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs>;

  /**
   * `prisma.bellNotification`: Exposes CRUD operations for the **BellNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BellNotifications
    * const bellNotifications = await prisma.bellNotification.findMany()
    * ```
    */
  get bellNotification(): Prisma.BellNotificationDelegate<ExtArgs>;

  /**
   * `prisma.bannerMessage`: Exposes CRUD operations for the **BannerMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerMessages
    * const bannerMessages = await prisma.bannerMessage.findMany()
    * ```
    */
  get bannerMessage(): Prisma.BannerMessageDelegate<ExtArgs>;

  /**
   * `prisma.iconAsset`: Exposes CRUD operations for the **IconAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IconAssets
    * const iconAssets = await prisma.iconAsset.findMany()
    * ```
    */
  get iconAsset(): Prisma.IconAssetDelegate<ExtArgs>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs>;

  /**
   * `prisma.couponRedemption`: Exposes CRUD operations for the **CouponRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CouponRedemptions
    * const couponRedemptions = await prisma.couponRedemption.findMany()
    * ```
    */
  get couponRedemption(): Prisma.CouponRedemptionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.21.1
   * Query Engine version: bf0e5e8a04cada8225617067eaa03d041e2bba36
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Order: 'Order',
    Service: 'Service',
    Payment: 'Payment',
    Upsell: 'Upsell',
    SocialProfile: 'SocialProfile',
    SocialProof: 'SocialProof',
    AdminSettings: 'AdminSettings',
    HomepageContent: 'HomepageContent',
    TeamMember: 'TeamMember',
    HeroSocialUpdate: 'HeroSocialUpdate',
    PromoBar: 'PromoBar',
    FeaturedOn: 'FeaturedOn',
    FeaturedOnPageLink: 'FeaturedOnPageLink',
    PlatformSection: 'PlatformSection',
    GetStartedContent: 'GetStartedContent',
    InfluenceSection: 'InfluenceSection',
    AdvantageSection: 'AdvantageSection',
    QuickStartSection: 'QuickStartSection',
    ServicePageContent: 'ServicePageContent',
    FAQ: 'FAQ',
    Review: 'Review',
    PasswordResetToken: 'PasswordResetToken',
    Testimonial: 'Testimonial',
    BlogPost: 'BlogPost',
    LegalPage: 'LegalPage',
    EmailTemplate: 'EmailTemplate',
    BellNotification: 'BellNotification',
    BannerMessage: 'BannerMessage',
    IconAsset: 'IconAsset',
    Coupon: 'Coupon',
    CouponRedemption: 'CouponRedemption'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "order" | "service" | "payment" | "upsell" | "socialProfile" | "socialProof" | "adminSettings" | "homepageContent" | "teamMember" | "heroSocialUpdate" | "promoBar" | "featuredOn" | "featuredOnPageLink" | "platformSection" | "getStartedContent" | "influenceSection" | "advantageSection" | "quickStartSection" | "servicePageContent" | "fAQ" | "review" | "passwordResetToken" | "testimonial" | "blogPost" | "legalPage" | "emailTemplate" | "bellNotification" | "bannerMessage" | "iconAsset" | "coupon" | "couponRedemption"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Upsell: {
        payload: Prisma.$UpsellPayload<ExtArgs>
        fields: Prisma.UpsellFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UpsellFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UpsellFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>
          }
          findFirst: {
            args: Prisma.UpsellFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UpsellFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>
          }
          findMany: {
            args: Prisma.UpsellFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>[]
          }
          create: {
            args: Prisma.UpsellCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>
          }
          createMany: {
            args: Prisma.UpsellCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UpsellCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>[]
          }
          delete: {
            args: Prisma.UpsellDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>
          }
          update: {
            args: Prisma.UpsellUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>
          }
          deleteMany: {
            args: Prisma.UpsellDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UpsellUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UpsellUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpsellPayload>
          }
          aggregate: {
            args: Prisma.UpsellAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpsell>
          }
          groupBy: {
            args: Prisma.UpsellGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpsellGroupByOutputType>[]
          }
          count: {
            args: Prisma.UpsellCountArgs<ExtArgs>
            result: $Utils.Optional<UpsellCountAggregateOutputType> | number
          }
        }
      }
      SocialProfile: {
        payload: Prisma.$SocialProfilePayload<ExtArgs>
        fields: Prisma.SocialProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          findFirst: {
            args: Prisma.SocialProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          findMany: {
            args: Prisma.SocialProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>[]
          }
          create: {
            args: Prisma.SocialProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          createMany: {
            args: Prisma.SocialProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>[]
          }
          delete: {
            args: Prisma.SocialProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          update: {
            args: Prisma.SocialProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          deleteMany: {
            args: Prisma.SocialProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProfilePayload>
          }
          aggregate: {
            args: Prisma.SocialProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialProfile>
          }
          groupBy: {
            args: Prisma.SocialProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialProfileCountArgs<ExtArgs>
            result: $Utils.Optional<SocialProfileCountAggregateOutputType> | number
          }
        }
      }
      SocialProof: {
        payload: Prisma.$SocialProofPayload<ExtArgs>
        fields: Prisma.SocialProofFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialProofFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialProofFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>
          }
          findFirst: {
            args: Prisma.SocialProofFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialProofFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>
          }
          findMany: {
            args: Prisma.SocialProofFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>[]
          }
          create: {
            args: Prisma.SocialProofCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>
          }
          createMany: {
            args: Prisma.SocialProofCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialProofCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>[]
          }
          delete: {
            args: Prisma.SocialProofDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>
          }
          update: {
            args: Prisma.SocialProofUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>
          }
          deleteMany: {
            args: Prisma.SocialProofDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialProofUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialProofUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialProofPayload>
          }
          aggregate: {
            args: Prisma.SocialProofAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialProof>
          }
          groupBy: {
            args: Prisma.SocialProofGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialProofGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialProofCountArgs<ExtArgs>
            result: $Utils.Optional<SocialProofCountAggregateOutputType> | number
          }
        }
      }
      AdminSettings: {
        payload: Prisma.$AdminSettingsPayload<ExtArgs>
        fields: Prisma.AdminSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>
          }
          findFirst: {
            args: Prisma.AdminSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>
          }
          findMany: {
            args: Prisma.AdminSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>[]
          }
          create: {
            args: Prisma.AdminSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>
          }
          createMany: {
            args: Prisma.AdminSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>[]
          }
          delete: {
            args: Prisma.AdminSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>
          }
          update: {
            args: Prisma.AdminSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>
          }
          deleteMany: {
            args: Prisma.AdminSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingsPayload>
          }
          aggregate: {
            args: Prisma.AdminSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSettings>
          }
          groupBy: {
            args: Prisma.AdminSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSettingsCountAggregateOutputType> | number
          }
        }
      }
      HomepageContent: {
        payload: Prisma.$HomepageContentPayload<ExtArgs>
        fields: Prisma.HomepageContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomepageContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomepageContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>
          }
          findFirst: {
            args: Prisma.HomepageContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomepageContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>
          }
          findMany: {
            args: Prisma.HomepageContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>[]
          }
          create: {
            args: Prisma.HomepageContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>
          }
          createMany: {
            args: Prisma.HomepageContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomepageContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>[]
          }
          delete: {
            args: Prisma.HomepageContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>
          }
          update: {
            args: Prisma.HomepageContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>
          }
          deleteMany: {
            args: Prisma.HomepageContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomepageContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HomepageContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomepageContentPayload>
          }
          aggregate: {
            args: Prisma.HomepageContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomepageContent>
          }
          groupBy: {
            args: Prisma.HomepageContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomepageContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomepageContentCountArgs<ExtArgs>
            result: $Utils.Optional<HomepageContentCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      HeroSocialUpdate: {
        payload: Prisma.$HeroSocialUpdatePayload<ExtArgs>
        fields: Prisma.HeroSocialUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroSocialUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroSocialUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>
          }
          findFirst: {
            args: Prisma.HeroSocialUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroSocialUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>
          }
          findMany: {
            args: Prisma.HeroSocialUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>[]
          }
          create: {
            args: Prisma.HeroSocialUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>
          }
          createMany: {
            args: Prisma.HeroSocialUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HeroSocialUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>[]
          }
          delete: {
            args: Prisma.HeroSocialUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>
          }
          update: {
            args: Prisma.HeroSocialUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>
          }
          deleteMany: {
            args: Prisma.HeroSocialUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroSocialUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HeroSocialUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSocialUpdatePayload>
          }
          aggregate: {
            args: Prisma.HeroSocialUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroSocialUpdate>
          }
          groupBy: {
            args: Prisma.HeroSocialUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroSocialUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeroSocialUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<HeroSocialUpdateCountAggregateOutputType> | number
          }
        }
      }
      PromoBar: {
        payload: Prisma.$PromoBarPayload<ExtArgs>
        fields: Prisma.PromoBarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoBarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoBarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>
          }
          findFirst: {
            args: Prisma.PromoBarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoBarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>
          }
          findMany: {
            args: Prisma.PromoBarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>[]
          }
          create: {
            args: Prisma.PromoBarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>
          }
          createMany: {
            args: Prisma.PromoBarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoBarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>[]
          }
          delete: {
            args: Prisma.PromoBarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>
          }
          update: {
            args: Prisma.PromoBarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>
          }
          deleteMany: {
            args: Prisma.PromoBarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoBarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromoBarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoBarPayload>
          }
          aggregate: {
            args: Prisma.PromoBarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoBar>
          }
          groupBy: {
            args: Prisma.PromoBarGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoBarGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoBarCountArgs<ExtArgs>
            result: $Utils.Optional<PromoBarCountAggregateOutputType> | number
          }
        }
      }
      FeaturedOn: {
        payload: Prisma.$FeaturedOnPayload<ExtArgs>
        fields: Prisma.FeaturedOnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedOnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedOnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>
          }
          findFirst: {
            args: Prisma.FeaturedOnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedOnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>
          }
          findMany: {
            args: Prisma.FeaturedOnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>[]
          }
          create: {
            args: Prisma.FeaturedOnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>
          }
          createMany: {
            args: Prisma.FeaturedOnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedOnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>[]
          }
          delete: {
            args: Prisma.FeaturedOnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>
          }
          update: {
            args: Prisma.FeaturedOnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedOnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedOnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeaturedOnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPayload>
          }
          aggregate: {
            args: Prisma.FeaturedOnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedOn>
          }
          groupBy: {
            args: Prisma.FeaturedOnGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedOnCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedOnCountAggregateOutputType> | number
          }
        }
      }
      FeaturedOnPageLink: {
        payload: Prisma.$FeaturedOnPageLinkPayload<ExtArgs>
        fields: Prisma.FeaturedOnPageLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedOnPageLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedOnPageLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>
          }
          findFirst: {
            args: Prisma.FeaturedOnPageLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedOnPageLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>
          }
          findMany: {
            args: Prisma.FeaturedOnPageLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>[]
          }
          create: {
            args: Prisma.FeaturedOnPageLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>
          }
          createMany: {
            args: Prisma.FeaturedOnPageLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedOnPageLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>[]
          }
          delete: {
            args: Prisma.FeaturedOnPageLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>
          }
          update: {
            args: Prisma.FeaturedOnPageLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedOnPageLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedOnPageLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeaturedOnPageLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedOnPageLinkPayload>
          }
          aggregate: {
            args: Prisma.FeaturedOnPageLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedOnPageLink>
          }
          groupBy: {
            args: Prisma.FeaturedOnPageLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedOnPageLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedOnPageLinkCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedOnPageLinkCountAggregateOutputType> | number
          }
        }
      }
      PlatformSection: {
        payload: Prisma.$PlatformSectionPayload<ExtArgs>
        fields: Prisma.PlatformSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>
          }
          findFirst: {
            args: Prisma.PlatformSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>
          }
          findMany: {
            args: Prisma.PlatformSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>[]
          }
          create: {
            args: Prisma.PlatformSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>
          }
          createMany: {
            args: Prisma.PlatformSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>[]
          }
          delete: {
            args: Prisma.PlatformSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>
          }
          update: {
            args: Prisma.PlatformSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>
          }
          deleteMany: {
            args: Prisma.PlatformSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlatformSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSectionPayload>
          }
          aggregate: {
            args: Prisma.PlatformSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformSection>
          }
          groupBy: {
            args: Prisma.PlatformSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformSectionCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformSectionCountAggregateOutputType> | number
          }
        }
      }
      GetStartedContent: {
        payload: Prisma.$GetStartedContentPayload<ExtArgs>
        fields: Prisma.GetStartedContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GetStartedContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GetStartedContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>
          }
          findFirst: {
            args: Prisma.GetStartedContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GetStartedContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>
          }
          findMany: {
            args: Prisma.GetStartedContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>[]
          }
          create: {
            args: Prisma.GetStartedContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>
          }
          createMany: {
            args: Prisma.GetStartedContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GetStartedContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>[]
          }
          delete: {
            args: Prisma.GetStartedContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>
          }
          update: {
            args: Prisma.GetStartedContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>
          }
          deleteMany: {
            args: Prisma.GetStartedContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GetStartedContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GetStartedContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetStartedContentPayload>
          }
          aggregate: {
            args: Prisma.GetStartedContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGetStartedContent>
          }
          groupBy: {
            args: Prisma.GetStartedContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<GetStartedContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.GetStartedContentCountArgs<ExtArgs>
            result: $Utils.Optional<GetStartedContentCountAggregateOutputType> | number
          }
        }
      }
      InfluenceSection: {
        payload: Prisma.$InfluenceSectionPayload<ExtArgs>
        fields: Prisma.InfluenceSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfluenceSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfluenceSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>
          }
          findFirst: {
            args: Prisma.InfluenceSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfluenceSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>
          }
          findMany: {
            args: Prisma.InfluenceSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>[]
          }
          create: {
            args: Prisma.InfluenceSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>
          }
          createMany: {
            args: Prisma.InfluenceSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfluenceSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>[]
          }
          delete: {
            args: Prisma.InfluenceSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>
          }
          update: {
            args: Prisma.InfluenceSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>
          }
          deleteMany: {
            args: Prisma.InfluenceSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfluenceSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InfluenceSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluenceSectionPayload>
          }
          aggregate: {
            args: Prisma.InfluenceSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfluenceSection>
          }
          groupBy: {
            args: Prisma.InfluenceSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfluenceSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfluenceSectionCountArgs<ExtArgs>
            result: $Utils.Optional<InfluenceSectionCountAggregateOutputType> | number
          }
        }
      }
      AdvantageSection: {
        payload: Prisma.$AdvantageSectionPayload<ExtArgs>
        fields: Prisma.AdvantageSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvantageSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvantageSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>
          }
          findFirst: {
            args: Prisma.AdvantageSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvantageSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>
          }
          findMany: {
            args: Prisma.AdvantageSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>[]
          }
          create: {
            args: Prisma.AdvantageSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>
          }
          createMany: {
            args: Prisma.AdvantageSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvantageSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>[]
          }
          delete: {
            args: Prisma.AdvantageSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>
          }
          update: {
            args: Prisma.AdvantageSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>
          }
          deleteMany: {
            args: Prisma.AdvantageSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvantageSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvantageSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvantageSectionPayload>
          }
          aggregate: {
            args: Prisma.AdvantageSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvantageSection>
          }
          groupBy: {
            args: Prisma.AdvantageSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvantageSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvantageSectionCountArgs<ExtArgs>
            result: $Utils.Optional<AdvantageSectionCountAggregateOutputType> | number
          }
        }
      }
      QuickStartSection: {
        payload: Prisma.$QuickStartSectionPayload<ExtArgs>
        fields: Prisma.QuickStartSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuickStartSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuickStartSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>
          }
          findFirst: {
            args: Prisma.QuickStartSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuickStartSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>
          }
          findMany: {
            args: Prisma.QuickStartSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>[]
          }
          create: {
            args: Prisma.QuickStartSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>
          }
          createMany: {
            args: Prisma.QuickStartSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuickStartSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>[]
          }
          delete: {
            args: Prisma.QuickStartSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>
          }
          update: {
            args: Prisma.QuickStartSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>
          }
          deleteMany: {
            args: Prisma.QuickStartSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuickStartSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuickStartSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickStartSectionPayload>
          }
          aggregate: {
            args: Prisma.QuickStartSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuickStartSection>
          }
          groupBy: {
            args: Prisma.QuickStartSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuickStartSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuickStartSectionCountArgs<ExtArgs>
            result: $Utils.Optional<QuickStartSectionCountAggregateOutputType> | number
          }
        }
      }
      ServicePageContent: {
        payload: Prisma.$ServicePageContentPayload<ExtArgs>
        fields: Prisma.ServicePageContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePageContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePageContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>
          }
          findFirst: {
            args: Prisma.ServicePageContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePageContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>
          }
          findMany: {
            args: Prisma.ServicePageContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>[]
          }
          create: {
            args: Prisma.ServicePageContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>
          }
          createMany: {
            args: Prisma.ServicePageContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePageContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>[]
          }
          delete: {
            args: Prisma.ServicePageContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>
          }
          update: {
            args: Prisma.ServicePageContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>
          }
          deleteMany: {
            args: Prisma.ServicePageContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePageContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicePageContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePageContentPayload>
          }
          aggregate: {
            args: Prisma.ServicePageContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePageContent>
          }
          groupBy: {
            args: Prisma.ServicePageContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePageContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePageContentCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePageContentCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestimonialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      LegalPage: {
        payload: Prisma.$LegalPagePayload<ExtArgs>
        fields: Prisma.LegalPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LegalPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LegalPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>
          }
          findFirst: {
            args: Prisma.LegalPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LegalPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>
          }
          findMany: {
            args: Prisma.LegalPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>[]
          }
          create: {
            args: Prisma.LegalPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>
          }
          createMany: {
            args: Prisma.LegalPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LegalPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>[]
          }
          delete: {
            args: Prisma.LegalPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>
          }
          update: {
            args: Prisma.LegalPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>
          }
          deleteMany: {
            args: Prisma.LegalPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LegalPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LegalPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalPagePayload>
          }
          aggregate: {
            args: Prisma.LegalPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLegalPage>
          }
          groupBy: {
            args: Prisma.LegalPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LegalPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LegalPageCountArgs<ExtArgs>
            result: $Utils.Optional<LegalPageCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      BellNotification: {
        payload: Prisma.$BellNotificationPayload<ExtArgs>
        fields: Prisma.BellNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BellNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BellNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>
          }
          findFirst: {
            args: Prisma.BellNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BellNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>
          }
          findMany: {
            args: Prisma.BellNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>[]
          }
          create: {
            args: Prisma.BellNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>
          }
          createMany: {
            args: Prisma.BellNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BellNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>[]
          }
          delete: {
            args: Prisma.BellNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>
          }
          update: {
            args: Prisma.BellNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>
          }
          deleteMany: {
            args: Prisma.BellNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BellNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BellNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BellNotificationPayload>
          }
          aggregate: {
            args: Prisma.BellNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBellNotification>
          }
          groupBy: {
            args: Prisma.BellNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BellNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BellNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<BellNotificationCountAggregateOutputType> | number
          }
        }
      }
      BannerMessage: {
        payload: Prisma.$BannerMessagePayload<ExtArgs>
        fields: Prisma.BannerMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>
          }
          findFirst: {
            args: Prisma.BannerMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>
          }
          findMany: {
            args: Prisma.BannerMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>[]
          }
          create: {
            args: Prisma.BannerMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>
          }
          createMany: {
            args: Prisma.BannerMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>[]
          }
          delete: {
            args: Prisma.BannerMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>
          }
          update: {
            args: Prisma.BannerMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>
          }
          deleteMany: {
            args: Prisma.BannerMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerMessagePayload>
          }
          aggregate: {
            args: Prisma.BannerMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerMessage>
          }
          groupBy: {
            args: Prisma.BannerMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerMessageCountArgs<ExtArgs>
            result: $Utils.Optional<BannerMessageCountAggregateOutputType> | number
          }
        }
      }
      IconAsset: {
        payload: Prisma.$IconAssetPayload<ExtArgs>
        fields: Prisma.IconAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IconAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IconAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>
          }
          findFirst: {
            args: Prisma.IconAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IconAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>
          }
          findMany: {
            args: Prisma.IconAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>[]
          }
          create: {
            args: Prisma.IconAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>
          }
          createMany: {
            args: Prisma.IconAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IconAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>[]
          }
          delete: {
            args: Prisma.IconAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>
          }
          update: {
            args: Prisma.IconAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>
          }
          deleteMany: {
            args: Prisma.IconAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IconAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IconAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconAssetPayload>
          }
          aggregate: {
            args: Prisma.IconAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIconAsset>
          }
          groupBy: {
            args: Prisma.IconAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<IconAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.IconAssetCountArgs<ExtArgs>
            result: $Utils.Optional<IconAssetCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      CouponRedemption: {
        payload: Prisma.$CouponRedemptionPayload<ExtArgs>
        fields: Prisma.CouponRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          findFirst: {
            args: Prisma.CouponRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          findMany: {
            args: Prisma.CouponRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>[]
          }
          create: {
            args: Prisma.CouponRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          createMany: {
            args: Prisma.CouponRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>[]
          }
          delete: {
            args: Prisma.CouponRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          update: {
            args: Prisma.CouponRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.CouponRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          aggregate: {
            args: Prisma.CouponRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCouponRedemption>
          }
          groupBy: {
            args: Prisma.CouponRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<CouponRedemptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    blogPosts: number
    orders: number
    reviews: number
    passwordResetTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    reviews: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | OrderCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    orders: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ServiceCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type FeaturedOnCountOutputType
   */

  export type FeaturedOnCountOutputType = {
    pageLinks: number
  }

  export type FeaturedOnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pageLinks?: boolean | FeaturedOnCountOutputTypeCountPageLinksArgs
  }

  // Custom InputTypes
  /**
   * FeaturedOnCountOutputType without action
   */
  export type FeaturedOnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnCountOutputType
     */
    select?: FeaturedOnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeaturedOnCountOutputType without action
   */
  export type FeaturedOnCountOutputTypeCountPageLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedOnPageLinkWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    redemptions: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | CouponCountOutputTypeCountRedemptionsArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    isBlocked: number
    createdAt: number
    updatedAt: number
    avatarUrl: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    role: $Enums.UserRole
    isBlocked: boolean
    createdAt: Date
    updatedAt: Date
    avatarUrl: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      role: $Enums.UserRole
      isBlocked: boolean
      createdAt: Date
      updatedAt: Date
      avatarUrl: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isBlocked: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly avatarUrl: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    quantity: number | null
    price: number | null
    currency: string | null
    status: $Enums.OrderStatus | null
    link: string | null
    japOrderId: string | null
    japStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    quantity: number | null
    price: number | null
    currency: string | null
    status: $Enums.OrderStatus | null
    link: string | null
    japOrderId: string | null
    japStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    platform: number
    serviceType: number
    quantity: number
    price: number
    currency: number
    status: number
    link: number
    japOrderId: number
    japStatus: number
    upsellData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    platform?: true
    serviceType?: true
    quantity?: true
    price?: true
    currency?: true
    status?: true
    link?: true
    japOrderId?: true
    japStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    platform?: true
    serviceType?: true
    quantity?: true
    price?: true
    currency?: true
    status?: true
    link?: true
    japOrderId?: true
    japStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    platform?: true
    serviceType?: true
    quantity?: true
    price?: true
    currency?: true
    status?: true
    link?: true
    japOrderId?: true
    japStatus?: true
    upsellData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency: string
    status: $Enums.OrderStatus
    link: string | null
    japOrderId: string | null
    japStatus: string | null
    upsellData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    platform?: boolean
    serviceType?: boolean
    quantity?: boolean
    price?: boolean
    currency?: boolean
    status?: boolean
    link?: boolean
    japOrderId?: boolean
    japStatus?: boolean
    upsellData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    reviews?: boolean | Order$reviewsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    platform?: boolean
    serviceType?: boolean
    quantity?: boolean
    price?: boolean
    currency?: boolean
    status?: boolean
    link?: boolean
    japOrderId?: boolean
    japStatus?: boolean
    upsellData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    platform?: boolean
    serviceType?: boolean
    quantity?: boolean
    price?: boolean
    currency?: boolean
    status?: boolean
    link?: boolean
    japOrderId?: boolean
    japStatus?: boolean
    upsellData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    reviews?: boolean | Order$reviewsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceId: string
      platform: $Enums.Platform
      serviceType: $Enums.ServiceType
      quantity: number
      price: number
      currency: string
      status: $Enums.OrderStatus
      link: string | null
      japOrderId: string | null
      japStatus: string | null
      upsellData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payment<T extends Order$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends Order$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Order$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly serviceId: FieldRef<"Order", 'String'>
    readonly platform: FieldRef<"Order", 'Platform'>
    readonly serviceType: FieldRef<"Order", 'ServiceType'>
    readonly quantity: FieldRef<"Order", 'Int'>
    readonly price: FieldRef<"Order", 'Float'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly link: FieldRef<"Order", 'String'>
    readonly japOrderId: FieldRef<"Order", 'String'>
    readonly japStatus: FieldRef<"Order", 'String'>
    readonly upsellData: FieldRef<"Order", 'Json'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.payment
   */
  export type Order$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Order.reviews
   */
  export type Order$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    basePrice: number | null
    markup: number | null
    finalPrice: number | null
    minQuantity: number | null
    maxQuantity: number | null
  }

  export type ServiceSumAggregateOutputType = {
    basePrice: number | null
    markup: number | null
    finalPrice: number | null
    minQuantity: number | null
    maxQuantity: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    japServiceId: string | null
    basePrice: number | null
    markup: number | null
    finalPrice: number | null
    minQuantity: number | null
    maxQuantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    japServiceId: string | null
    basePrice: number | null
    markup: number | null
    finalPrice: number | null
    minQuantity: number | null
    maxQuantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    platform: number
    serviceType: number
    japServiceId: number
    basePrice: number
    markup: number
    finalPrice: number
    minQuantity: number
    maxQuantity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    basePrice?: true
    markup?: true
    finalPrice?: true
    minQuantity?: true
    maxQuantity?: true
  }

  export type ServiceSumAggregateInputType = {
    basePrice?: true
    markup?: true
    finalPrice?: true
    minQuantity?: true
    maxQuantity?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    platform?: true
    serviceType?: true
    japServiceId?: true
    basePrice?: true
    markup?: true
    finalPrice?: true
    minQuantity?: true
    maxQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    platform?: true
    serviceType?: true
    japServiceId?: true
    basePrice?: true
    markup?: true
    finalPrice?: true
    minQuantity?: true
    maxQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    platform?: true
    serviceType?: true
    japServiceId?: true
    basePrice?: true
    markup?: true
    finalPrice?: true
    minQuantity?: true
    maxQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    japServiceId: string | null
    basePrice: number
    markup: number
    finalPrice: number
    minQuantity: number | null
    maxQuantity: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    platform?: boolean
    serviceType?: boolean
    japServiceId?: boolean
    basePrice?: boolean
    markup?: boolean
    finalPrice?: boolean
    minQuantity?: boolean
    maxQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | Service$ordersArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    platform?: boolean
    serviceType?: boolean
    japServiceId?: boolean
    basePrice?: boolean
    markup?: boolean
    finalPrice?: boolean
    minQuantity?: boolean
    maxQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    platform?: boolean
    serviceType?: boolean
    japServiceId?: boolean
    basePrice?: boolean
    markup?: boolean
    finalPrice?: boolean
    minQuantity?: boolean
    maxQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Service$ordersArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      platform: $Enums.Platform
      serviceType: $Enums.ServiceType
      japServiceId: string | null
      basePrice: number
      markup: number
      finalPrice: number
      minQuantity: number | null
      maxQuantity: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Service$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Service$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly platform: FieldRef<"Service", 'Platform'>
    readonly serviceType: FieldRef<"Service", 'ServiceType'>
    readonly japServiceId: FieldRef<"Service", 'String'>
    readonly basePrice: FieldRef<"Service", 'Float'>
    readonly markup: FieldRef<"Service", 'Float'>
    readonly finalPrice: FieldRef<"Service", 'Float'>
    readonly minQuantity: FieldRef<"Service", 'Int'>
    readonly maxQuantity: FieldRef<"Service", 'Int'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.orders
   */
  export type Service$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    gateway: $Enums.PaymentGateway | null
    transactionId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    gateway: $Enums.PaymentGateway | null
    transactionId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    gateway: number
    transactionId: number
    amount: number
    currency: number
    status: number
    webhookData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    gateway?: true
    transactionId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    gateway?: true
    transactionId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    gateway?: true
    transactionId?: true
    amount?: true
    currency?: true
    status?: true
    webhookData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderId: string
    gateway: $Enums.PaymentGateway
    transactionId: string | null
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    webhookData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    gateway?: boolean
    transactionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    webhookData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    gateway?: boolean
    transactionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    webhookData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    gateway?: boolean
    transactionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    webhookData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      gateway: $Enums.PaymentGateway
      transactionId: string | null
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      webhookData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly gateway: FieldRef<"Payment", 'PaymentGateway'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly webhookData: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Upsell
   */

  export type AggregateUpsell = {
    _count: UpsellCountAggregateOutputType | null
    _avg: UpsellAvgAggregateOutputType | null
    _sum: UpsellSumAggregateOutputType | null
    _min: UpsellMinAggregateOutputType | null
    _max: UpsellMaxAggregateOutputType | null
  }

  export type UpsellAvgAggregateOutputType = {
    basePrice: number | null
    discountValue: number | null
    minSubtotal: number | null
    sortOrder: number | null
  }

  export type UpsellSumAggregateOutputType = {
    basePrice: number | null
    discountValue: number | null
    minSubtotal: number | null
    sortOrder: number | null
  }

  export type UpsellMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    serviceId: string | null
    packageId: string | null
    basePrice: number | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    badgeText: string | null
    badgeColor: string | null
    badgeIcon: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    minSubtotal: number | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UpsellMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    serviceId: string | null
    packageId: string | null
    basePrice: number | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    badgeText: string | null
    badgeColor: string | null
    badgeIcon: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    minSubtotal: number | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UpsellCountAggregateOutputType = {
    id: number
    title: number
    description: number
    serviceId: number
    packageId: number
    basePrice: number
    discountType: number
    discountValue: number
    badgeText: number
    badgeColor: number
    badgeIcon: number
    platform: number
    serviceType: number
    minSubtotal: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UpsellAvgAggregateInputType = {
    basePrice?: true
    discountValue?: true
    minSubtotal?: true
    sortOrder?: true
  }

  export type UpsellSumAggregateInputType = {
    basePrice?: true
    discountValue?: true
    minSubtotal?: true
    sortOrder?: true
  }

  export type UpsellMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    serviceId?: true
    packageId?: true
    basePrice?: true
    discountType?: true
    discountValue?: true
    badgeText?: true
    badgeColor?: true
    badgeIcon?: true
    platform?: true
    serviceType?: true
    minSubtotal?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UpsellMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    serviceId?: true
    packageId?: true
    basePrice?: true
    discountType?: true
    discountValue?: true
    badgeText?: true
    badgeColor?: true
    badgeIcon?: true
    platform?: true
    serviceType?: true
    minSubtotal?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UpsellCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    serviceId?: true
    packageId?: true
    basePrice?: true
    discountType?: true
    discountValue?: true
    badgeText?: true
    badgeColor?: true
    badgeIcon?: true
    platform?: true
    serviceType?: true
    minSubtotal?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UpsellAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Upsell to aggregate.
     */
    where?: UpsellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Upsells to fetch.
     */
    orderBy?: UpsellOrderByWithRelationInput | UpsellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UpsellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Upsells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Upsells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Upsells
    **/
    _count?: true | UpsellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UpsellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UpsellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpsellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpsellMaxAggregateInputType
  }

  export type GetUpsellAggregateType<T extends UpsellAggregateArgs> = {
        [P in keyof T & keyof AggregateUpsell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpsell[P]>
      : GetScalarType<T[P], AggregateUpsell[P]>
  }




  export type UpsellGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpsellWhereInput
    orderBy?: UpsellOrderByWithAggregationInput | UpsellOrderByWithAggregationInput[]
    by: UpsellScalarFieldEnum[] | UpsellScalarFieldEnum
    having?: UpsellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpsellCountAggregateInputType | true
    _avg?: UpsellAvgAggregateInputType
    _sum?: UpsellSumAggregateInputType
    _min?: UpsellMinAggregateInputType
    _max?: UpsellMaxAggregateInputType
  }

  export type UpsellGroupByOutputType = {
    id: string
    title: string
    description: string | null
    serviceId: string | null
    packageId: string | null
    basePrice: number
    discountType: $Enums.DiscountType
    discountValue: number
    badgeText: string | null
    badgeColor: string | null
    badgeIcon: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    minSubtotal: number | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: UpsellCountAggregateOutputType | null
    _avg: UpsellAvgAggregateOutputType | null
    _sum: UpsellSumAggregateOutputType | null
    _min: UpsellMinAggregateOutputType | null
    _max: UpsellMaxAggregateOutputType | null
  }

  type GetUpsellGroupByPayload<T extends UpsellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpsellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpsellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpsellGroupByOutputType[P]>
            : GetScalarType<T[P], UpsellGroupByOutputType[P]>
        }
      >
    >


  export type UpsellSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    serviceId?: boolean
    packageId?: boolean
    basePrice?: boolean
    discountType?: boolean
    discountValue?: boolean
    badgeText?: boolean
    badgeColor?: boolean
    badgeIcon?: boolean
    platform?: boolean
    serviceType?: boolean
    minSubtotal?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["upsell"]>

  export type UpsellSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    serviceId?: boolean
    packageId?: boolean
    basePrice?: boolean
    discountType?: boolean
    discountValue?: boolean
    badgeText?: boolean
    badgeColor?: boolean
    badgeIcon?: boolean
    platform?: boolean
    serviceType?: boolean
    minSubtotal?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["upsell"]>

  export type UpsellSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    serviceId?: boolean
    packageId?: boolean
    basePrice?: boolean
    discountType?: boolean
    discountValue?: boolean
    badgeText?: boolean
    badgeColor?: boolean
    badgeIcon?: boolean
    platform?: boolean
    serviceType?: boolean
    minSubtotal?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UpsellPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Upsell"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      serviceId: string | null
      packageId: string | null
      basePrice: number
      discountType: $Enums.DiscountType
      discountValue: number
      badgeText: string | null
      badgeColor: string | null
      badgeIcon: string | null
      platform: $Enums.Platform | null
      serviceType: $Enums.ServiceType | null
      minSubtotal: number | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["upsell"]>
    composites: {}
  }

  type UpsellGetPayload<S extends boolean | null | undefined | UpsellDefaultArgs> = $Result.GetResult<Prisma.$UpsellPayload, S>

  type UpsellCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UpsellFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UpsellCountAggregateInputType | true
    }

  export interface UpsellDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Upsell'], meta: { name: 'Upsell' } }
    /**
     * Find zero or one Upsell that matches the filter.
     * @param {UpsellFindUniqueArgs} args - Arguments to find a Upsell
     * @example
     * // Get one Upsell
     * const upsell = await prisma.upsell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UpsellFindUniqueArgs>(args: SelectSubset<T, UpsellFindUniqueArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Upsell that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UpsellFindUniqueOrThrowArgs} args - Arguments to find a Upsell
     * @example
     * // Get one Upsell
     * const upsell = await prisma.upsell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UpsellFindUniqueOrThrowArgs>(args: SelectSubset<T, UpsellFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Upsell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpsellFindFirstArgs} args - Arguments to find a Upsell
     * @example
     * // Get one Upsell
     * const upsell = await prisma.upsell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UpsellFindFirstArgs>(args?: SelectSubset<T, UpsellFindFirstArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Upsell that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpsellFindFirstOrThrowArgs} args - Arguments to find a Upsell
     * @example
     * // Get one Upsell
     * const upsell = await prisma.upsell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UpsellFindFirstOrThrowArgs>(args?: SelectSubset<T, UpsellFindFirstOrThrowArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Upsells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpsellFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Upsells
     * const upsells = await prisma.upsell.findMany()
     * 
     * // Get first 10 Upsells
     * const upsells = await prisma.upsell.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const upsellWithIdOnly = await prisma.upsell.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UpsellFindManyArgs>(args?: SelectSubset<T, UpsellFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Upsell.
     * @param {UpsellCreateArgs} args - Arguments to create a Upsell.
     * @example
     * // Create one Upsell
     * const Upsell = await prisma.upsell.create({
     *   data: {
     *     // ... data to create a Upsell
     *   }
     * })
     * 
     */
    create<T extends UpsellCreateArgs>(args: SelectSubset<T, UpsellCreateArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Upsells.
     * @param {UpsellCreateManyArgs} args - Arguments to create many Upsells.
     * @example
     * // Create many Upsells
     * const upsell = await prisma.upsell.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UpsellCreateManyArgs>(args?: SelectSubset<T, UpsellCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Upsells and returns the data saved in the database.
     * @param {UpsellCreateManyAndReturnArgs} args - Arguments to create many Upsells.
     * @example
     * // Create many Upsells
     * const upsell = await prisma.upsell.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Upsells and only return the `id`
     * const upsellWithIdOnly = await prisma.upsell.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UpsellCreateManyAndReturnArgs>(args?: SelectSubset<T, UpsellCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Upsell.
     * @param {UpsellDeleteArgs} args - Arguments to delete one Upsell.
     * @example
     * // Delete one Upsell
     * const Upsell = await prisma.upsell.delete({
     *   where: {
     *     // ... filter to delete one Upsell
     *   }
     * })
     * 
     */
    delete<T extends UpsellDeleteArgs>(args: SelectSubset<T, UpsellDeleteArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Upsell.
     * @param {UpsellUpdateArgs} args - Arguments to update one Upsell.
     * @example
     * // Update one Upsell
     * const upsell = await prisma.upsell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UpsellUpdateArgs>(args: SelectSubset<T, UpsellUpdateArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Upsells.
     * @param {UpsellDeleteManyArgs} args - Arguments to filter Upsells to delete.
     * @example
     * // Delete a few Upsells
     * const { count } = await prisma.upsell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UpsellDeleteManyArgs>(args?: SelectSubset<T, UpsellDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Upsells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpsellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Upsells
     * const upsell = await prisma.upsell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UpsellUpdateManyArgs>(args: SelectSubset<T, UpsellUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Upsell.
     * @param {UpsellUpsertArgs} args - Arguments to update or create a Upsell.
     * @example
     * // Update or create a Upsell
     * const upsell = await prisma.upsell.upsert({
     *   create: {
     *     // ... data to create a Upsell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upsell we want to update
     *   }
     * })
     */
    upsert<T extends UpsellUpsertArgs>(args: SelectSubset<T, UpsellUpsertArgs<ExtArgs>>): Prisma__UpsellClient<$Result.GetResult<Prisma.$UpsellPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Upsells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpsellCountArgs} args - Arguments to filter Upsells to count.
     * @example
     * // Count the number of Upsells
     * const count = await prisma.upsell.count({
     *   where: {
     *     // ... the filter for the Upsells we want to count
     *   }
     * })
    **/
    count<T extends UpsellCountArgs>(
      args?: Subset<T, UpsellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpsellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upsell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpsellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpsellAggregateArgs>(args: Subset<T, UpsellAggregateArgs>): Prisma.PrismaPromise<GetUpsellAggregateType<T>>

    /**
     * Group by Upsell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpsellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UpsellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UpsellGroupByArgs['orderBy'] }
        : { orderBy?: UpsellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UpsellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpsellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Upsell model
   */
  readonly fields: UpsellFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Upsell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UpsellClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Upsell model
   */ 
  interface UpsellFieldRefs {
    readonly id: FieldRef<"Upsell", 'String'>
    readonly title: FieldRef<"Upsell", 'String'>
    readonly description: FieldRef<"Upsell", 'String'>
    readonly serviceId: FieldRef<"Upsell", 'String'>
    readonly packageId: FieldRef<"Upsell", 'String'>
    readonly basePrice: FieldRef<"Upsell", 'Float'>
    readonly discountType: FieldRef<"Upsell", 'DiscountType'>
    readonly discountValue: FieldRef<"Upsell", 'Float'>
    readonly badgeText: FieldRef<"Upsell", 'String'>
    readonly badgeColor: FieldRef<"Upsell", 'String'>
    readonly badgeIcon: FieldRef<"Upsell", 'String'>
    readonly platform: FieldRef<"Upsell", 'Platform'>
    readonly serviceType: FieldRef<"Upsell", 'ServiceType'>
    readonly minSubtotal: FieldRef<"Upsell", 'Float'>
    readonly isActive: FieldRef<"Upsell", 'Boolean'>
    readonly sortOrder: FieldRef<"Upsell", 'Int'>
    readonly createdAt: FieldRef<"Upsell", 'DateTime'>
    readonly updatedAt: FieldRef<"Upsell", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Upsell findUnique
   */
  export type UpsellFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * Filter, which Upsell to fetch.
     */
    where: UpsellWhereUniqueInput
  }

  /**
   * Upsell findUniqueOrThrow
   */
  export type UpsellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * Filter, which Upsell to fetch.
     */
    where: UpsellWhereUniqueInput
  }

  /**
   * Upsell findFirst
   */
  export type UpsellFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * Filter, which Upsell to fetch.
     */
    where?: UpsellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Upsells to fetch.
     */
    orderBy?: UpsellOrderByWithRelationInput | UpsellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Upsells.
     */
    cursor?: UpsellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Upsells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Upsells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Upsells.
     */
    distinct?: UpsellScalarFieldEnum | UpsellScalarFieldEnum[]
  }

  /**
   * Upsell findFirstOrThrow
   */
  export type UpsellFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * Filter, which Upsell to fetch.
     */
    where?: UpsellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Upsells to fetch.
     */
    orderBy?: UpsellOrderByWithRelationInput | UpsellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Upsells.
     */
    cursor?: UpsellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Upsells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Upsells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Upsells.
     */
    distinct?: UpsellScalarFieldEnum | UpsellScalarFieldEnum[]
  }

  /**
   * Upsell findMany
   */
  export type UpsellFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * Filter, which Upsells to fetch.
     */
    where?: UpsellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Upsells to fetch.
     */
    orderBy?: UpsellOrderByWithRelationInput | UpsellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Upsells.
     */
    cursor?: UpsellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Upsells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Upsells.
     */
    skip?: number
    distinct?: UpsellScalarFieldEnum | UpsellScalarFieldEnum[]
  }

  /**
   * Upsell create
   */
  export type UpsellCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * The data needed to create a Upsell.
     */
    data: XOR<UpsellCreateInput, UpsellUncheckedCreateInput>
  }

  /**
   * Upsell createMany
   */
  export type UpsellCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Upsells.
     */
    data: UpsellCreateManyInput | UpsellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Upsell createManyAndReturn
   */
  export type UpsellCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Upsells.
     */
    data: UpsellCreateManyInput | UpsellCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Upsell update
   */
  export type UpsellUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * The data needed to update a Upsell.
     */
    data: XOR<UpsellUpdateInput, UpsellUncheckedUpdateInput>
    /**
     * Choose, which Upsell to update.
     */
    where: UpsellWhereUniqueInput
  }

  /**
   * Upsell updateMany
   */
  export type UpsellUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Upsells.
     */
    data: XOR<UpsellUpdateManyMutationInput, UpsellUncheckedUpdateManyInput>
    /**
     * Filter which Upsells to update
     */
    where?: UpsellWhereInput
  }

  /**
   * Upsell upsert
   */
  export type UpsellUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * The filter to search for the Upsell to update in case it exists.
     */
    where: UpsellWhereUniqueInput
    /**
     * In case the Upsell found by the `where` argument doesn't exist, create a new Upsell with this data.
     */
    create: XOR<UpsellCreateInput, UpsellUncheckedCreateInput>
    /**
     * In case the Upsell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UpsellUpdateInput, UpsellUncheckedUpdateInput>
  }

  /**
   * Upsell delete
   */
  export type UpsellDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
    /**
     * Filter which Upsell to delete.
     */
    where: UpsellWhereUniqueInput
  }

  /**
   * Upsell deleteMany
   */
  export type UpsellDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Upsells to delete
     */
    where?: UpsellWhereInput
  }

  /**
   * Upsell without action
   */
  export type UpsellDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upsell
     */
    select?: UpsellSelect<ExtArgs> | null
  }


  /**
   * Model SocialProfile
   */

  export type AggregateSocialProfile = {
    _count: SocialProfileCountAggregateOutputType | null
    _min: SocialProfileMinAggregateOutputType | null
    _max: SocialProfileMaxAggregateOutputType | null
  }

  export type SocialProfileMinAggregateOutputType = {
    id: string | null
    platform: $Enums.Platform | null
    username: string | null
    cachedAt: Date | null
    expiresAt: Date | null
  }

  export type SocialProfileMaxAggregateOutputType = {
    id: string | null
    platform: $Enums.Platform | null
    username: string | null
    cachedAt: Date | null
    expiresAt: Date | null
  }

  export type SocialProfileCountAggregateOutputType = {
    id: number
    platform: number
    username: number
    profileData: number
    posts: number
    cachedAt: number
    expiresAt: number
    _all: number
  }


  export type SocialProfileMinAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    cachedAt?: true
    expiresAt?: true
  }

  export type SocialProfileMaxAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    cachedAt?: true
    expiresAt?: true
  }

  export type SocialProfileCountAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    profileData?: true
    posts?: true
    cachedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SocialProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialProfile to aggregate.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialProfiles
    **/
    _count?: true | SocialProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialProfileMaxAggregateInputType
  }

  export type GetSocialProfileAggregateType<T extends SocialProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialProfile[P]>
      : GetScalarType<T[P], AggregateSocialProfile[P]>
  }




  export type SocialProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialProfileWhereInput
    orderBy?: SocialProfileOrderByWithAggregationInput | SocialProfileOrderByWithAggregationInput[]
    by: SocialProfileScalarFieldEnum[] | SocialProfileScalarFieldEnum
    having?: SocialProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialProfileCountAggregateInputType | true
    _min?: SocialProfileMinAggregateInputType
    _max?: SocialProfileMaxAggregateInputType
  }

  export type SocialProfileGroupByOutputType = {
    id: string
    platform: $Enums.Platform
    username: string
    profileData: JsonValue
    posts: JsonValue | null
    cachedAt: Date
    expiresAt: Date
    _count: SocialProfileCountAggregateOutputType | null
    _min: SocialProfileMinAggregateOutputType | null
    _max: SocialProfileMaxAggregateOutputType | null
  }

  type GetSocialProfileGroupByPayload<T extends SocialProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialProfileGroupByOutputType[P]>
            : GetScalarType<T[P], SocialProfileGroupByOutputType[P]>
        }
      >
    >


  export type SocialProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    username?: boolean
    profileData?: boolean
    posts?: boolean
    cachedAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["socialProfile"]>

  export type SocialProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    username?: boolean
    profileData?: boolean
    posts?: boolean
    cachedAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["socialProfile"]>

  export type SocialProfileSelectScalar = {
    id?: boolean
    platform?: boolean
    username?: boolean
    profileData?: boolean
    posts?: boolean
    cachedAt?: boolean
    expiresAt?: boolean
  }


  export type $SocialProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: $Enums.Platform
      username: string
      profileData: Prisma.JsonValue
      posts: Prisma.JsonValue | null
      cachedAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["socialProfile"]>
    composites: {}
  }

  type SocialProfileGetPayload<S extends boolean | null | undefined | SocialProfileDefaultArgs> = $Result.GetResult<Prisma.$SocialProfilePayload, S>

  type SocialProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SocialProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SocialProfileCountAggregateInputType | true
    }

  export interface SocialProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialProfile'], meta: { name: 'SocialProfile' } }
    /**
     * Find zero or one SocialProfile that matches the filter.
     * @param {SocialProfileFindUniqueArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialProfileFindUniqueArgs>(args: SelectSubset<T, SocialProfileFindUniqueArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SocialProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SocialProfileFindUniqueOrThrowArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SocialProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileFindFirstArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialProfileFindFirstArgs>(args?: SelectSubset<T, SocialProfileFindFirstArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SocialProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileFindFirstOrThrowArgs} args - Arguments to find a SocialProfile
     * @example
     * // Get one SocialProfile
     * const socialProfile = await prisma.socialProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SocialProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialProfiles
     * const socialProfiles = await prisma.socialProfile.findMany()
     * 
     * // Get first 10 SocialProfiles
     * const socialProfiles = await prisma.socialProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialProfileWithIdOnly = await prisma.socialProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialProfileFindManyArgs>(args?: SelectSubset<T, SocialProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SocialProfile.
     * @param {SocialProfileCreateArgs} args - Arguments to create a SocialProfile.
     * @example
     * // Create one SocialProfile
     * const SocialProfile = await prisma.socialProfile.create({
     *   data: {
     *     // ... data to create a SocialProfile
     *   }
     * })
     * 
     */
    create<T extends SocialProfileCreateArgs>(args: SelectSubset<T, SocialProfileCreateArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SocialProfiles.
     * @param {SocialProfileCreateManyArgs} args - Arguments to create many SocialProfiles.
     * @example
     * // Create many SocialProfiles
     * const socialProfile = await prisma.socialProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialProfileCreateManyArgs>(args?: SelectSubset<T, SocialProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialProfiles and returns the data saved in the database.
     * @param {SocialProfileCreateManyAndReturnArgs} args - Arguments to create many SocialProfiles.
     * @example
     * // Create many SocialProfiles
     * const socialProfile = await prisma.socialProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialProfiles and only return the `id`
     * const socialProfileWithIdOnly = await prisma.socialProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SocialProfile.
     * @param {SocialProfileDeleteArgs} args - Arguments to delete one SocialProfile.
     * @example
     * // Delete one SocialProfile
     * const SocialProfile = await prisma.socialProfile.delete({
     *   where: {
     *     // ... filter to delete one SocialProfile
     *   }
     * })
     * 
     */
    delete<T extends SocialProfileDeleteArgs>(args: SelectSubset<T, SocialProfileDeleteArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SocialProfile.
     * @param {SocialProfileUpdateArgs} args - Arguments to update one SocialProfile.
     * @example
     * // Update one SocialProfile
     * const socialProfile = await prisma.socialProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialProfileUpdateArgs>(args: SelectSubset<T, SocialProfileUpdateArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SocialProfiles.
     * @param {SocialProfileDeleteManyArgs} args - Arguments to filter SocialProfiles to delete.
     * @example
     * // Delete a few SocialProfiles
     * const { count } = await prisma.socialProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialProfileDeleteManyArgs>(args?: SelectSubset<T, SocialProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialProfiles
     * const socialProfile = await prisma.socialProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialProfileUpdateManyArgs>(args: SelectSubset<T, SocialProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialProfile.
     * @param {SocialProfileUpsertArgs} args - Arguments to update or create a SocialProfile.
     * @example
     * // Update or create a SocialProfile
     * const socialProfile = await prisma.socialProfile.upsert({
     *   create: {
     *     // ... data to create a SocialProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialProfile we want to update
     *   }
     * })
     */
    upsert<T extends SocialProfileUpsertArgs>(args: SelectSubset<T, SocialProfileUpsertArgs<ExtArgs>>): Prisma__SocialProfileClient<$Result.GetResult<Prisma.$SocialProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SocialProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileCountArgs} args - Arguments to filter SocialProfiles to count.
     * @example
     * // Count the number of SocialProfiles
     * const count = await prisma.socialProfile.count({
     *   where: {
     *     // ... the filter for the SocialProfiles we want to count
     *   }
     * })
    **/
    count<T extends SocialProfileCountArgs>(
      args?: Subset<T, SocialProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialProfileAggregateArgs>(args: Subset<T, SocialProfileAggregateArgs>): Prisma.PrismaPromise<GetSocialProfileAggregateType<T>>

    /**
     * Group by SocialProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialProfileGroupByArgs['orderBy'] }
        : { orderBy?: SocialProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialProfile model
   */
  readonly fields: SocialProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialProfile model
   */ 
  interface SocialProfileFieldRefs {
    readonly id: FieldRef<"SocialProfile", 'String'>
    readonly platform: FieldRef<"SocialProfile", 'Platform'>
    readonly username: FieldRef<"SocialProfile", 'String'>
    readonly profileData: FieldRef<"SocialProfile", 'Json'>
    readonly posts: FieldRef<"SocialProfile", 'Json'>
    readonly cachedAt: FieldRef<"SocialProfile", 'DateTime'>
    readonly expiresAt: FieldRef<"SocialProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialProfile findUnique
   */
  export type SocialProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile findUniqueOrThrow
   */
  export type SocialProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile findFirst
   */
  export type SocialProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialProfiles.
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialProfiles.
     */
    distinct?: SocialProfileScalarFieldEnum | SocialProfileScalarFieldEnum[]
  }

  /**
   * SocialProfile findFirstOrThrow
   */
  export type SocialProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Filter, which SocialProfile to fetch.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialProfiles.
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialProfiles.
     */
    distinct?: SocialProfileScalarFieldEnum | SocialProfileScalarFieldEnum[]
  }

  /**
   * SocialProfile findMany
   */
  export type SocialProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Filter, which SocialProfiles to fetch.
     */
    where?: SocialProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProfiles to fetch.
     */
    orderBy?: SocialProfileOrderByWithRelationInput | SocialProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialProfiles.
     */
    cursor?: SocialProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProfiles.
     */
    skip?: number
    distinct?: SocialProfileScalarFieldEnum | SocialProfileScalarFieldEnum[]
  }

  /**
   * SocialProfile create
   */
  export type SocialProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * The data needed to create a SocialProfile.
     */
    data: XOR<SocialProfileCreateInput, SocialProfileUncheckedCreateInput>
  }

  /**
   * SocialProfile createMany
   */
  export type SocialProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialProfiles.
     */
    data: SocialProfileCreateManyInput | SocialProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialProfile createManyAndReturn
   */
  export type SocialProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SocialProfiles.
     */
    data: SocialProfileCreateManyInput | SocialProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialProfile update
   */
  export type SocialProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * The data needed to update a SocialProfile.
     */
    data: XOR<SocialProfileUpdateInput, SocialProfileUncheckedUpdateInput>
    /**
     * Choose, which SocialProfile to update.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile updateMany
   */
  export type SocialProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialProfiles.
     */
    data: XOR<SocialProfileUpdateManyMutationInput, SocialProfileUncheckedUpdateManyInput>
    /**
     * Filter which SocialProfiles to update
     */
    where?: SocialProfileWhereInput
  }

  /**
   * SocialProfile upsert
   */
  export type SocialProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * The filter to search for the SocialProfile to update in case it exists.
     */
    where: SocialProfileWhereUniqueInput
    /**
     * In case the SocialProfile found by the `where` argument doesn't exist, create a new SocialProfile with this data.
     */
    create: XOR<SocialProfileCreateInput, SocialProfileUncheckedCreateInput>
    /**
     * In case the SocialProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialProfileUpdateInput, SocialProfileUncheckedUpdateInput>
  }

  /**
   * SocialProfile delete
   */
  export type SocialProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
    /**
     * Filter which SocialProfile to delete.
     */
    where: SocialProfileWhereUniqueInput
  }

  /**
   * SocialProfile deleteMany
   */
  export type SocialProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialProfiles to delete
     */
    where?: SocialProfileWhereInput
  }

  /**
   * SocialProfile without action
   */
  export type SocialProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProfile
     */
    select?: SocialProfileSelect<ExtArgs> | null
  }


  /**
   * Model SocialProof
   */

  export type AggregateSocialProof = {
    _count: SocialProofCountAggregateOutputType | null
    _avg: SocialProofAvgAggregateOutputType | null
    _sum: SocialProofSumAggregateOutputType | null
    _min: SocialProofMinAggregateOutputType | null
    _max: SocialProofMaxAggregateOutputType | null
  }

  export type SocialProofAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type SocialProofSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type SocialProofMinAggregateOutputType = {
    id: string | null
    platform: string | null
    username: string | null
    service: string | null
    timeText: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialProofMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    username: string | null
    service: string | null
    timeText: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialProofCountAggregateOutputType = {
    id: number
    platform: number
    username: number
    service: number
    timeText: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialProofAvgAggregateInputType = {
    displayOrder?: true
  }

  export type SocialProofSumAggregateInputType = {
    displayOrder?: true
  }

  export type SocialProofMinAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    service?: true
    timeText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialProofMaxAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    service?: true
    timeText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialProofCountAggregateInputType = {
    id?: true
    platform?: true
    username?: true
    service?: true
    timeText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialProofAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialProof to aggregate.
     */
    where?: SocialProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProofs to fetch.
     */
    orderBy?: SocialProofOrderByWithRelationInput | SocialProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialProofs
    **/
    _count?: true | SocialProofCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialProofAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialProofSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialProofMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialProofMaxAggregateInputType
  }

  export type GetSocialProofAggregateType<T extends SocialProofAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialProof]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialProof[P]>
      : GetScalarType<T[P], AggregateSocialProof[P]>
  }




  export type SocialProofGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialProofWhereInput
    orderBy?: SocialProofOrderByWithAggregationInput | SocialProofOrderByWithAggregationInput[]
    by: SocialProofScalarFieldEnum[] | SocialProofScalarFieldEnum
    having?: SocialProofScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialProofCountAggregateInputType | true
    _avg?: SocialProofAvgAggregateInputType
    _sum?: SocialProofSumAggregateInputType
    _min?: SocialProofMinAggregateInputType
    _max?: SocialProofMaxAggregateInputType
  }

  export type SocialProofGroupByOutputType = {
    id: string
    platform: string
    username: string
    service: string
    timeText: string
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: SocialProofCountAggregateOutputType | null
    _avg: SocialProofAvgAggregateOutputType | null
    _sum: SocialProofSumAggregateOutputType | null
    _min: SocialProofMinAggregateOutputType | null
    _max: SocialProofMaxAggregateOutputType | null
  }

  type GetSocialProofGroupByPayload<T extends SocialProofGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialProofGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialProofGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialProofGroupByOutputType[P]>
            : GetScalarType<T[P], SocialProofGroupByOutputType[P]>
        }
      >
    >


  export type SocialProofSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    username?: boolean
    service?: boolean
    timeText?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialProof"]>

  export type SocialProofSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    username?: boolean
    service?: boolean
    timeText?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialProof"]>

  export type SocialProofSelectScalar = {
    id?: boolean
    platform?: boolean
    username?: boolean
    service?: boolean
    timeText?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SocialProofPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialProof"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      username: string
      service: string
      timeText: string
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialProof"]>
    composites: {}
  }

  type SocialProofGetPayload<S extends boolean | null | undefined | SocialProofDefaultArgs> = $Result.GetResult<Prisma.$SocialProofPayload, S>

  type SocialProofCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SocialProofFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SocialProofCountAggregateInputType | true
    }

  export interface SocialProofDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialProof'], meta: { name: 'SocialProof' } }
    /**
     * Find zero or one SocialProof that matches the filter.
     * @param {SocialProofFindUniqueArgs} args - Arguments to find a SocialProof
     * @example
     * // Get one SocialProof
     * const socialProof = await prisma.socialProof.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialProofFindUniqueArgs>(args: SelectSubset<T, SocialProofFindUniqueArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SocialProof that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SocialProofFindUniqueOrThrowArgs} args - Arguments to find a SocialProof
     * @example
     * // Get one SocialProof
     * const socialProof = await prisma.socialProof.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialProofFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialProofFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SocialProof that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProofFindFirstArgs} args - Arguments to find a SocialProof
     * @example
     * // Get one SocialProof
     * const socialProof = await prisma.socialProof.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialProofFindFirstArgs>(args?: SelectSubset<T, SocialProofFindFirstArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SocialProof that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProofFindFirstOrThrowArgs} args - Arguments to find a SocialProof
     * @example
     * // Get one SocialProof
     * const socialProof = await prisma.socialProof.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialProofFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialProofFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SocialProofs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProofFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialProofs
     * const socialProofs = await prisma.socialProof.findMany()
     * 
     * // Get first 10 SocialProofs
     * const socialProofs = await prisma.socialProof.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialProofWithIdOnly = await prisma.socialProof.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialProofFindManyArgs>(args?: SelectSubset<T, SocialProofFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SocialProof.
     * @param {SocialProofCreateArgs} args - Arguments to create a SocialProof.
     * @example
     * // Create one SocialProof
     * const SocialProof = await prisma.socialProof.create({
     *   data: {
     *     // ... data to create a SocialProof
     *   }
     * })
     * 
     */
    create<T extends SocialProofCreateArgs>(args: SelectSubset<T, SocialProofCreateArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SocialProofs.
     * @param {SocialProofCreateManyArgs} args - Arguments to create many SocialProofs.
     * @example
     * // Create many SocialProofs
     * const socialProof = await prisma.socialProof.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialProofCreateManyArgs>(args?: SelectSubset<T, SocialProofCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialProofs and returns the data saved in the database.
     * @param {SocialProofCreateManyAndReturnArgs} args - Arguments to create many SocialProofs.
     * @example
     * // Create many SocialProofs
     * const socialProof = await prisma.socialProof.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialProofs and only return the `id`
     * const socialProofWithIdOnly = await prisma.socialProof.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialProofCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialProofCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SocialProof.
     * @param {SocialProofDeleteArgs} args - Arguments to delete one SocialProof.
     * @example
     * // Delete one SocialProof
     * const SocialProof = await prisma.socialProof.delete({
     *   where: {
     *     // ... filter to delete one SocialProof
     *   }
     * })
     * 
     */
    delete<T extends SocialProofDeleteArgs>(args: SelectSubset<T, SocialProofDeleteArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SocialProof.
     * @param {SocialProofUpdateArgs} args - Arguments to update one SocialProof.
     * @example
     * // Update one SocialProof
     * const socialProof = await prisma.socialProof.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialProofUpdateArgs>(args: SelectSubset<T, SocialProofUpdateArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SocialProofs.
     * @param {SocialProofDeleteManyArgs} args - Arguments to filter SocialProofs to delete.
     * @example
     * // Delete a few SocialProofs
     * const { count } = await prisma.socialProof.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialProofDeleteManyArgs>(args?: SelectSubset<T, SocialProofDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProofUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialProofs
     * const socialProof = await prisma.socialProof.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialProofUpdateManyArgs>(args: SelectSubset<T, SocialProofUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialProof.
     * @param {SocialProofUpsertArgs} args - Arguments to update or create a SocialProof.
     * @example
     * // Update or create a SocialProof
     * const socialProof = await prisma.socialProof.upsert({
     *   create: {
     *     // ... data to create a SocialProof
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialProof we want to update
     *   }
     * })
     */
    upsert<T extends SocialProofUpsertArgs>(args: SelectSubset<T, SocialProofUpsertArgs<ExtArgs>>): Prisma__SocialProofClient<$Result.GetResult<Prisma.$SocialProofPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SocialProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProofCountArgs} args - Arguments to filter SocialProofs to count.
     * @example
     * // Count the number of SocialProofs
     * const count = await prisma.socialProof.count({
     *   where: {
     *     // ... the filter for the SocialProofs we want to count
     *   }
     * })
    **/
    count<T extends SocialProofCountArgs>(
      args?: Subset<T, SocialProofCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialProofCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProofAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialProofAggregateArgs>(args: Subset<T, SocialProofAggregateArgs>): Prisma.PrismaPromise<GetSocialProofAggregateType<T>>

    /**
     * Group by SocialProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialProofGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialProofGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialProofGroupByArgs['orderBy'] }
        : { orderBy?: SocialProofGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialProofGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialProofGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialProof model
   */
  readonly fields: SocialProofFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialProof.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialProofClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialProof model
   */ 
  interface SocialProofFieldRefs {
    readonly id: FieldRef<"SocialProof", 'String'>
    readonly platform: FieldRef<"SocialProof", 'String'>
    readonly username: FieldRef<"SocialProof", 'String'>
    readonly service: FieldRef<"SocialProof", 'String'>
    readonly timeText: FieldRef<"SocialProof", 'String'>
    readonly displayOrder: FieldRef<"SocialProof", 'Int'>
    readonly createdAt: FieldRef<"SocialProof", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialProof", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialProof findUnique
   */
  export type SocialProofFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * Filter, which SocialProof to fetch.
     */
    where: SocialProofWhereUniqueInput
  }

  /**
   * SocialProof findUniqueOrThrow
   */
  export type SocialProofFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * Filter, which SocialProof to fetch.
     */
    where: SocialProofWhereUniqueInput
  }

  /**
   * SocialProof findFirst
   */
  export type SocialProofFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * Filter, which SocialProof to fetch.
     */
    where?: SocialProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProofs to fetch.
     */
    orderBy?: SocialProofOrderByWithRelationInput | SocialProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialProofs.
     */
    cursor?: SocialProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialProofs.
     */
    distinct?: SocialProofScalarFieldEnum | SocialProofScalarFieldEnum[]
  }

  /**
   * SocialProof findFirstOrThrow
   */
  export type SocialProofFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * Filter, which SocialProof to fetch.
     */
    where?: SocialProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProofs to fetch.
     */
    orderBy?: SocialProofOrderByWithRelationInput | SocialProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialProofs.
     */
    cursor?: SocialProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialProofs.
     */
    distinct?: SocialProofScalarFieldEnum | SocialProofScalarFieldEnum[]
  }

  /**
   * SocialProof findMany
   */
  export type SocialProofFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * Filter, which SocialProofs to fetch.
     */
    where?: SocialProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialProofs to fetch.
     */
    orderBy?: SocialProofOrderByWithRelationInput | SocialProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialProofs.
     */
    cursor?: SocialProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialProofs.
     */
    skip?: number
    distinct?: SocialProofScalarFieldEnum | SocialProofScalarFieldEnum[]
  }

  /**
   * SocialProof create
   */
  export type SocialProofCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * The data needed to create a SocialProof.
     */
    data: XOR<SocialProofCreateInput, SocialProofUncheckedCreateInput>
  }

  /**
   * SocialProof createMany
   */
  export type SocialProofCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialProofs.
     */
    data: SocialProofCreateManyInput | SocialProofCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialProof createManyAndReturn
   */
  export type SocialProofCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SocialProofs.
     */
    data: SocialProofCreateManyInput | SocialProofCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialProof update
   */
  export type SocialProofUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * The data needed to update a SocialProof.
     */
    data: XOR<SocialProofUpdateInput, SocialProofUncheckedUpdateInput>
    /**
     * Choose, which SocialProof to update.
     */
    where: SocialProofWhereUniqueInput
  }

  /**
   * SocialProof updateMany
   */
  export type SocialProofUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialProofs.
     */
    data: XOR<SocialProofUpdateManyMutationInput, SocialProofUncheckedUpdateManyInput>
    /**
     * Filter which SocialProofs to update
     */
    where?: SocialProofWhereInput
  }

  /**
   * SocialProof upsert
   */
  export type SocialProofUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * The filter to search for the SocialProof to update in case it exists.
     */
    where: SocialProofWhereUniqueInput
    /**
     * In case the SocialProof found by the `where` argument doesn't exist, create a new SocialProof with this data.
     */
    create: XOR<SocialProofCreateInput, SocialProofUncheckedCreateInput>
    /**
     * In case the SocialProof was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialProofUpdateInput, SocialProofUncheckedUpdateInput>
  }

  /**
   * SocialProof delete
   */
  export type SocialProofDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
    /**
     * Filter which SocialProof to delete.
     */
    where: SocialProofWhereUniqueInput
  }

  /**
   * SocialProof deleteMany
   */
  export type SocialProofDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialProofs to delete
     */
    where?: SocialProofWhereInput
  }

  /**
   * SocialProof without action
   */
  export type SocialProofDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialProof
     */
    select?: SocialProofSelect<ExtArgs> | null
  }


  /**
   * Model AdminSettings
   */

  export type AggregateAdminSettings = {
    _count: AdminSettingsCountAggregateOutputType | null
    _avg: AdminSettingsAvgAggregateOutputType | null
    _sum: AdminSettingsSumAggregateOutputType | null
    _min: AdminSettingsMinAggregateOutputType | null
    _max: AdminSettingsMaxAggregateOutputType | null
  }

  export type AdminSettingsAvgAggregateOutputType = {
    smtpPort: number | null
    bannerDurationHours: number | null
    inboxCount: number | null
    teamCount: number | null
  }

  export type AdminSettingsSumAggregateOutputType = {
    smtpPort: number | null
    bannerDurationHours: number | null
    inboxCount: number | null
    teamCount: number | null
  }

  export type AdminSettingsMinAggregateOutputType = {
    id: string | null
    japApiUrl: string | null
    japApiKey: string | null
    checkoutApiKey: string | null
    checkoutWebhookSecret: string | null
    bigPayMeApiKey: string | null
    bigPayMeWebhookSecret: string | null
    rapidApiKey: string | null
    rapidApiInstagramHost: string | null
    rapidApiTikTokHost: string | null
    rapidApiYouTubeHost: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean | null
    smtpUser: string | null
    smtpPass: string | null
    smtpFrom: string | null
    defaultCurrency: string | null
    cryptomusMerchantId: string | null
    cryptomusApiKey: string | null
    cryptomusDisplayName: string | null
    cryptomusTestMode: boolean | null
    bigPayMerchantId: string | null
    bigPayDisplayName: string | null
    bigPayApiSecret: string | null
    bigPayTestMode: boolean | null
    exitIntentEnabled: boolean | null
    exitIntentTitle: string | null
    exitIntentSubtitle: string | null
    exitIntentDiscountCode: string | null
    newServiceIndicator: boolean | null
    supportEmail: string | null
    updatedAt: Date | null
    bannerDurationHours: number | null
    bannerEnabled: boolean | null
    inboxCount: number | null
    teamCount: number | null
    faviconUrl: string | null
    footerLogoUrl: string | null
    headerLogoUrl: string | null
    homeMetaDescription: string | null
    homeMetaTitle: string | null
    robotsTxtContent: string | null
    recaptchaSecretKey: string | null
    recaptchaSiteKey: string | null
    googleClientId: string | null
    googleClientSecret: string | null
    facebookClientId: string | null
    facebookClientSecret: string | null
    myFatoorahToken: string | null
    myFatoorahBaseURL: string | null
    myFatoorahTestMode: boolean | null
    myFatoorahWebhookSecret: string | null
  }

  export type AdminSettingsMaxAggregateOutputType = {
    id: string | null
    japApiUrl: string | null
    japApiKey: string | null
    checkoutApiKey: string | null
    checkoutWebhookSecret: string | null
    bigPayMeApiKey: string | null
    bigPayMeWebhookSecret: string | null
    rapidApiKey: string | null
    rapidApiInstagramHost: string | null
    rapidApiTikTokHost: string | null
    rapidApiYouTubeHost: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean | null
    smtpUser: string | null
    smtpPass: string | null
    smtpFrom: string | null
    defaultCurrency: string | null
    cryptomusMerchantId: string | null
    cryptomusApiKey: string | null
    cryptomusDisplayName: string | null
    cryptomusTestMode: boolean | null
    bigPayMerchantId: string | null
    bigPayDisplayName: string | null
    bigPayApiSecret: string | null
    bigPayTestMode: boolean | null
    exitIntentEnabled: boolean | null
    exitIntentTitle: string | null
    exitIntentSubtitle: string | null
    exitIntentDiscountCode: string | null
    newServiceIndicator: boolean | null
    supportEmail: string | null
    updatedAt: Date | null
    bannerDurationHours: number | null
    bannerEnabled: boolean | null
    inboxCount: number | null
    teamCount: number | null
    faviconUrl: string | null
    footerLogoUrl: string | null
    headerLogoUrl: string | null
    homeMetaDescription: string | null
    homeMetaTitle: string | null
    robotsTxtContent: string | null
    recaptchaSecretKey: string | null
    recaptchaSiteKey: string | null
    googleClientId: string | null
    googleClientSecret: string | null
    facebookClientId: string | null
    facebookClientSecret: string | null
    myFatoorahToken: string | null
    myFatoorahBaseURL: string | null
    myFatoorahTestMode: boolean | null
    myFatoorahWebhookSecret: string | null
  }

  export type AdminSettingsCountAggregateOutputType = {
    id: number
    japApiUrl: number
    japApiKey: number
    checkoutApiKey: number
    checkoutWebhookSecret: number
    bigPayMeApiKey: number
    bigPayMeWebhookSecret: number
    rapidApiKey: number
    rapidApiInstagramHost: number
    rapidApiTikTokHost: number
    rapidApiYouTubeHost: number
    smtpHost: number
    smtpPort: number
    smtpSecure: number
    smtpUser: number
    smtpPass: number
    smtpFrom: number
    defaultCurrency: number
    cryptomusMerchantId: number
    cryptomusApiKey: number
    cryptomusDisplayName: number
    cryptomusTestMode: number
    bigPayMerchantId: number
    bigPayDisplayName: number
    bigPayApiSecret: number
    bigPayTestMode: number
    exitIntentEnabled: number
    exitIntentTitle: number
    exitIntentSubtitle: number
    exitIntentDiscountCode: number
    newServiceIndicator: number
    supportEmail: number
    updatedAt: number
    bannerDurationHours: number
    bannerEnabled: number
    inboxCount: number
    teamCount: number
    faviconUrl: number
    footerLogoUrl: number
    headerLogoUrl: number
    homeMetaDescription: number
    homeMetaTitle: number
    robotsTxtContent: number
    recaptchaSecretKey: number
    recaptchaSiteKey: number
    googleClientId: number
    googleClientSecret: number
    facebookClientId: number
    facebookClientSecret: number
    myFatoorahToken: number
    myFatoorahBaseURL: number
    myFatoorahTestMode: number
    myFatoorahWebhookSecret: number
    _all: number
  }


  export type AdminSettingsAvgAggregateInputType = {
    smtpPort?: true
    bannerDurationHours?: true
    inboxCount?: true
    teamCount?: true
  }

  export type AdminSettingsSumAggregateInputType = {
    smtpPort?: true
    bannerDurationHours?: true
    inboxCount?: true
    teamCount?: true
  }

  export type AdminSettingsMinAggregateInputType = {
    id?: true
    japApiUrl?: true
    japApiKey?: true
    checkoutApiKey?: true
    checkoutWebhookSecret?: true
    bigPayMeApiKey?: true
    bigPayMeWebhookSecret?: true
    rapidApiKey?: true
    rapidApiInstagramHost?: true
    rapidApiTikTokHost?: true
    rapidApiYouTubeHost?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    smtpUser?: true
    smtpPass?: true
    smtpFrom?: true
    defaultCurrency?: true
    cryptomusMerchantId?: true
    cryptomusApiKey?: true
    cryptomusDisplayName?: true
    cryptomusTestMode?: true
    bigPayMerchantId?: true
    bigPayDisplayName?: true
    bigPayApiSecret?: true
    bigPayTestMode?: true
    exitIntentEnabled?: true
    exitIntentTitle?: true
    exitIntentSubtitle?: true
    exitIntentDiscountCode?: true
    newServiceIndicator?: true
    supportEmail?: true
    updatedAt?: true
    bannerDurationHours?: true
    bannerEnabled?: true
    inboxCount?: true
    teamCount?: true
    faviconUrl?: true
    footerLogoUrl?: true
    headerLogoUrl?: true
    homeMetaDescription?: true
    homeMetaTitle?: true
    robotsTxtContent?: true
    recaptchaSecretKey?: true
    recaptchaSiteKey?: true
    googleClientId?: true
    googleClientSecret?: true
    facebookClientId?: true
    facebookClientSecret?: true
    myFatoorahToken?: true
    myFatoorahBaseURL?: true
    myFatoorahTestMode?: true
    myFatoorahWebhookSecret?: true
  }

  export type AdminSettingsMaxAggregateInputType = {
    id?: true
    japApiUrl?: true
    japApiKey?: true
    checkoutApiKey?: true
    checkoutWebhookSecret?: true
    bigPayMeApiKey?: true
    bigPayMeWebhookSecret?: true
    rapidApiKey?: true
    rapidApiInstagramHost?: true
    rapidApiTikTokHost?: true
    rapidApiYouTubeHost?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    smtpUser?: true
    smtpPass?: true
    smtpFrom?: true
    defaultCurrency?: true
    cryptomusMerchantId?: true
    cryptomusApiKey?: true
    cryptomusDisplayName?: true
    cryptomusTestMode?: true
    bigPayMerchantId?: true
    bigPayDisplayName?: true
    bigPayApiSecret?: true
    bigPayTestMode?: true
    exitIntentEnabled?: true
    exitIntentTitle?: true
    exitIntentSubtitle?: true
    exitIntentDiscountCode?: true
    newServiceIndicator?: true
    supportEmail?: true
    updatedAt?: true
    bannerDurationHours?: true
    bannerEnabled?: true
    inboxCount?: true
    teamCount?: true
    faviconUrl?: true
    footerLogoUrl?: true
    headerLogoUrl?: true
    homeMetaDescription?: true
    homeMetaTitle?: true
    robotsTxtContent?: true
    recaptchaSecretKey?: true
    recaptchaSiteKey?: true
    googleClientId?: true
    googleClientSecret?: true
    facebookClientId?: true
    facebookClientSecret?: true
    myFatoorahToken?: true
    myFatoorahBaseURL?: true
    myFatoorahTestMode?: true
    myFatoorahWebhookSecret?: true
  }

  export type AdminSettingsCountAggregateInputType = {
    id?: true
    japApiUrl?: true
    japApiKey?: true
    checkoutApiKey?: true
    checkoutWebhookSecret?: true
    bigPayMeApiKey?: true
    bigPayMeWebhookSecret?: true
    rapidApiKey?: true
    rapidApiInstagramHost?: true
    rapidApiTikTokHost?: true
    rapidApiYouTubeHost?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    smtpUser?: true
    smtpPass?: true
    smtpFrom?: true
    defaultCurrency?: true
    cryptomusMerchantId?: true
    cryptomusApiKey?: true
    cryptomusDisplayName?: true
    cryptomusTestMode?: true
    bigPayMerchantId?: true
    bigPayDisplayName?: true
    bigPayApiSecret?: true
    bigPayTestMode?: true
    exitIntentEnabled?: true
    exitIntentTitle?: true
    exitIntentSubtitle?: true
    exitIntentDiscountCode?: true
    newServiceIndicator?: true
    supportEmail?: true
    updatedAt?: true
    bannerDurationHours?: true
    bannerEnabled?: true
    inboxCount?: true
    teamCount?: true
    faviconUrl?: true
    footerLogoUrl?: true
    headerLogoUrl?: true
    homeMetaDescription?: true
    homeMetaTitle?: true
    robotsTxtContent?: true
    recaptchaSecretKey?: true
    recaptchaSiteKey?: true
    googleClientId?: true
    googleClientSecret?: true
    facebookClientId?: true
    facebookClientSecret?: true
    myFatoorahToken?: true
    myFatoorahBaseURL?: true
    myFatoorahTestMode?: true
    myFatoorahWebhookSecret?: true
    _all?: true
  }

  export type AdminSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSettings to aggregate.
     */
    where?: AdminSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingsOrderByWithRelationInput | AdminSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSettings
    **/
    _count?: true | AdminSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSettingsMaxAggregateInputType
  }

  export type GetAdminSettingsAggregateType<T extends AdminSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSettings[P]>
      : GetScalarType<T[P], AggregateAdminSettings[P]>
  }




  export type AdminSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSettingsWhereInput
    orderBy?: AdminSettingsOrderByWithAggregationInput | AdminSettingsOrderByWithAggregationInput[]
    by: AdminSettingsScalarFieldEnum[] | AdminSettingsScalarFieldEnum
    having?: AdminSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSettingsCountAggregateInputType | true
    _avg?: AdminSettingsAvgAggregateInputType
    _sum?: AdminSettingsSumAggregateInputType
    _min?: AdminSettingsMinAggregateInputType
    _max?: AdminSettingsMaxAggregateInputType
  }

  export type AdminSettingsGroupByOutputType = {
    id: string
    japApiUrl: string | null
    japApiKey: string | null
    checkoutApiKey: string | null
    checkoutWebhookSecret: string | null
    bigPayMeApiKey: string | null
    bigPayMeWebhookSecret: string | null
    rapidApiKey: string | null
    rapidApiInstagramHost: string | null
    rapidApiTikTokHost: string | null
    rapidApiYouTubeHost: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean
    smtpUser: string | null
    smtpPass: string | null
    smtpFrom: string | null
    defaultCurrency: string
    cryptomusMerchantId: string | null
    cryptomusApiKey: string | null
    cryptomusDisplayName: string | null
    cryptomusTestMode: boolean
    bigPayMerchantId: string | null
    bigPayDisplayName: string | null
    bigPayApiSecret: string | null
    bigPayTestMode: boolean
    exitIntentEnabled: boolean
    exitIntentTitle: string | null
    exitIntentSubtitle: string | null
    exitIntentDiscountCode: string | null
    newServiceIndicator: boolean
    supportEmail: string | null
    updatedAt: Date
    bannerDurationHours: number
    bannerEnabled: boolean
    inboxCount: number
    teamCount: number
    faviconUrl: string | null
    footerLogoUrl: string | null
    headerLogoUrl: string | null
    homeMetaDescription: string | null
    homeMetaTitle: string | null
    robotsTxtContent: string | null
    recaptchaSecretKey: string | null
    recaptchaSiteKey: string | null
    googleClientId: string | null
    googleClientSecret: string | null
    facebookClientId: string | null
    facebookClientSecret: string | null
    myFatoorahToken: string | null
    myFatoorahBaseURL: string | null
    myFatoorahTestMode: boolean
    myFatoorahWebhookSecret: string | null
    _count: AdminSettingsCountAggregateOutputType | null
    _avg: AdminSettingsAvgAggregateOutputType | null
    _sum: AdminSettingsSumAggregateOutputType | null
    _min: AdminSettingsMinAggregateOutputType | null
    _max: AdminSettingsMaxAggregateOutputType | null
  }

  type GetAdminSettingsGroupByPayload<T extends AdminSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSettingsGroupByOutputType[P]>
        }
      >
    >


  export type AdminSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    japApiUrl?: boolean
    japApiKey?: boolean
    checkoutApiKey?: boolean
    checkoutWebhookSecret?: boolean
    bigPayMeApiKey?: boolean
    bigPayMeWebhookSecret?: boolean
    rapidApiKey?: boolean
    rapidApiInstagramHost?: boolean
    rapidApiTikTokHost?: boolean
    rapidApiYouTubeHost?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    smtpUser?: boolean
    smtpPass?: boolean
    smtpFrom?: boolean
    defaultCurrency?: boolean
    cryptomusMerchantId?: boolean
    cryptomusApiKey?: boolean
    cryptomusDisplayName?: boolean
    cryptomusTestMode?: boolean
    bigPayMerchantId?: boolean
    bigPayDisplayName?: boolean
    bigPayApiSecret?: boolean
    bigPayTestMode?: boolean
    exitIntentEnabled?: boolean
    exitIntentTitle?: boolean
    exitIntentSubtitle?: boolean
    exitIntentDiscountCode?: boolean
    newServiceIndicator?: boolean
    supportEmail?: boolean
    updatedAt?: boolean
    bannerDurationHours?: boolean
    bannerEnabled?: boolean
    inboxCount?: boolean
    teamCount?: boolean
    faviconUrl?: boolean
    footerLogoUrl?: boolean
    headerLogoUrl?: boolean
    homeMetaDescription?: boolean
    homeMetaTitle?: boolean
    robotsTxtContent?: boolean
    recaptchaSecretKey?: boolean
    recaptchaSiteKey?: boolean
    googleClientId?: boolean
    googleClientSecret?: boolean
    facebookClientId?: boolean
    facebookClientSecret?: boolean
    myFatoorahToken?: boolean
    myFatoorahBaseURL?: boolean
    myFatoorahTestMode?: boolean
    myFatoorahWebhookSecret?: boolean
  }, ExtArgs["result"]["adminSettings"]>

  export type AdminSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    japApiUrl?: boolean
    japApiKey?: boolean
    checkoutApiKey?: boolean
    checkoutWebhookSecret?: boolean
    bigPayMeApiKey?: boolean
    bigPayMeWebhookSecret?: boolean
    rapidApiKey?: boolean
    rapidApiInstagramHost?: boolean
    rapidApiTikTokHost?: boolean
    rapidApiYouTubeHost?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    smtpUser?: boolean
    smtpPass?: boolean
    smtpFrom?: boolean
    defaultCurrency?: boolean
    cryptomusMerchantId?: boolean
    cryptomusApiKey?: boolean
    cryptomusDisplayName?: boolean
    cryptomusTestMode?: boolean
    bigPayMerchantId?: boolean
    bigPayDisplayName?: boolean
    bigPayApiSecret?: boolean
    bigPayTestMode?: boolean
    exitIntentEnabled?: boolean
    exitIntentTitle?: boolean
    exitIntentSubtitle?: boolean
    exitIntentDiscountCode?: boolean
    newServiceIndicator?: boolean
    supportEmail?: boolean
    updatedAt?: boolean
    bannerDurationHours?: boolean
    bannerEnabled?: boolean
    inboxCount?: boolean
    teamCount?: boolean
    faviconUrl?: boolean
    footerLogoUrl?: boolean
    headerLogoUrl?: boolean
    homeMetaDescription?: boolean
    homeMetaTitle?: boolean
    robotsTxtContent?: boolean
    recaptchaSecretKey?: boolean
    recaptchaSiteKey?: boolean
    googleClientId?: boolean
    googleClientSecret?: boolean
    facebookClientId?: boolean
    facebookClientSecret?: boolean
    myFatoorahToken?: boolean
    myFatoorahBaseURL?: boolean
    myFatoorahTestMode?: boolean
    myFatoorahWebhookSecret?: boolean
  }, ExtArgs["result"]["adminSettings"]>

  export type AdminSettingsSelectScalar = {
    id?: boolean
    japApiUrl?: boolean
    japApiKey?: boolean
    checkoutApiKey?: boolean
    checkoutWebhookSecret?: boolean
    bigPayMeApiKey?: boolean
    bigPayMeWebhookSecret?: boolean
    rapidApiKey?: boolean
    rapidApiInstagramHost?: boolean
    rapidApiTikTokHost?: boolean
    rapidApiYouTubeHost?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    smtpUser?: boolean
    smtpPass?: boolean
    smtpFrom?: boolean
    defaultCurrency?: boolean
    cryptomusMerchantId?: boolean
    cryptomusApiKey?: boolean
    cryptomusDisplayName?: boolean
    cryptomusTestMode?: boolean
    bigPayMerchantId?: boolean
    bigPayDisplayName?: boolean
    bigPayApiSecret?: boolean
    bigPayTestMode?: boolean
    exitIntentEnabled?: boolean
    exitIntentTitle?: boolean
    exitIntentSubtitle?: boolean
    exitIntentDiscountCode?: boolean
    newServiceIndicator?: boolean
    supportEmail?: boolean
    updatedAt?: boolean
    bannerDurationHours?: boolean
    bannerEnabled?: boolean
    inboxCount?: boolean
    teamCount?: boolean
    faviconUrl?: boolean
    footerLogoUrl?: boolean
    headerLogoUrl?: boolean
    homeMetaDescription?: boolean
    homeMetaTitle?: boolean
    robotsTxtContent?: boolean
    recaptchaSecretKey?: boolean
    recaptchaSiteKey?: boolean
    googleClientId?: boolean
    googleClientSecret?: boolean
    facebookClientId?: boolean
    facebookClientSecret?: boolean
    myFatoorahToken?: boolean
    myFatoorahBaseURL?: boolean
    myFatoorahTestMode?: boolean
    myFatoorahWebhookSecret?: boolean
  }


  export type $AdminSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      japApiUrl: string | null
      japApiKey: string | null
      checkoutApiKey: string | null
      checkoutWebhookSecret: string | null
      bigPayMeApiKey: string | null
      bigPayMeWebhookSecret: string | null
      rapidApiKey: string | null
      rapidApiInstagramHost: string | null
      rapidApiTikTokHost: string | null
      rapidApiYouTubeHost: string | null
      smtpHost: string | null
      smtpPort: number | null
      smtpSecure: boolean
      smtpUser: string | null
      smtpPass: string | null
      smtpFrom: string | null
      defaultCurrency: string
      cryptomusMerchantId: string | null
      cryptomusApiKey: string | null
      cryptomusDisplayName: string | null
      cryptomusTestMode: boolean
      bigPayMerchantId: string | null
      bigPayDisplayName: string | null
      bigPayApiSecret: string | null
      bigPayTestMode: boolean
      exitIntentEnabled: boolean
      exitIntentTitle: string | null
      exitIntentSubtitle: string | null
      exitIntentDiscountCode: string | null
      newServiceIndicator: boolean
      supportEmail: string | null
      updatedAt: Date
      bannerDurationHours: number
      bannerEnabled: boolean
      inboxCount: number
      teamCount: number
      faviconUrl: string | null
      footerLogoUrl: string | null
      headerLogoUrl: string | null
      homeMetaDescription: string | null
      homeMetaTitle: string | null
      robotsTxtContent: string | null
      recaptchaSecretKey: string | null
      recaptchaSiteKey: string | null
      googleClientId: string | null
      googleClientSecret: string | null
      facebookClientId: string | null
      facebookClientSecret: string | null
      myFatoorahToken: string | null
      myFatoorahBaseURL: string | null
      myFatoorahTestMode: boolean
      myFatoorahWebhookSecret: string | null
    }, ExtArgs["result"]["adminSettings"]>
    composites: {}
  }

  type AdminSettingsGetPayload<S extends boolean | null | undefined | AdminSettingsDefaultArgs> = $Result.GetResult<Prisma.$AdminSettingsPayload, S>

  type AdminSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminSettingsCountAggregateInputType | true
    }

  export interface AdminSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSettings'], meta: { name: 'AdminSettings' } }
    /**
     * Find zero or one AdminSettings that matches the filter.
     * @param {AdminSettingsFindUniqueArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSettingsFindUniqueArgs>(args: SelectSubset<T, AdminSettingsFindUniqueArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminSettingsFindUniqueOrThrowArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsFindFirstArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSettingsFindFirstArgs>(args?: SelectSubset<T, AdminSettingsFindFirstArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsFindFirstOrThrowArgs} args - Arguments to find a AdminSettings
     * @example
     * // Get one AdminSettings
     * const adminSettings = await prisma.adminSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSettings
     * const adminSettings = await prisma.adminSettings.findMany()
     * 
     * // Get first 10 AdminSettings
     * const adminSettings = await prisma.adminSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSettingsWithIdOnly = await prisma.adminSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSettingsFindManyArgs>(args?: SelectSubset<T, AdminSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminSettings.
     * @param {AdminSettingsCreateArgs} args - Arguments to create a AdminSettings.
     * @example
     * // Create one AdminSettings
     * const AdminSettings = await prisma.adminSettings.create({
     *   data: {
     *     // ... data to create a AdminSettings
     *   }
     * })
     * 
     */
    create<T extends AdminSettingsCreateArgs>(args: SelectSubset<T, AdminSettingsCreateArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminSettings.
     * @param {AdminSettingsCreateManyArgs} args - Arguments to create many AdminSettings.
     * @example
     * // Create many AdminSettings
     * const adminSettings = await prisma.adminSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSettingsCreateManyArgs>(args?: SelectSubset<T, AdminSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSettings and returns the data saved in the database.
     * @param {AdminSettingsCreateManyAndReturnArgs} args - Arguments to create many AdminSettings.
     * @example
     * // Create many AdminSettings
     * const adminSettings = await prisma.adminSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSettings and only return the `id`
     * const adminSettingsWithIdOnly = await prisma.adminSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminSettings.
     * @param {AdminSettingsDeleteArgs} args - Arguments to delete one AdminSettings.
     * @example
     * // Delete one AdminSettings
     * const AdminSettings = await prisma.adminSettings.delete({
     *   where: {
     *     // ... filter to delete one AdminSettings
     *   }
     * })
     * 
     */
    delete<T extends AdminSettingsDeleteArgs>(args: SelectSubset<T, AdminSettingsDeleteArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminSettings.
     * @param {AdminSettingsUpdateArgs} args - Arguments to update one AdminSettings.
     * @example
     * // Update one AdminSettings
     * const adminSettings = await prisma.adminSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSettingsUpdateArgs>(args: SelectSubset<T, AdminSettingsUpdateArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminSettings.
     * @param {AdminSettingsDeleteManyArgs} args - Arguments to filter AdminSettings to delete.
     * @example
     * // Delete a few AdminSettings
     * const { count } = await prisma.adminSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSettingsDeleteManyArgs>(args?: SelectSubset<T, AdminSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSettings
     * const adminSettings = await prisma.adminSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSettingsUpdateManyArgs>(args: SelectSubset<T, AdminSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminSettings.
     * @param {AdminSettingsUpsertArgs} args - Arguments to update or create a AdminSettings.
     * @example
     * // Update or create a AdminSettings
     * const adminSettings = await prisma.adminSettings.upsert({
     *   create: {
     *     // ... data to create a AdminSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSettings we want to update
     *   }
     * })
     */
    upsert<T extends AdminSettingsUpsertArgs>(args: SelectSubset<T, AdminSettingsUpsertArgs<ExtArgs>>): Prisma__AdminSettingsClient<$Result.GetResult<Prisma.$AdminSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsCountArgs} args - Arguments to filter AdminSettings to count.
     * @example
     * // Count the number of AdminSettings
     * const count = await prisma.adminSettings.count({
     *   where: {
     *     // ... the filter for the AdminSettings we want to count
     *   }
     * })
    **/
    count<T extends AdminSettingsCountArgs>(
      args?: Subset<T, AdminSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSettingsAggregateArgs>(args: Subset<T, AdminSettingsAggregateArgs>): Prisma.PrismaPromise<GetAdminSettingsAggregateType<T>>

    /**
     * Group by AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSettingsGroupByArgs['orderBy'] }
        : { orderBy?: AdminSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSettings model
   */
  readonly fields: AdminSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSettings model
   */ 
  interface AdminSettingsFieldRefs {
    readonly id: FieldRef<"AdminSettings", 'String'>
    readonly japApiUrl: FieldRef<"AdminSettings", 'String'>
    readonly japApiKey: FieldRef<"AdminSettings", 'String'>
    readonly checkoutApiKey: FieldRef<"AdminSettings", 'String'>
    readonly checkoutWebhookSecret: FieldRef<"AdminSettings", 'String'>
    readonly bigPayMeApiKey: FieldRef<"AdminSettings", 'String'>
    readonly bigPayMeWebhookSecret: FieldRef<"AdminSettings", 'String'>
    readonly rapidApiKey: FieldRef<"AdminSettings", 'String'>
    readonly rapidApiInstagramHost: FieldRef<"AdminSettings", 'String'>
    readonly rapidApiTikTokHost: FieldRef<"AdminSettings", 'String'>
    readonly rapidApiYouTubeHost: FieldRef<"AdminSettings", 'String'>
    readonly smtpHost: FieldRef<"AdminSettings", 'String'>
    readonly smtpPort: FieldRef<"AdminSettings", 'Int'>
    readonly smtpSecure: FieldRef<"AdminSettings", 'Boolean'>
    readonly smtpUser: FieldRef<"AdminSettings", 'String'>
    readonly smtpPass: FieldRef<"AdminSettings", 'String'>
    readonly smtpFrom: FieldRef<"AdminSettings", 'String'>
    readonly defaultCurrency: FieldRef<"AdminSettings", 'String'>
    readonly cryptomusMerchantId: FieldRef<"AdminSettings", 'String'>
    readonly cryptomusApiKey: FieldRef<"AdminSettings", 'String'>
    readonly cryptomusDisplayName: FieldRef<"AdminSettings", 'String'>
    readonly cryptomusTestMode: FieldRef<"AdminSettings", 'Boolean'>
    readonly bigPayMerchantId: FieldRef<"AdminSettings", 'String'>
    readonly bigPayDisplayName: FieldRef<"AdminSettings", 'String'>
    readonly bigPayApiSecret: FieldRef<"AdminSettings", 'String'>
    readonly bigPayTestMode: FieldRef<"AdminSettings", 'Boolean'>
    readonly exitIntentEnabled: FieldRef<"AdminSettings", 'Boolean'>
    readonly exitIntentTitle: FieldRef<"AdminSettings", 'String'>
    readonly exitIntentSubtitle: FieldRef<"AdminSettings", 'String'>
    readonly exitIntentDiscountCode: FieldRef<"AdminSettings", 'String'>
    readonly newServiceIndicator: FieldRef<"AdminSettings", 'Boolean'>
    readonly supportEmail: FieldRef<"AdminSettings", 'String'>
    readonly updatedAt: FieldRef<"AdminSettings", 'DateTime'>
    readonly bannerDurationHours: FieldRef<"AdminSettings", 'Int'>
    readonly bannerEnabled: FieldRef<"AdminSettings", 'Boolean'>
    readonly inboxCount: FieldRef<"AdminSettings", 'Int'>
    readonly teamCount: FieldRef<"AdminSettings", 'Int'>
    readonly faviconUrl: FieldRef<"AdminSettings", 'String'>
    readonly footerLogoUrl: FieldRef<"AdminSettings", 'String'>
    readonly headerLogoUrl: FieldRef<"AdminSettings", 'String'>
    readonly homeMetaDescription: FieldRef<"AdminSettings", 'String'>
    readonly homeMetaTitle: FieldRef<"AdminSettings", 'String'>
    readonly robotsTxtContent: FieldRef<"AdminSettings", 'String'>
    readonly recaptchaSecretKey: FieldRef<"AdminSettings", 'String'>
    readonly recaptchaSiteKey: FieldRef<"AdminSettings", 'String'>
    readonly googleClientId: FieldRef<"AdminSettings", 'String'>
    readonly googleClientSecret: FieldRef<"AdminSettings", 'String'>
    readonly facebookClientId: FieldRef<"AdminSettings", 'String'>
    readonly facebookClientSecret: FieldRef<"AdminSettings", 'String'>
    readonly myFatoorahToken: FieldRef<"AdminSettings", 'String'>
    readonly myFatoorahBaseURL: FieldRef<"AdminSettings", 'String'>
    readonly myFatoorahTestMode: FieldRef<"AdminSettings", 'Boolean'>
    readonly myFatoorahWebhookSecret: FieldRef<"AdminSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminSettings findUnique
   */
  export type AdminSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AdminSettings to fetch.
     */
    where: AdminSettingsWhereUniqueInput
  }

  /**
   * AdminSettings findUniqueOrThrow
   */
  export type AdminSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AdminSettings to fetch.
     */
    where: AdminSettingsWhereUniqueInput
  }

  /**
   * AdminSettings findFirst
   */
  export type AdminSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AdminSettings to fetch.
     */
    where?: AdminSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingsOrderByWithRelationInput | AdminSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSettings.
     */
    cursor?: AdminSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSettings.
     */
    distinct?: AdminSettingsScalarFieldEnum | AdminSettingsScalarFieldEnum[]
  }

  /**
   * AdminSettings findFirstOrThrow
   */
  export type AdminSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AdminSettings to fetch.
     */
    where?: AdminSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingsOrderByWithRelationInput | AdminSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSettings.
     */
    cursor?: AdminSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSettings.
     */
    distinct?: AdminSettingsScalarFieldEnum | AdminSettingsScalarFieldEnum[]
  }

  /**
   * AdminSettings findMany
   */
  export type AdminSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * Filter, which AdminSettings to fetch.
     */
    where?: AdminSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingsOrderByWithRelationInput | AdminSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSettings.
     */
    cursor?: AdminSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    distinct?: AdminSettingsScalarFieldEnum | AdminSettingsScalarFieldEnum[]
  }

  /**
   * AdminSettings create
   */
  export type AdminSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a AdminSettings.
     */
    data: XOR<AdminSettingsCreateInput, AdminSettingsUncheckedCreateInput>
  }

  /**
   * AdminSettings createMany
   */
  export type AdminSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSettings.
     */
    data: AdminSettingsCreateManyInput | AdminSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSettings createManyAndReturn
   */
  export type AdminSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminSettings.
     */
    data: AdminSettingsCreateManyInput | AdminSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSettings update
   */
  export type AdminSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a AdminSettings.
     */
    data: XOR<AdminSettingsUpdateInput, AdminSettingsUncheckedUpdateInput>
    /**
     * Choose, which AdminSettings to update.
     */
    where: AdminSettingsWhereUniqueInput
  }

  /**
   * AdminSettings updateMany
   */
  export type AdminSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSettings.
     */
    data: XOR<AdminSettingsUpdateManyMutationInput, AdminSettingsUncheckedUpdateManyInput>
    /**
     * Filter which AdminSettings to update
     */
    where?: AdminSettingsWhereInput
  }

  /**
   * AdminSettings upsert
   */
  export type AdminSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the AdminSettings to update in case it exists.
     */
    where: AdminSettingsWhereUniqueInput
    /**
     * In case the AdminSettings found by the `where` argument doesn't exist, create a new AdminSettings with this data.
     */
    create: XOR<AdminSettingsCreateInput, AdminSettingsUncheckedCreateInput>
    /**
     * In case the AdminSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSettingsUpdateInput, AdminSettingsUncheckedUpdateInput>
  }

  /**
   * AdminSettings delete
   */
  export type AdminSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
    /**
     * Filter which AdminSettings to delete.
     */
    where: AdminSettingsWhereUniqueInput
  }

  /**
   * AdminSettings deleteMany
   */
  export type AdminSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSettings to delete
     */
    where?: AdminSettingsWhereInput
  }

  /**
   * AdminSettings without action
   */
  export type AdminSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSettings
     */
    select?: AdminSettingsSelect<ExtArgs> | null
  }


  /**
   * Model HomepageContent
   */

  export type AggregateHomepageContent = {
    _count: HomepageContentCountAggregateOutputType | null
    _min: HomepageContentMinAggregateOutputType | null
    _max: HomepageContentMaxAggregateOutputType | null
  }

  export type HomepageContentMinAggregateOutputType = {
    id: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    heroRating: string | null
    heroReviewCount: string | null
    isActive: boolean | null
    updatedAt: Date | null
    heroProfileEngagement: string | null
    heroProfileFollowers: string | null
    heroProfileHandle: string | null
    heroProfileLikes: string | null
    heroProfileRole: string | null
    influenceSubtitle: string | null
    influenceTitle: string | null
    platformSubtitle: string | null
    platformTitle: string | null
    quickStartDescription1: string | null
    quickStartDescription2: string | null
    quickStartTitle: string | null
    whyChooseSubtitle: string | null
    whyChooseTitle: string | null
    heroProfileImage: string | null
    influenceImage: string | null
  }

  export type HomepageContentMaxAggregateOutputType = {
    id: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    heroRating: string | null
    heroReviewCount: string | null
    isActive: boolean | null
    updatedAt: Date | null
    heroProfileEngagement: string | null
    heroProfileFollowers: string | null
    heroProfileHandle: string | null
    heroProfileLikes: string | null
    heroProfileRole: string | null
    influenceSubtitle: string | null
    influenceTitle: string | null
    platformSubtitle: string | null
    platformTitle: string | null
    quickStartDescription1: string | null
    quickStartDescription2: string | null
    quickStartTitle: string | null
    whyChooseSubtitle: string | null
    whyChooseTitle: string | null
    heroProfileImage: string | null
    influenceImage: string | null
  }

  export type HomepageContentCountAggregateOutputType = {
    id: number
    heroTitle: number
    heroSubtitle: number
    heroRating: number
    heroReviewCount: number
    heroCtaButtons: number
    isActive: number
    updatedAt: number
    benefits: number
    heroProfileEngagement: number
    heroProfileFollowers: number
    heroProfileHandle: number
    heroProfileLikes: number
    heroProfileRole: number
    influenceSubtitle: number
    influenceTitle: number
    platformSubtitle: number
    platformTitle: number
    quickStartDescription1: number
    quickStartDescription2: number
    quickStartTitle: number
    whyChooseSubtitle: number
    whyChooseTitle: number
    platformCards: number
    heroProfileImage: number
    influenceImage: number
    influenceSteps: number
    quickStartButtons: number
    _all: number
  }


  export type HomepageContentMinAggregateInputType = {
    id?: true
    heroTitle?: true
    heroSubtitle?: true
    heroRating?: true
    heroReviewCount?: true
    isActive?: true
    updatedAt?: true
    heroProfileEngagement?: true
    heroProfileFollowers?: true
    heroProfileHandle?: true
    heroProfileLikes?: true
    heroProfileRole?: true
    influenceSubtitle?: true
    influenceTitle?: true
    platformSubtitle?: true
    platformTitle?: true
    quickStartDescription1?: true
    quickStartDescription2?: true
    quickStartTitle?: true
    whyChooseSubtitle?: true
    whyChooseTitle?: true
    heroProfileImage?: true
    influenceImage?: true
  }

  export type HomepageContentMaxAggregateInputType = {
    id?: true
    heroTitle?: true
    heroSubtitle?: true
    heroRating?: true
    heroReviewCount?: true
    isActive?: true
    updatedAt?: true
    heroProfileEngagement?: true
    heroProfileFollowers?: true
    heroProfileHandle?: true
    heroProfileLikes?: true
    heroProfileRole?: true
    influenceSubtitle?: true
    influenceTitle?: true
    platformSubtitle?: true
    platformTitle?: true
    quickStartDescription1?: true
    quickStartDescription2?: true
    quickStartTitle?: true
    whyChooseSubtitle?: true
    whyChooseTitle?: true
    heroProfileImage?: true
    influenceImage?: true
  }

  export type HomepageContentCountAggregateInputType = {
    id?: true
    heroTitle?: true
    heroSubtitle?: true
    heroRating?: true
    heroReviewCount?: true
    heroCtaButtons?: true
    isActive?: true
    updatedAt?: true
    benefits?: true
    heroProfileEngagement?: true
    heroProfileFollowers?: true
    heroProfileHandle?: true
    heroProfileLikes?: true
    heroProfileRole?: true
    influenceSubtitle?: true
    influenceTitle?: true
    platformSubtitle?: true
    platformTitle?: true
    quickStartDescription1?: true
    quickStartDescription2?: true
    quickStartTitle?: true
    whyChooseSubtitle?: true
    whyChooseTitle?: true
    platformCards?: true
    heroProfileImage?: true
    influenceImage?: true
    influenceSteps?: true
    quickStartButtons?: true
    _all?: true
  }

  export type HomepageContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomepageContent to aggregate.
     */
    where?: HomepageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomepageContents to fetch.
     */
    orderBy?: HomepageContentOrderByWithRelationInput | HomepageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomepageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomepageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomepageContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomepageContents
    **/
    _count?: true | HomepageContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomepageContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomepageContentMaxAggregateInputType
  }

  export type GetHomepageContentAggregateType<T extends HomepageContentAggregateArgs> = {
        [P in keyof T & keyof AggregateHomepageContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomepageContent[P]>
      : GetScalarType<T[P], AggregateHomepageContent[P]>
  }




  export type HomepageContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomepageContentWhereInput
    orderBy?: HomepageContentOrderByWithAggregationInput | HomepageContentOrderByWithAggregationInput[]
    by: HomepageContentScalarFieldEnum[] | HomepageContentScalarFieldEnum
    having?: HomepageContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomepageContentCountAggregateInputType | true
    _min?: HomepageContentMinAggregateInputType
    _max?: HomepageContentMaxAggregateInputType
  }

  export type HomepageContentGroupByOutputType = {
    id: string
    heroTitle: string
    heroSubtitle: string
    heroRating: string | null
    heroReviewCount: string | null
    heroCtaButtons: JsonValue | null
    isActive: boolean
    updatedAt: Date
    benefits: JsonValue | null
    heroProfileEngagement: string | null
    heroProfileFollowers: string | null
    heroProfileHandle: string | null
    heroProfileLikes: string | null
    heroProfileRole: string | null
    influenceSubtitle: string | null
    influenceTitle: string | null
    platformSubtitle: string | null
    platformTitle: string | null
    quickStartDescription1: string | null
    quickStartDescription2: string | null
    quickStartTitle: string | null
    whyChooseSubtitle: string | null
    whyChooseTitle: string | null
    platformCards: JsonValue | null
    heroProfileImage: string | null
    influenceImage: string | null
    influenceSteps: JsonValue | null
    quickStartButtons: JsonValue | null
    _count: HomepageContentCountAggregateOutputType | null
    _min: HomepageContentMinAggregateOutputType | null
    _max: HomepageContentMaxAggregateOutputType | null
  }

  type GetHomepageContentGroupByPayload<T extends HomepageContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomepageContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomepageContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomepageContentGroupByOutputType[P]>
            : GetScalarType<T[P], HomepageContentGroupByOutputType[P]>
        }
      >
    >


  export type HomepageContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroRating?: boolean
    heroReviewCount?: boolean
    heroCtaButtons?: boolean
    isActive?: boolean
    updatedAt?: boolean
    benefits?: boolean
    heroProfileEngagement?: boolean
    heroProfileFollowers?: boolean
    heroProfileHandle?: boolean
    heroProfileLikes?: boolean
    heroProfileRole?: boolean
    influenceSubtitle?: boolean
    influenceTitle?: boolean
    platformSubtitle?: boolean
    platformTitle?: boolean
    quickStartDescription1?: boolean
    quickStartDescription2?: boolean
    quickStartTitle?: boolean
    whyChooseSubtitle?: boolean
    whyChooseTitle?: boolean
    platformCards?: boolean
    heroProfileImage?: boolean
    influenceImage?: boolean
    influenceSteps?: boolean
    quickStartButtons?: boolean
  }, ExtArgs["result"]["homepageContent"]>

  export type HomepageContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroRating?: boolean
    heroReviewCount?: boolean
    heroCtaButtons?: boolean
    isActive?: boolean
    updatedAt?: boolean
    benefits?: boolean
    heroProfileEngagement?: boolean
    heroProfileFollowers?: boolean
    heroProfileHandle?: boolean
    heroProfileLikes?: boolean
    heroProfileRole?: boolean
    influenceSubtitle?: boolean
    influenceTitle?: boolean
    platformSubtitle?: boolean
    platformTitle?: boolean
    quickStartDescription1?: boolean
    quickStartDescription2?: boolean
    quickStartTitle?: boolean
    whyChooseSubtitle?: boolean
    whyChooseTitle?: boolean
    platformCards?: boolean
    heroProfileImage?: boolean
    influenceImage?: boolean
    influenceSteps?: boolean
    quickStartButtons?: boolean
  }, ExtArgs["result"]["homepageContent"]>

  export type HomepageContentSelectScalar = {
    id?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroRating?: boolean
    heroReviewCount?: boolean
    heroCtaButtons?: boolean
    isActive?: boolean
    updatedAt?: boolean
    benefits?: boolean
    heroProfileEngagement?: boolean
    heroProfileFollowers?: boolean
    heroProfileHandle?: boolean
    heroProfileLikes?: boolean
    heroProfileRole?: boolean
    influenceSubtitle?: boolean
    influenceTitle?: boolean
    platformSubtitle?: boolean
    platformTitle?: boolean
    quickStartDescription1?: boolean
    quickStartDescription2?: boolean
    quickStartTitle?: boolean
    whyChooseSubtitle?: boolean
    whyChooseTitle?: boolean
    platformCards?: boolean
    heroProfileImage?: boolean
    influenceImage?: boolean
    influenceSteps?: boolean
    quickStartButtons?: boolean
  }


  export type $HomepageContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomepageContent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      heroTitle: string
      heroSubtitle: string
      heroRating: string | null
      heroReviewCount: string | null
      heroCtaButtons: Prisma.JsonValue | null
      isActive: boolean
      updatedAt: Date
      benefits: Prisma.JsonValue | null
      heroProfileEngagement: string | null
      heroProfileFollowers: string | null
      heroProfileHandle: string | null
      heroProfileLikes: string | null
      heroProfileRole: string | null
      influenceSubtitle: string | null
      influenceTitle: string | null
      platformSubtitle: string | null
      platformTitle: string | null
      quickStartDescription1: string | null
      quickStartDescription2: string | null
      quickStartTitle: string | null
      whyChooseSubtitle: string | null
      whyChooseTitle: string | null
      platformCards: Prisma.JsonValue | null
      heroProfileImage: string | null
      influenceImage: string | null
      influenceSteps: Prisma.JsonValue | null
      quickStartButtons: Prisma.JsonValue | null
    }, ExtArgs["result"]["homepageContent"]>
    composites: {}
  }

  type HomepageContentGetPayload<S extends boolean | null | undefined | HomepageContentDefaultArgs> = $Result.GetResult<Prisma.$HomepageContentPayload, S>

  type HomepageContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HomepageContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HomepageContentCountAggregateInputType | true
    }

  export interface HomepageContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomepageContent'], meta: { name: 'HomepageContent' } }
    /**
     * Find zero or one HomepageContent that matches the filter.
     * @param {HomepageContentFindUniqueArgs} args - Arguments to find a HomepageContent
     * @example
     * // Get one HomepageContent
     * const homepageContent = await prisma.homepageContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomepageContentFindUniqueArgs>(args: SelectSubset<T, HomepageContentFindUniqueArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HomepageContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HomepageContentFindUniqueOrThrowArgs} args - Arguments to find a HomepageContent
     * @example
     * // Get one HomepageContent
     * const homepageContent = await prisma.homepageContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomepageContentFindUniqueOrThrowArgs>(args: SelectSubset<T, HomepageContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HomepageContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomepageContentFindFirstArgs} args - Arguments to find a HomepageContent
     * @example
     * // Get one HomepageContent
     * const homepageContent = await prisma.homepageContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomepageContentFindFirstArgs>(args?: SelectSubset<T, HomepageContentFindFirstArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HomepageContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomepageContentFindFirstOrThrowArgs} args - Arguments to find a HomepageContent
     * @example
     * // Get one HomepageContent
     * const homepageContent = await prisma.homepageContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomepageContentFindFirstOrThrowArgs>(args?: SelectSubset<T, HomepageContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HomepageContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomepageContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomepageContents
     * const homepageContents = await prisma.homepageContent.findMany()
     * 
     * // Get first 10 HomepageContents
     * const homepageContents = await prisma.homepageContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homepageContentWithIdOnly = await prisma.homepageContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomepageContentFindManyArgs>(args?: SelectSubset<T, HomepageContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HomepageContent.
     * @param {HomepageContentCreateArgs} args - Arguments to create a HomepageContent.
     * @example
     * // Create one HomepageContent
     * const HomepageContent = await prisma.homepageContent.create({
     *   data: {
     *     // ... data to create a HomepageContent
     *   }
     * })
     * 
     */
    create<T extends HomepageContentCreateArgs>(args: SelectSubset<T, HomepageContentCreateArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HomepageContents.
     * @param {HomepageContentCreateManyArgs} args - Arguments to create many HomepageContents.
     * @example
     * // Create many HomepageContents
     * const homepageContent = await prisma.homepageContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomepageContentCreateManyArgs>(args?: SelectSubset<T, HomepageContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomepageContents and returns the data saved in the database.
     * @param {HomepageContentCreateManyAndReturnArgs} args - Arguments to create many HomepageContents.
     * @example
     * // Create many HomepageContents
     * const homepageContent = await prisma.homepageContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomepageContents and only return the `id`
     * const homepageContentWithIdOnly = await prisma.homepageContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomepageContentCreateManyAndReturnArgs>(args?: SelectSubset<T, HomepageContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HomepageContent.
     * @param {HomepageContentDeleteArgs} args - Arguments to delete one HomepageContent.
     * @example
     * // Delete one HomepageContent
     * const HomepageContent = await prisma.homepageContent.delete({
     *   where: {
     *     // ... filter to delete one HomepageContent
     *   }
     * })
     * 
     */
    delete<T extends HomepageContentDeleteArgs>(args: SelectSubset<T, HomepageContentDeleteArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HomepageContent.
     * @param {HomepageContentUpdateArgs} args - Arguments to update one HomepageContent.
     * @example
     * // Update one HomepageContent
     * const homepageContent = await prisma.homepageContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomepageContentUpdateArgs>(args: SelectSubset<T, HomepageContentUpdateArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HomepageContents.
     * @param {HomepageContentDeleteManyArgs} args - Arguments to filter HomepageContents to delete.
     * @example
     * // Delete a few HomepageContents
     * const { count } = await prisma.homepageContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomepageContentDeleteManyArgs>(args?: SelectSubset<T, HomepageContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomepageContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomepageContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomepageContents
     * const homepageContent = await prisma.homepageContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomepageContentUpdateManyArgs>(args: SelectSubset<T, HomepageContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomepageContent.
     * @param {HomepageContentUpsertArgs} args - Arguments to update or create a HomepageContent.
     * @example
     * // Update or create a HomepageContent
     * const homepageContent = await prisma.homepageContent.upsert({
     *   create: {
     *     // ... data to create a HomepageContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomepageContent we want to update
     *   }
     * })
     */
    upsert<T extends HomepageContentUpsertArgs>(args: SelectSubset<T, HomepageContentUpsertArgs<ExtArgs>>): Prisma__HomepageContentClient<$Result.GetResult<Prisma.$HomepageContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HomepageContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomepageContentCountArgs} args - Arguments to filter HomepageContents to count.
     * @example
     * // Count the number of HomepageContents
     * const count = await prisma.homepageContent.count({
     *   where: {
     *     // ... the filter for the HomepageContents we want to count
     *   }
     * })
    **/
    count<T extends HomepageContentCountArgs>(
      args?: Subset<T, HomepageContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomepageContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomepageContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomepageContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomepageContentAggregateArgs>(args: Subset<T, HomepageContentAggregateArgs>): Prisma.PrismaPromise<GetHomepageContentAggregateType<T>>

    /**
     * Group by HomepageContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomepageContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomepageContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomepageContentGroupByArgs['orderBy'] }
        : { orderBy?: HomepageContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomepageContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomepageContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomepageContent model
   */
  readonly fields: HomepageContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomepageContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomepageContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomepageContent model
   */ 
  interface HomepageContentFieldRefs {
    readonly id: FieldRef<"HomepageContent", 'String'>
    readonly heroTitle: FieldRef<"HomepageContent", 'String'>
    readonly heroSubtitle: FieldRef<"HomepageContent", 'String'>
    readonly heroRating: FieldRef<"HomepageContent", 'String'>
    readonly heroReviewCount: FieldRef<"HomepageContent", 'String'>
    readonly heroCtaButtons: FieldRef<"HomepageContent", 'Json'>
    readonly isActive: FieldRef<"HomepageContent", 'Boolean'>
    readonly updatedAt: FieldRef<"HomepageContent", 'DateTime'>
    readonly benefits: FieldRef<"HomepageContent", 'Json'>
    readonly heroProfileEngagement: FieldRef<"HomepageContent", 'String'>
    readonly heroProfileFollowers: FieldRef<"HomepageContent", 'String'>
    readonly heroProfileHandle: FieldRef<"HomepageContent", 'String'>
    readonly heroProfileLikes: FieldRef<"HomepageContent", 'String'>
    readonly heroProfileRole: FieldRef<"HomepageContent", 'String'>
    readonly influenceSubtitle: FieldRef<"HomepageContent", 'String'>
    readonly influenceTitle: FieldRef<"HomepageContent", 'String'>
    readonly platformSubtitle: FieldRef<"HomepageContent", 'String'>
    readonly platformTitle: FieldRef<"HomepageContent", 'String'>
    readonly quickStartDescription1: FieldRef<"HomepageContent", 'String'>
    readonly quickStartDescription2: FieldRef<"HomepageContent", 'String'>
    readonly quickStartTitle: FieldRef<"HomepageContent", 'String'>
    readonly whyChooseSubtitle: FieldRef<"HomepageContent", 'String'>
    readonly whyChooseTitle: FieldRef<"HomepageContent", 'String'>
    readonly platformCards: FieldRef<"HomepageContent", 'Json'>
    readonly heroProfileImage: FieldRef<"HomepageContent", 'String'>
    readonly influenceImage: FieldRef<"HomepageContent", 'String'>
    readonly influenceSteps: FieldRef<"HomepageContent", 'Json'>
    readonly quickStartButtons: FieldRef<"HomepageContent", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * HomepageContent findUnique
   */
  export type HomepageContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * Filter, which HomepageContent to fetch.
     */
    where: HomepageContentWhereUniqueInput
  }

  /**
   * HomepageContent findUniqueOrThrow
   */
  export type HomepageContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * Filter, which HomepageContent to fetch.
     */
    where: HomepageContentWhereUniqueInput
  }

  /**
   * HomepageContent findFirst
   */
  export type HomepageContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * Filter, which HomepageContent to fetch.
     */
    where?: HomepageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomepageContents to fetch.
     */
    orderBy?: HomepageContentOrderByWithRelationInput | HomepageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomepageContents.
     */
    cursor?: HomepageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomepageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomepageContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomepageContents.
     */
    distinct?: HomepageContentScalarFieldEnum | HomepageContentScalarFieldEnum[]
  }

  /**
   * HomepageContent findFirstOrThrow
   */
  export type HomepageContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * Filter, which HomepageContent to fetch.
     */
    where?: HomepageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomepageContents to fetch.
     */
    orderBy?: HomepageContentOrderByWithRelationInput | HomepageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomepageContents.
     */
    cursor?: HomepageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomepageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomepageContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomepageContents.
     */
    distinct?: HomepageContentScalarFieldEnum | HomepageContentScalarFieldEnum[]
  }

  /**
   * HomepageContent findMany
   */
  export type HomepageContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * Filter, which HomepageContents to fetch.
     */
    where?: HomepageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomepageContents to fetch.
     */
    orderBy?: HomepageContentOrderByWithRelationInput | HomepageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomepageContents.
     */
    cursor?: HomepageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomepageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomepageContents.
     */
    skip?: number
    distinct?: HomepageContentScalarFieldEnum | HomepageContentScalarFieldEnum[]
  }

  /**
   * HomepageContent create
   */
  export type HomepageContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * The data needed to create a HomepageContent.
     */
    data: XOR<HomepageContentCreateInput, HomepageContentUncheckedCreateInput>
  }

  /**
   * HomepageContent createMany
   */
  export type HomepageContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomepageContents.
     */
    data: HomepageContentCreateManyInput | HomepageContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomepageContent createManyAndReturn
   */
  export type HomepageContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HomepageContents.
     */
    data: HomepageContentCreateManyInput | HomepageContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomepageContent update
   */
  export type HomepageContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * The data needed to update a HomepageContent.
     */
    data: XOR<HomepageContentUpdateInput, HomepageContentUncheckedUpdateInput>
    /**
     * Choose, which HomepageContent to update.
     */
    where: HomepageContentWhereUniqueInput
  }

  /**
   * HomepageContent updateMany
   */
  export type HomepageContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomepageContents.
     */
    data: XOR<HomepageContentUpdateManyMutationInput, HomepageContentUncheckedUpdateManyInput>
    /**
     * Filter which HomepageContents to update
     */
    where?: HomepageContentWhereInput
  }

  /**
   * HomepageContent upsert
   */
  export type HomepageContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * The filter to search for the HomepageContent to update in case it exists.
     */
    where: HomepageContentWhereUniqueInput
    /**
     * In case the HomepageContent found by the `where` argument doesn't exist, create a new HomepageContent with this data.
     */
    create: XOR<HomepageContentCreateInput, HomepageContentUncheckedCreateInput>
    /**
     * In case the HomepageContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomepageContentUpdateInput, HomepageContentUncheckedUpdateInput>
  }

  /**
   * HomepageContent delete
   */
  export type HomepageContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
    /**
     * Filter which HomepageContent to delete.
     */
    where: HomepageContentWhereUniqueInput
  }

  /**
   * HomepageContent deleteMany
   */
  export type HomepageContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomepageContents to delete
     */
    where?: HomepageContentWhereInput
  }

  /**
   * HomepageContent without action
   */
  export type HomepageContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomepageContent
     */
    select?: HomepageContentSelect<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    description: string | null
    twitterUrl: string | null
    linkedinUrl: string | null
    avatarUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    description: string | null
    twitterUrl: string | null
    linkedinUrl: string | null
    avatarUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    name: number
    role: number
    description: number
    twitterUrl: number
    linkedinUrl: number
    avatarUrl: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TeamMemberSumAggregateInputType = {
    displayOrder?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    description?: true
    twitterUrl?: true
    linkedinUrl?: true
    avatarUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    description?: true
    twitterUrl?: true
    linkedinUrl?: true
    avatarUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    description?: true
    twitterUrl?: true
    linkedinUrl?: true
    avatarUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    name: string
    role: string
    description: string
    twitterUrl: string | null
    linkedinUrl: string | null
    avatarUrl: string | null
    displayOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    description?: boolean
    twitterUrl?: boolean
    linkedinUrl?: boolean
    avatarUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    description?: boolean
    twitterUrl?: boolean
    linkedinUrl?: boolean
    avatarUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    description?: boolean
    twitterUrl?: boolean
    linkedinUrl?: boolean
    avatarUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      description: string
      twitterUrl: string | null
      linkedinUrl: string | null
      avatarUrl: string | null
      displayOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly name: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'String'>
    readonly description: FieldRef<"TeamMember", 'String'>
    readonly twitterUrl: FieldRef<"TeamMember", 'String'>
    readonly linkedinUrl: FieldRef<"TeamMember", 'String'>
    readonly avatarUrl: FieldRef<"TeamMember", 'String'>
    readonly displayOrder: FieldRef<"TeamMember", 'Int'>
    readonly isActive: FieldRef<"TeamMember", 'Boolean'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
  }


  /**
   * Model HeroSocialUpdate
   */

  export type AggregateHeroSocialUpdate = {
    _count: HeroSocialUpdateCountAggregateOutputType | null
    _avg: HeroSocialUpdateAvgAggregateOutputType | null
    _sum: HeroSocialUpdateSumAggregateOutputType | null
    _min: HeroSocialUpdateMinAggregateOutputType | null
    _max: HeroSocialUpdateMaxAggregateOutputType | null
  }

  export type HeroSocialUpdateAvgAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type HeroSocialUpdateSumAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type HeroSocialUpdateMinAggregateOutputType = {
    id: number | null
    handle: string | null
    item: string | null
    time: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type HeroSocialUpdateMaxAggregateOutputType = {
    id: number | null
    handle: string | null
    item: string | null
    time: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type HeroSocialUpdateCountAggregateOutputType = {
    id: number
    handle: number
    item: number
    time: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type HeroSocialUpdateAvgAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type HeroSocialUpdateSumAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type HeroSocialUpdateMinAggregateInputType = {
    id?: true
    handle?: true
    item?: true
    time?: true
    displayOrder?: true
    isActive?: true
  }

  export type HeroSocialUpdateMaxAggregateInputType = {
    id?: true
    handle?: true
    item?: true
    time?: true
    displayOrder?: true
    isActive?: true
  }

  export type HeroSocialUpdateCountAggregateInputType = {
    id?: true
    handle?: true
    item?: true
    time?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type HeroSocialUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSocialUpdate to aggregate.
     */
    where?: HeroSocialUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSocialUpdates to fetch.
     */
    orderBy?: HeroSocialUpdateOrderByWithRelationInput | HeroSocialUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroSocialUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSocialUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSocialUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroSocialUpdates
    **/
    _count?: true | HeroSocialUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HeroSocialUpdateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HeroSocialUpdateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroSocialUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroSocialUpdateMaxAggregateInputType
  }

  export type GetHeroSocialUpdateAggregateType<T extends HeroSocialUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroSocialUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroSocialUpdate[P]>
      : GetScalarType<T[P], AggregateHeroSocialUpdate[P]>
  }




  export type HeroSocialUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroSocialUpdateWhereInput
    orderBy?: HeroSocialUpdateOrderByWithAggregationInput | HeroSocialUpdateOrderByWithAggregationInput[]
    by: HeroSocialUpdateScalarFieldEnum[] | HeroSocialUpdateScalarFieldEnum
    having?: HeroSocialUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroSocialUpdateCountAggregateInputType | true
    _avg?: HeroSocialUpdateAvgAggregateInputType
    _sum?: HeroSocialUpdateSumAggregateInputType
    _min?: HeroSocialUpdateMinAggregateInputType
    _max?: HeroSocialUpdateMaxAggregateInputType
  }

  export type HeroSocialUpdateGroupByOutputType = {
    id: number
    handle: string
    item: string
    time: string
    displayOrder: number
    isActive: boolean
    _count: HeroSocialUpdateCountAggregateOutputType | null
    _avg: HeroSocialUpdateAvgAggregateOutputType | null
    _sum: HeroSocialUpdateSumAggregateOutputType | null
    _min: HeroSocialUpdateMinAggregateOutputType | null
    _max: HeroSocialUpdateMaxAggregateOutputType | null
  }

  type GetHeroSocialUpdateGroupByPayload<T extends HeroSocialUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroSocialUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroSocialUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroSocialUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], HeroSocialUpdateGroupByOutputType[P]>
        }
      >
    >


  export type HeroSocialUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    handle?: boolean
    item?: boolean
    time?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["heroSocialUpdate"]>

  export type HeroSocialUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    handle?: boolean
    item?: boolean
    time?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["heroSocialUpdate"]>

  export type HeroSocialUpdateSelectScalar = {
    id?: boolean
    handle?: boolean
    item?: boolean
    time?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }


  export type $HeroSocialUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroSocialUpdate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      handle: string
      item: string
      time: string
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["heroSocialUpdate"]>
    composites: {}
  }

  type HeroSocialUpdateGetPayload<S extends boolean | null | undefined | HeroSocialUpdateDefaultArgs> = $Result.GetResult<Prisma.$HeroSocialUpdatePayload, S>

  type HeroSocialUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HeroSocialUpdateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HeroSocialUpdateCountAggregateInputType | true
    }

  export interface HeroSocialUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroSocialUpdate'], meta: { name: 'HeroSocialUpdate' } }
    /**
     * Find zero or one HeroSocialUpdate that matches the filter.
     * @param {HeroSocialUpdateFindUniqueArgs} args - Arguments to find a HeroSocialUpdate
     * @example
     * // Get one HeroSocialUpdate
     * const heroSocialUpdate = await prisma.heroSocialUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroSocialUpdateFindUniqueArgs>(args: SelectSubset<T, HeroSocialUpdateFindUniqueArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HeroSocialUpdate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HeroSocialUpdateFindUniqueOrThrowArgs} args - Arguments to find a HeroSocialUpdate
     * @example
     * // Get one HeroSocialUpdate
     * const heroSocialUpdate = await prisma.heroSocialUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroSocialUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroSocialUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HeroSocialUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSocialUpdateFindFirstArgs} args - Arguments to find a HeroSocialUpdate
     * @example
     * // Get one HeroSocialUpdate
     * const heroSocialUpdate = await prisma.heroSocialUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroSocialUpdateFindFirstArgs>(args?: SelectSubset<T, HeroSocialUpdateFindFirstArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HeroSocialUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSocialUpdateFindFirstOrThrowArgs} args - Arguments to find a HeroSocialUpdate
     * @example
     * // Get one HeroSocialUpdate
     * const heroSocialUpdate = await prisma.heroSocialUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroSocialUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroSocialUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HeroSocialUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSocialUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroSocialUpdates
     * const heroSocialUpdates = await prisma.heroSocialUpdate.findMany()
     * 
     * // Get first 10 HeroSocialUpdates
     * const heroSocialUpdates = await prisma.heroSocialUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroSocialUpdateWithIdOnly = await prisma.heroSocialUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroSocialUpdateFindManyArgs>(args?: SelectSubset<T, HeroSocialUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HeroSocialUpdate.
     * @param {HeroSocialUpdateCreateArgs} args - Arguments to create a HeroSocialUpdate.
     * @example
     * // Create one HeroSocialUpdate
     * const HeroSocialUpdate = await prisma.heroSocialUpdate.create({
     *   data: {
     *     // ... data to create a HeroSocialUpdate
     *   }
     * })
     * 
     */
    create<T extends HeroSocialUpdateCreateArgs>(args: SelectSubset<T, HeroSocialUpdateCreateArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HeroSocialUpdates.
     * @param {HeroSocialUpdateCreateManyArgs} args - Arguments to create many HeroSocialUpdates.
     * @example
     * // Create many HeroSocialUpdates
     * const heroSocialUpdate = await prisma.heroSocialUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroSocialUpdateCreateManyArgs>(args?: SelectSubset<T, HeroSocialUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HeroSocialUpdates and returns the data saved in the database.
     * @param {HeroSocialUpdateCreateManyAndReturnArgs} args - Arguments to create many HeroSocialUpdates.
     * @example
     * // Create many HeroSocialUpdates
     * const heroSocialUpdate = await prisma.heroSocialUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HeroSocialUpdates and only return the `id`
     * const heroSocialUpdateWithIdOnly = await prisma.heroSocialUpdate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HeroSocialUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, HeroSocialUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HeroSocialUpdate.
     * @param {HeroSocialUpdateDeleteArgs} args - Arguments to delete one HeroSocialUpdate.
     * @example
     * // Delete one HeroSocialUpdate
     * const HeroSocialUpdate = await prisma.heroSocialUpdate.delete({
     *   where: {
     *     // ... filter to delete one HeroSocialUpdate
     *   }
     * })
     * 
     */
    delete<T extends HeroSocialUpdateDeleteArgs>(args: SelectSubset<T, HeroSocialUpdateDeleteArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HeroSocialUpdate.
     * @param {HeroSocialUpdateUpdateArgs} args - Arguments to update one HeroSocialUpdate.
     * @example
     * // Update one HeroSocialUpdate
     * const heroSocialUpdate = await prisma.heroSocialUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroSocialUpdateUpdateArgs>(args: SelectSubset<T, HeroSocialUpdateUpdateArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HeroSocialUpdates.
     * @param {HeroSocialUpdateDeleteManyArgs} args - Arguments to filter HeroSocialUpdates to delete.
     * @example
     * // Delete a few HeroSocialUpdates
     * const { count } = await prisma.heroSocialUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroSocialUpdateDeleteManyArgs>(args?: SelectSubset<T, HeroSocialUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroSocialUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSocialUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroSocialUpdates
     * const heroSocialUpdate = await prisma.heroSocialUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroSocialUpdateUpdateManyArgs>(args: SelectSubset<T, HeroSocialUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HeroSocialUpdate.
     * @param {HeroSocialUpdateUpsertArgs} args - Arguments to update or create a HeroSocialUpdate.
     * @example
     * // Update or create a HeroSocialUpdate
     * const heroSocialUpdate = await prisma.heroSocialUpdate.upsert({
     *   create: {
     *     // ... data to create a HeroSocialUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroSocialUpdate we want to update
     *   }
     * })
     */
    upsert<T extends HeroSocialUpdateUpsertArgs>(args: SelectSubset<T, HeroSocialUpdateUpsertArgs<ExtArgs>>): Prisma__HeroSocialUpdateClient<$Result.GetResult<Prisma.$HeroSocialUpdatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HeroSocialUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSocialUpdateCountArgs} args - Arguments to filter HeroSocialUpdates to count.
     * @example
     * // Count the number of HeroSocialUpdates
     * const count = await prisma.heroSocialUpdate.count({
     *   where: {
     *     // ... the filter for the HeroSocialUpdates we want to count
     *   }
     * })
    **/
    count<T extends HeroSocialUpdateCountArgs>(
      args?: Subset<T, HeroSocialUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroSocialUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroSocialUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSocialUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroSocialUpdateAggregateArgs>(args: Subset<T, HeroSocialUpdateAggregateArgs>): Prisma.PrismaPromise<GetHeroSocialUpdateAggregateType<T>>

    /**
     * Group by HeroSocialUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSocialUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroSocialUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroSocialUpdateGroupByArgs['orderBy'] }
        : { orderBy?: HeroSocialUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroSocialUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroSocialUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroSocialUpdate model
   */
  readonly fields: HeroSocialUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroSocialUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroSocialUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroSocialUpdate model
   */ 
  interface HeroSocialUpdateFieldRefs {
    readonly id: FieldRef<"HeroSocialUpdate", 'Int'>
    readonly handle: FieldRef<"HeroSocialUpdate", 'String'>
    readonly item: FieldRef<"HeroSocialUpdate", 'String'>
    readonly time: FieldRef<"HeroSocialUpdate", 'String'>
    readonly displayOrder: FieldRef<"HeroSocialUpdate", 'Int'>
    readonly isActive: FieldRef<"HeroSocialUpdate", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * HeroSocialUpdate findUnique
   */
  export type HeroSocialUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * Filter, which HeroSocialUpdate to fetch.
     */
    where: HeroSocialUpdateWhereUniqueInput
  }

  /**
   * HeroSocialUpdate findUniqueOrThrow
   */
  export type HeroSocialUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * Filter, which HeroSocialUpdate to fetch.
     */
    where: HeroSocialUpdateWhereUniqueInput
  }

  /**
   * HeroSocialUpdate findFirst
   */
  export type HeroSocialUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * Filter, which HeroSocialUpdate to fetch.
     */
    where?: HeroSocialUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSocialUpdates to fetch.
     */
    orderBy?: HeroSocialUpdateOrderByWithRelationInput | HeroSocialUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSocialUpdates.
     */
    cursor?: HeroSocialUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSocialUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSocialUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSocialUpdates.
     */
    distinct?: HeroSocialUpdateScalarFieldEnum | HeroSocialUpdateScalarFieldEnum[]
  }

  /**
   * HeroSocialUpdate findFirstOrThrow
   */
  export type HeroSocialUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * Filter, which HeroSocialUpdate to fetch.
     */
    where?: HeroSocialUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSocialUpdates to fetch.
     */
    orderBy?: HeroSocialUpdateOrderByWithRelationInput | HeroSocialUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSocialUpdates.
     */
    cursor?: HeroSocialUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSocialUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSocialUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSocialUpdates.
     */
    distinct?: HeroSocialUpdateScalarFieldEnum | HeroSocialUpdateScalarFieldEnum[]
  }

  /**
   * HeroSocialUpdate findMany
   */
  export type HeroSocialUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * Filter, which HeroSocialUpdates to fetch.
     */
    where?: HeroSocialUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSocialUpdates to fetch.
     */
    orderBy?: HeroSocialUpdateOrderByWithRelationInput | HeroSocialUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroSocialUpdates.
     */
    cursor?: HeroSocialUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSocialUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSocialUpdates.
     */
    skip?: number
    distinct?: HeroSocialUpdateScalarFieldEnum | HeroSocialUpdateScalarFieldEnum[]
  }

  /**
   * HeroSocialUpdate create
   */
  export type HeroSocialUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * The data needed to create a HeroSocialUpdate.
     */
    data: XOR<HeroSocialUpdateCreateInput, HeroSocialUpdateUncheckedCreateInput>
  }

  /**
   * HeroSocialUpdate createMany
   */
  export type HeroSocialUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroSocialUpdates.
     */
    data: HeroSocialUpdateCreateManyInput | HeroSocialUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroSocialUpdate createManyAndReturn
   */
  export type HeroSocialUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HeroSocialUpdates.
     */
    data: HeroSocialUpdateCreateManyInput | HeroSocialUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroSocialUpdate update
   */
  export type HeroSocialUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * The data needed to update a HeroSocialUpdate.
     */
    data: XOR<HeroSocialUpdateUpdateInput, HeroSocialUpdateUncheckedUpdateInput>
    /**
     * Choose, which HeroSocialUpdate to update.
     */
    where: HeroSocialUpdateWhereUniqueInput
  }

  /**
   * HeroSocialUpdate updateMany
   */
  export type HeroSocialUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroSocialUpdates.
     */
    data: XOR<HeroSocialUpdateUpdateManyMutationInput, HeroSocialUpdateUncheckedUpdateManyInput>
    /**
     * Filter which HeroSocialUpdates to update
     */
    where?: HeroSocialUpdateWhereInput
  }

  /**
   * HeroSocialUpdate upsert
   */
  export type HeroSocialUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * The filter to search for the HeroSocialUpdate to update in case it exists.
     */
    where: HeroSocialUpdateWhereUniqueInput
    /**
     * In case the HeroSocialUpdate found by the `where` argument doesn't exist, create a new HeroSocialUpdate with this data.
     */
    create: XOR<HeroSocialUpdateCreateInput, HeroSocialUpdateUncheckedCreateInput>
    /**
     * In case the HeroSocialUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroSocialUpdateUpdateInput, HeroSocialUpdateUncheckedUpdateInput>
  }

  /**
   * HeroSocialUpdate delete
   */
  export type HeroSocialUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
    /**
     * Filter which HeroSocialUpdate to delete.
     */
    where: HeroSocialUpdateWhereUniqueInput
  }

  /**
   * HeroSocialUpdate deleteMany
   */
  export type HeroSocialUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSocialUpdates to delete
     */
    where?: HeroSocialUpdateWhereInput
  }

  /**
   * HeroSocialUpdate without action
   */
  export type HeroSocialUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSocialUpdate
     */
    select?: HeroSocialUpdateSelect<ExtArgs> | null
  }


  /**
   * Model PromoBar
   */

  export type AggregatePromoBar = {
    _count: PromoBarCountAggregateOutputType | null
    _avg: PromoBarAvgAggregateOutputType | null
    _sum: PromoBarSumAggregateOutputType | null
    _min: PromoBarMinAggregateOutputType | null
    _max: PromoBarMaxAggregateOutputType | null
  }

  export type PromoBarAvgAggregateOutputType = {
    countdownSeconds: number | null
    displayOrder: number | null
  }

  export type PromoBarSumAggregateOutputType = {
    countdownSeconds: number | null
    displayOrder: number | null
  }

  export type PromoBarMinAggregateOutputType = {
    id: string | null
    countdownSeconds: number | null
    isVisible: boolean | null
    displayOrder: number | null
    updatedAt: Date | null
  }

  export type PromoBarMaxAggregateOutputType = {
    id: string | null
    countdownSeconds: number | null
    isVisible: boolean | null
    displayOrder: number | null
    updatedAt: Date | null
  }

  export type PromoBarCountAggregateOutputType = {
    id: number
    messages: number
    countdownSeconds: number
    isVisible: number
    displayOrder: number
    updatedAt: number
    _all: number
  }


  export type PromoBarAvgAggregateInputType = {
    countdownSeconds?: true
    displayOrder?: true
  }

  export type PromoBarSumAggregateInputType = {
    countdownSeconds?: true
    displayOrder?: true
  }

  export type PromoBarMinAggregateInputType = {
    id?: true
    countdownSeconds?: true
    isVisible?: true
    displayOrder?: true
    updatedAt?: true
  }

  export type PromoBarMaxAggregateInputType = {
    id?: true
    countdownSeconds?: true
    isVisible?: true
    displayOrder?: true
    updatedAt?: true
  }

  export type PromoBarCountAggregateInputType = {
    id?: true
    messages?: true
    countdownSeconds?: true
    isVisible?: true
    displayOrder?: true
    updatedAt?: true
    _all?: true
  }

  export type PromoBarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoBar to aggregate.
     */
    where?: PromoBarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoBars to fetch.
     */
    orderBy?: PromoBarOrderByWithRelationInput | PromoBarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoBarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoBars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoBars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoBars
    **/
    _count?: true | PromoBarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoBarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoBarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoBarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoBarMaxAggregateInputType
  }

  export type GetPromoBarAggregateType<T extends PromoBarAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoBar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoBar[P]>
      : GetScalarType<T[P], AggregatePromoBar[P]>
  }




  export type PromoBarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoBarWhereInput
    orderBy?: PromoBarOrderByWithAggregationInput | PromoBarOrderByWithAggregationInput[]
    by: PromoBarScalarFieldEnum[] | PromoBarScalarFieldEnum
    having?: PromoBarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoBarCountAggregateInputType | true
    _avg?: PromoBarAvgAggregateInputType
    _sum?: PromoBarSumAggregateInputType
    _min?: PromoBarMinAggregateInputType
    _max?: PromoBarMaxAggregateInputType
  }

  export type PromoBarGroupByOutputType = {
    id: string
    messages: JsonValue
    countdownSeconds: number | null
    isVisible: boolean
    displayOrder: number
    updatedAt: Date
    _count: PromoBarCountAggregateOutputType | null
    _avg: PromoBarAvgAggregateOutputType | null
    _sum: PromoBarSumAggregateOutputType | null
    _min: PromoBarMinAggregateOutputType | null
    _max: PromoBarMaxAggregateOutputType | null
  }

  type GetPromoBarGroupByPayload<T extends PromoBarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoBarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoBarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoBarGroupByOutputType[P]>
            : GetScalarType<T[P], PromoBarGroupByOutputType[P]>
        }
      >
    >


  export type PromoBarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messages?: boolean
    countdownSeconds?: boolean
    isVisible?: boolean
    displayOrder?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoBar"]>

  export type PromoBarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messages?: boolean
    countdownSeconds?: boolean
    isVisible?: boolean
    displayOrder?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promoBar"]>

  export type PromoBarSelectScalar = {
    id?: boolean
    messages?: boolean
    countdownSeconds?: boolean
    isVisible?: boolean
    displayOrder?: boolean
    updatedAt?: boolean
  }


  export type $PromoBarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoBar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messages: Prisma.JsonValue
      countdownSeconds: number | null
      isVisible: boolean
      displayOrder: number
      updatedAt: Date
    }, ExtArgs["result"]["promoBar"]>
    composites: {}
  }

  type PromoBarGetPayload<S extends boolean | null | undefined | PromoBarDefaultArgs> = $Result.GetResult<Prisma.$PromoBarPayload, S>

  type PromoBarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromoBarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromoBarCountAggregateInputType | true
    }

  export interface PromoBarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoBar'], meta: { name: 'PromoBar' } }
    /**
     * Find zero or one PromoBar that matches the filter.
     * @param {PromoBarFindUniqueArgs} args - Arguments to find a PromoBar
     * @example
     * // Get one PromoBar
     * const promoBar = await prisma.promoBar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoBarFindUniqueArgs>(args: SelectSubset<T, PromoBarFindUniqueArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromoBar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromoBarFindUniqueOrThrowArgs} args - Arguments to find a PromoBar
     * @example
     * // Get one PromoBar
     * const promoBar = await prisma.promoBar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoBarFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoBarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromoBar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoBarFindFirstArgs} args - Arguments to find a PromoBar
     * @example
     * // Get one PromoBar
     * const promoBar = await prisma.promoBar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoBarFindFirstArgs>(args?: SelectSubset<T, PromoBarFindFirstArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromoBar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoBarFindFirstOrThrowArgs} args - Arguments to find a PromoBar
     * @example
     * // Get one PromoBar
     * const promoBar = await prisma.promoBar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoBarFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoBarFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromoBars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoBarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoBars
     * const promoBars = await prisma.promoBar.findMany()
     * 
     * // Get first 10 PromoBars
     * const promoBars = await prisma.promoBar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoBarWithIdOnly = await prisma.promoBar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoBarFindManyArgs>(args?: SelectSubset<T, PromoBarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromoBar.
     * @param {PromoBarCreateArgs} args - Arguments to create a PromoBar.
     * @example
     * // Create one PromoBar
     * const PromoBar = await prisma.promoBar.create({
     *   data: {
     *     // ... data to create a PromoBar
     *   }
     * })
     * 
     */
    create<T extends PromoBarCreateArgs>(args: SelectSubset<T, PromoBarCreateArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromoBars.
     * @param {PromoBarCreateManyArgs} args - Arguments to create many PromoBars.
     * @example
     * // Create many PromoBars
     * const promoBar = await prisma.promoBar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoBarCreateManyArgs>(args?: SelectSubset<T, PromoBarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoBars and returns the data saved in the database.
     * @param {PromoBarCreateManyAndReturnArgs} args - Arguments to create many PromoBars.
     * @example
     * // Create many PromoBars
     * const promoBar = await prisma.promoBar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoBars and only return the `id`
     * const promoBarWithIdOnly = await prisma.promoBar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoBarCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoBarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromoBar.
     * @param {PromoBarDeleteArgs} args - Arguments to delete one PromoBar.
     * @example
     * // Delete one PromoBar
     * const PromoBar = await prisma.promoBar.delete({
     *   where: {
     *     // ... filter to delete one PromoBar
     *   }
     * })
     * 
     */
    delete<T extends PromoBarDeleteArgs>(args: SelectSubset<T, PromoBarDeleteArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromoBar.
     * @param {PromoBarUpdateArgs} args - Arguments to update one PromoBar.
     * @example
     * // Update one PromoBar
     * const promoBar = await prisma.promoBar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoBarUpdateArgs>(args: SelectSubset<T, PromoBarUpdateArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromoBars.
     * @param {PromoBarDeleteManyArgs} args - Arguments to filter PromoBars to delete.
     * @example
     * // Delete a few PromoBars
     * const { count } = await prisma.promoBar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoBarDeleteManyArgs>(args?: SelectSubset<T, PromoBarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoBars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoBarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoBars
     * const promoBar = await prisma.promoBar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoBarUpdateManyArgs>(args: SelectSubset<T, PromoBarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromoBar.
     * @param {PromoBarUpsertArgs} args - Arguments to update or create a PromoBar.
     * @example
     * // Update or create a PromoBar
     * const promoBar = await prisma.promoBar.upsert({
     *   create: {
     *     // ... data to create a PromoBar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoBar we want to update
     *   }
     * })
     */
    upsert<T extends PromoBarUpsertArgs>(args: SelectSubset<T, PromoBarUpsertArgs<ExtArgs>>): Prisma__PromoBarClient<$Result.GetResult<Prisma.$PromoBarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromoBars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoBarCountArgs} args - Arguments to filter PromoBars to count.
     * @example
     * // Count the number of PromoBars
     * const count = await prisma.promoBar.count({
     *   where: {
     *     // ... the filter for the PromoBars we want to count
     *   }
     * })
    **/
    count<T extends PromoBarCountArgs>(
      args?: Subset<T, PromoBarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoBarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoBar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoBarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoBarAggregateArgs>(args: Subset<T, PromoBarAggregateArgs>): Prisma.PrismaPromise<GetPromoBarAggregateType<T>>

    /**
     * Group by PromoBar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoBarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoBarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoBarGroupByArgs['orderBy'] }
        : { orderBy?: PromoBarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoBarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoBarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoBar model
   */
  readonly fields: PromoBarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoBar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoBarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoBar model
   */ 
  interface PromoBarFieldRefs {
    readonly id: FieldRef<"PromoBar", 'String'>
    readonly messages: FieldRef<"PromoBar", 'Json'>
    readonly countdownSeconds: FieldRef<"PromoBar", 'Int'>
    readonly isVisible: FieldRef<"PromoBar", 'Boolean'>
    readonly displayOrder: FieldRef<"PromoBar", 'Int'>
    readonly updatedAt: FieldRef<"PromoBar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoBar findUnique
   */
  export type PromoBarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * Filter, which PromoBar to fetch.
     */
    where: PromoBarWhereUniqueInput
  }

  /**
   * PromoBar findUniqueOrThrow
   */
  export type PromoBarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * Filter, which PromoBar to fetch.
     */
    where: PromoBarWhereUniqueInput
  }

  /**
   * PromoBar findFirst
   */
  export type PromoBarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * Filter, which PromoBar to fetch.
     */
    where?: PromoBarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoBars to fetch.
     */
    orderBy?: PromoBarOrderByWithRelationInput | PromoBarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoBars.
     */
    cursor?: PromoBarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoBars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoBars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoBars.
     */
    distinct?: PromoBarScalarFieldEnum | PromoBarScalarFieldEnum[]
  }

  /**
   * PromoBar findFirstOrThrow
   */
  export type PromoBarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * Filter, which PromoBar to fetch.
     */
    where?: PromoBarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoBars to fetch.
     */
    orderBy?: PromoBarOrderByWithRelationInput | PromoBarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoBars.
     */
    cursor?: PromoBarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoBars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoBars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoBars.
     */
    distinct?: PromoBarScalarFieldEnum | PromoBarScalarFieldEnum[]
  }

  /**
   * PromoBar findMany
   */
  export type PromoBarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * Filter, which PromoBars to fetch.
     */
    where?: PromoBarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoBars to fetch.
     */
    orderBy?: PromoBarOrderByWithRelationInput | PromoBarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoBars.
     */
    cursor?: PromoBarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoBars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoBars.
     */
    skip?: number
    distinct?: PromoBarScalarFieldEnum | PromoBarScalarFieldEnum[]
  }

  /**
   * PromoBar create
   */
  export type PromoBarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * The data needed to create a PromoBar.
     */
    data: XOR<PromoBarCreateInput, PromoBarUncheckedCreateInput>
  }

  /**
   * PromoBar createMany
   */
  export type PromoBarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoBars.
     */
    data: PromoBarCreateManyInput | PromoBarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoBar createManyAndReturn
   */
  export type PromoBarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromoBars.
     */
    data: PromoBarCreateManyInput | PromoBarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoBar update
   */
  export type PromoBarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * The data needed to update a PromoBar.
     */
    data: XOR<PromoBarUpdateInput, PromoBarUncheckedUpdateInput>
    /**
     * Choose, which PromoBar to update.
     */
    where: PromoBarWhereUniqueInput
  }

  /**
   * PromoBar updateMany
   */
  export type PromoBarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoBars.
     */
    data: XOR<PromoBarUpdateManyMutationInput, PromoBarUncheckedUpdateManyInput>
    /**
     * Filter which PromoBars to update
     */
    where?: PromoBarWhereInput
  }

  /**
   * PromoBar upsert
   */
  export type PromoBarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * The filter to search for the PromoBar to update in case it exists.
     */
    where: PromoBarWhereUniqueInput
    /**
     * In case the PromoBar found by the `where` argument doesn't exist, create a new PromoBar with this data.
     */
    create: XOR<PromoBarCreateInput, PromoBarUncheckedCreateInput>
    /**
     * In case the PromoBar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoBarUpdateInput, PromoBarUncheckedUpdateInput>
  }

  /**
   * PromoBar delete
   */
  export type PromoBarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
    /**
     * Filter which PromoBar to delete.
     */
    where: PromoBarWhereUniqueInput
  }

  /**
   * PromoBar deleteMany
   */
  export type PromoBarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoBars to delete
     */
    where?: PromoBarWhereInput
  }

  /**
   * PromoBar without action
   */
  export type PromoBarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoBar
     */
    select?: PromoBarSelect<ExtArgs> | null
  }


  /**
   * Model FeaturedOn
   */

  export type AggregateFeaturedOn = {
    _count: FeaturedOnCountAggregateOutputType | null
    _avg: FeaturedOnAvgAggregateOutputType | null
    _sum: FeaturedOnSumAggregateOutputType | null
    _min: FeaturedOnMinAggregateOutputType | null
    _max: FeaturedOnMaxAggregateOutputType | null
  }

  export type FeaturedOnAvgAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type FeaturedOnSumAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type FeaturedOnMinAggregateOutputType = {
    id: number | null
    brandName: string | null
    logoUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type FeaturedOnMaxAggregateOutputType = {
    id: number | null
    brandName: string | null
    logoUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
  }

  export type FeaturedOnCountAggregateOutputType = {
    id: number
    brandName: number
    logoUrl: number
    displayOrder: number
    isActive: number
    _all: number
  }


  export type FeaturedOnAvgAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type FeaturedOnSumAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type FeaturedOnMinAggregateInputType = {
    id?: true
    brandName?: true
    logoUrl?: true
    displayOrder?: true
    isActive?: true
  }

  export type FeaturedOnMaxAggregateInputType = {
    id?: true
    brandName?: true
    logoUrl?: true
    displayOrder?: true
    isActive?: true
  }

  export type FeaturedOnCountAggregateInputType = {
    id?: true
    brandName?: true
    logoUrl?: true
    displayOrder?: true
    isActive?: true
    _all?: true
  }

  export type FeaturedOnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedOn to aggregate.
     */
    where?: FeaturedOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOns to fetch.
     */
    orderBy?: FeaturedOnOrderByWithRelationInput | FeaturedOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedOns
    **/
    _count?: true | FeaturedOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturedOnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturedOnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedOnMaxAggregateInputType
  }

  export type GetFeaturedOnAggregateType<T extends FeaturedOnAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedOn[P]>
      : GetScalarType<T[P], AggregateFeaturedOn[P]>
  }




  export type FeaturedOnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedOnWhereInput
    orderBy?: FeaturedOnOrderByWithAggregationInput | FeaturedOnOrderByWithAggregationInput[]
    by: FeaturedOnScalarFieldEnum[] | FeaturedOnScalarFieldEnum
    having?: FeaturedOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedOnCountAggregateInputType | true
    _avg?: FeaturedOnAvgAggregateInputType
    _sum?: FeaturedOnSumAggregateInputType
    _min?: FeaturedOnMinAggregateInputType
    _max?: FeaturedOnMaxAggregateInputType
  }

  export type FeaturedOnGroupByOutputType = {
    id: number
    brandName: string
    logoUrl: string | null
    displayOrder: number
    isActive: boolean
    _count: FeaturedOnCountAggregateOutputType | null
    _avg: FeaturedOnAvgAggregateOutputType | null
    _sum: FeaturedOnSumAggregateOutputType | null
    _min: FeaturedOnMinAggregateOutputType | null
    _max: FeaturedOnMaxAggregateOutputType | null
  }

  type GetFeaturedOnGroupByPayload<T extends FeaturedOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedOnGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedOnGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedOnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandName?: boolean
    logoUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    pageLinks?: boolean | FeaturedOn$pageLinksArgs<ExtArgs>
    _count?: boolean | FeaturedOnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredOn"]>

  export type FeaturedOnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandName?: boolean
    logoUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["featuredOn"]>

  export type FeaturedOnSelectScalar = {
    id?: boolean
    brandName?: boolean
    logoUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
  }

  export type FeaturedOnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pageLinks?: boolean | FeaturedOn$pageLinksArgs<ExtArgs>
    _count?: boolean | FeaturedOnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeaturedOnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeaturedOnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedOn"
    objects: {
      pageLinks: Prisma.$FeaturedOnPageLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brandName: string
      logoUrl: string | null
      displayOrder: number
      isActive: boolean
    }, ExtArgs["result"]["featuredOn"]>
    composites: {}
  }

  type FeaturedOnGetPayload<S extends boolean | null | undefined | FeaturedOnDefaultArgs> = $Result.GetResult<Prisma.$FeaturedOnPayload, S>

  type FeaturedOnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeaturedOnFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeaturedOnCountAggregateInputType | true
    }

  export interface FeaturedOnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedOn'], meta: { name: 'FeaturedOn' } }
    /**
     * Find zero or one FeaturedOn that matches the filter.
     * @param {FeaturedOnFindUniqueArgs} args - Arguments to find a FeaturedOn
     * @example
     * // Get one FeaturedOn
     * const featuredOn = await prisma.featuredOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedOnFindUniqueArgs>(args: SelectSubset<T, FeaturedOnFindUniqueArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeaturedOn that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeaturedOnFindUniqueOrThrowArgs} args - Arguments to find a FeaturedOn
     * @example
     * // Get one FeaturedOn
     * const featuredOn = await prisma.featuredOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedOnFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedOnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeaturedOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnFindFirstArgs} args - Arguments to find a FeaturedOn
     * @example
     * // Get one FeaturedOn
     * const featuredOn = await prisma.featuredOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedOnFindFirstArgs>(args?: SelectSubset<T, FeaturedOnFindFirstArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeaturedOn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnFindFirstOrThrowArgs} args - Arguments to find a FeaturedOn
     * @example
     * // Get one FeaturedOn
     * const featuredOn = await prisma.featuredOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedOnFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedOnFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeaturedOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedOns
     * const featuredOns = await prisma.featuredOn.findMany()
     * 
     * // Get first 10 FeaturedOns
     * const featuredOns = await prisma.featuredOn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredOnWithIdOnly = await prisma.featuredOn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedOnFindManyArgs>(args?: SelectSubset<T, FeaturedOnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeaturedOn.
     * @param {FeaturedOnCreateArgs} args - Arguments to create a FeaturedOn.
     * @example
     * // Create one FeaturedOn
     * const FeaturedOn = await prisma.featuredOn.create({
     *   data: {
     *     // ... data to create a FeaturedOn
     *   }
     * })
     * 
     */
    create<T extends FeaturedOnCreateArgs>(args: SelectSubset<T, FeaturedOnCreateArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeaturedOns.
     * @param {FeaturedOnCreateManyArgs} args - Arguments to create many FeaturedOns.
     * @example
     * // Create many FeaturedOns
     * const featuredOn = await prisma.featuredOn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedOnCreateManyArgs>(args?: SelectSubset<T, FeaturedOnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedOns and returns the data saved in the database.
     * @param {FeaturedOnCreateManyAndReturnArgs} args - Arguments to create many FeaturedOns.
     * @example
     * // Create many FeaturedOns
     * const featuredOn = await prisma.featuredOn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedOns and only return the `id`
     * const featuredOnWithIdOnly = await prisma.featuredOn.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedOnCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedOnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeaturedOn.
     * @param {FeaturedOnDeleteArgs} args - Arguments to delete one FeaturedOn.
     * @example
     * // Delete one FeaturedOn
     * const FeaturedOn = await prisma.featuredOn.delete({
     *   where: {
     *     // ... filter to delete one FeaturedOn
     *   }
     * })
     * 
     */
    delete<T extends FeaturedOnDeleteArgs>(args: SelectSubset<T, FeaturedOnDeleteArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeaturedOn.
     * @param {FeaturedOnUpdateArgs} args - Arguments to update one FeaturedOn.
     * @example
     * // Update one FeaturedOn
     * const featuredOn = await prisma.featuredOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedOnUpdateArgs>(args: SelectSubset<T, FeaturedOnUpdateArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeaturedOns.
     * @param {FeaturedOnDeleteManyArgs} args - Arguments to filter FeaturedOns to delete.
     * @example
     * // Delete a few FeaturedOns
     * const { count } = await prisma.featuredOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedOnDeleteManyArgs>(args?: SelectSubset<T, FeaturedOnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedOns
     * const featuredOn = await prisma.featuredOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedOnUpdateManyArgs>(args: SelectSubset<T, FeaturedOnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeaturedOn.
     * @param {FeaturedOnUpsertArgs} args - Arguments to update or create a FeaturedOn.
     * @example
     * // Update or create a FeaturedOn
     * const featuredOn = await prisma.featuredOn.upsert({
     *   create: {
     *     // ... data to create a FeaturedOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedOn we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedOnUpsertArgs>(args: SelectSubset<T, FeaturedOnUpsertArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeaturedOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnCountArgs} args - Arguments to filter FeaturedOns to count.
     * @example
     * // Count the number of FeaturedOns
     * const count = await prisma.featuredOn.count({
     *   where: {
     *     // ... the filter for the FeaturedOns we want to count
     *   }
     * })
    **/
    count<T extends FeaturedOnCountArgs>(
      args?: Subset<T, FeaturedOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedOnAggregateArgs>(args: Subset<T, FeaturedOnAggregateArgs>): Prisma.PrismaPromise<GetFeaturedOnAggregateType<T>>

    /**
     * Group by FeaturedOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedOnGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedOn model
   */
  readonly fields: FeaturedOnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedOnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pageLinks<T extends FeaturedOn$pageLinksArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedOn$pageLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedOn model
   */ 
  interface FeaturedOnFieldRefs {
    readonly id: FieldRef<"FeaturedOn", 'Int'>
    readonly brandName: FieldRef<"FeaturedOn", 'String'>
    readonly logoUrl: FieldRef<"FeaturedOn", 'String'>
    readonly displayOrder: FieldRef<"FeaturedOn", 'Int'>
    readonly isActive: FieldRef<"FeaturedOn", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedOn findUnique
   */
  export type FeaturedOnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOn to fetch.
     */
    where: FeaturedOnWhereUniqueInput
  }

  /**
   * FeaturedOn findUniqueOrThrow
   */
  export type FeaturedOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOn to fetch.
     */
    where: FeaturedOnWhereUniqueInput
  }

  /**
   * FeaturedOn findFirst
   */
  export type FeaturedOnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOn to fetch.
     */
    where?: FeaturedOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOns to fetch.
     */
    orderBy?: FeaturedOnOrderByWithRelationInput | FeaturedOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedOns.
     */
    cursor?: FeaturedOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedOns.
     */
    distinct?: FeaturedOnScalarFieldEnum | FeaturedOnScalarFieldEnum[]
  }

  /**
   * FeaturedOn findFirstOrThrow
   */
  export type FeaturedOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOn to fetch.
     */
    where?: FeaturedOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOns to fetch.
     */
    orderBy?: FeaturedOnOrderByWithRelationInput | FeaturedOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedOns.
     */
    cursor?: FeaturedOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedOns.
     */
    distinct?: FeaturedOnScalarFieldEnum | FeaturedOnScalarFieldEnum[]
  }

  /**
   * FeaturedOn findMany
   */
  export type FeaturedOnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOns to fetch.
     */
    where?: FeaturedOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOns to fetch.
     */
    orderBy?: FeaturedOnOrderByWithRelationInput | FeaturedOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedOns.
     */
    cursor?: FeaturedOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOns.
     */
    skip?: number
    distinct?: FeaturedOnScalarFieldEnum | FeaturedOnScalarFieldEnum[]
  }

  /**
   * FeaturedOn create
   */
  export type FeaturedOnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedOn.
     */
    data: XOR<FeaturedOnCreateInput, FeaturedOnUncheckedCreateInput>
  }

  /**
   * FeaturedOn createMany
   */
  export type FeaturedOnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedOns.
     */
    data: FeaturedOnCreateManyInput | FeaturedOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedOn createManyAndReturn
   */
  export type FeaturedOnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeaturedOns.
     */
    data: FeaturedOnCreateManyInput | FeaturedOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedOn update
   */
  export type FeaturedOnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedOn.
     */
    data: XOR<FeaturedOnUpdateInput, FeaturedOnUncheckedUpdateInput>
    /**
     * Choose, which FeaturedOn to update.
     */
    where: FeaturedOnWhereUniqueInput
  }

  /**
   * FeaturedOn updateMany
   */
  export type FeaturedOnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedOns.
     */
    data: XOR<FeaturedOnUpdateManyMutationInput, FeaturedOnUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedOns to update
     */
    where?: FeaturedOnWhereInput
  }

  /**
   * FeaturedOn upsert
   */
  export type FeaturedOnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedOn to update in case it exists.
     */
    where: FeaturedOnWhereUniqueInput
    /**
     * In case the FeaturedOn found by the `where` argument doesn't exist, create a new FeaturedOn with this data.
     */
    create: XOR<FeaturedOnCreateInput, FeaturedOnUncheckedCreateInput>
    /**
     * In case the FeaturedOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedOnUpdateInput, FeaturedOnUncheckedUpdateInput>
  }

  /**
   * FeaturedOn delete
   */
  export type FeaturedOnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
    /**
     * Filter which FeaturedOn to delete.
     */
    where: FeaturedOnWhereUniqueInput
  }

  /**
   * FeaturedOn deleteMany
   */
  export type FeaturedOnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedOns to delete
     */
    where?: FeaturedOnWhereInput
  }

  /**
   * FeaturedOn.pageLinks
   */
  export type FeaturedOn$pageLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    where?: FeaturedOnPageLinkWhereInput
    orderBy?: FeaturedOnPageLinkOrderByWithRelationInput | FeaturedOnPageLinkOrderByWithRelationInput[]
    cursor?: FeaturedOnPageLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeaturedOnPageLinkScalarFieldEnum | FeaturedOnPageLinkScalarFieldEnum[]
  }

  /**
   * FeaturedOn without action
   */
  export type FeaturedOnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOn
     */
    select?: FeaturedOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnInclude<ExtArgs> | null
  }


  /**
   * Model FeaturedOnPageLink
   */

  export type AggregateFeaturedOnPageLink = {
    _count: FeaturedOnPageLinkCountAggregateOutputType | null
    _avg: FeaturedOnPageLinkAvgAggregateOutputType | null
    _sum: FeaturedOnPageLinkSumAggregateOutputType | null
    _min: FeaturedOnPageLinkMinAggregateOutputType | null
    _max: FeaturedOnPageLinkMaxAggregateOutputType | null
  }

  export type FeaturedOnPageLinkAvgAggregateOutputType = {
    id: number | null
    featuredOnId: number | null
  }

  export type FeaturedOnPageLinkSumAggregateOutputType = {
    id: number | null
    featuredOnId: number | null
  }

  export type FeaturedOnPageLinkMinAggregateOutputType = {
    id: number | null
    featuredOnId: number | null
    pagePath: string | null
    link: string | null
    nofollow: boolean | null
  }

  export type FeaturedOnPageLinkMaxAggregateOutputType = {
    id: number | null
    featuredOnId: number | null
    pagePath: string | null
    link: string | null
    nofollow: boolean | null
  }

  export type FeaturedOnPageLinkCountAggregateOutputType = {
    id: number
    featuredOnId: number
    pagePath: number
    link: number
    nofollow: number
    _all: number
  }


  export type FeaturedOnPageLinkAvgAggregateInputType = {
    id?: true
    featuredOnId?: true
  }

  export type FeaturedOnPageLinkSumAggregateInputType = {
    id?: true
    featuredOnId?: true
  }

  export type FeaturedOnPageLinkMinAggregateInputType = {
    id?: true
    featuredOnId?: true
    pagePath?: true
    link?: true
    nofollow?: true
  }

  export type FeaturedOnPageLinkMaxAggregateInputType = {
    id?: true
    featuredOnId?: true
    pagePath?: true
    link?: true
    nofollow?: true
  }

  export type FeaturedOnPageLinkCountAggregateInputType = {
    id?: true
    featuredOnId?: true
    pagePath?: true
    link?: true
    nofollow?: true
    _all?: true
  }

  export type FeaturedOnPageLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedOnPageLink to aggregate.
     */
    where?: FeaturedOnPageLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOnPageLinks to fetch.
     */
    orderBy?: FeaturedOnPageLinkOrderByWithRelationInput | FeaturedOnPageLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedOnPageLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOnPageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOnPageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedOnPageLinks
    **/
    _count?: true | FeaturedOnPageLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturedOnPageLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturedOnPageLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedOnPageLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedOnPageLinkMaxAggregateInputType
  }

  export type GetFeaturedOnPageLinkAggregateType<T extends FeaturedOnPageLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedOnPageLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedOnPageLink[P]>
      : GetScalarType<T[P], AggregateFeaturedOnPageLink[P]>
  }




  export type FeaturedOnPageLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedOnPageLinkWhereInput
    orderBy?: FeaturedOnPageLinkOrderByWithAggregationInput | FeaturedOnPageLinkOrderByWithAggregationInput[]
    by: FeaturedOnPageLinkScalarFieldEnum[] | FeaturedOnPageLinkScalarFieldEnum
    having?: FeaturedOnPageLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedOnPageLinkCountAggregateInputType | true
    _avg?: FeaturedOnPageLinkAvgAggregateInputType
    _sum?: FeaturedOnPageLinkSumAggregateInputType
    _min?: FeaturedOnPageLinkMinAggregateInputType
    _max?: FeaturedOnPageLinkMaxAggregateInputType
  }

  export type FeaturedOnPageLinkGroupByOutputType = {
    id: number
    featuredOnId: number
    pagePath: string
    link: string | null
    nofollow: boolean
    _count: FeaturedOnPageLinkCountAggregateOutputType | null
    _avg: FeaturedOnPageLinkAvgAggregateOutputType | null
    _sum: FeaturedOnPageLinkSumAggregateOutputType | null
    _min: FeaturedOnPageLinkMinAggregateOutputType | null
    _max: FeaturedOnPageLinkMaxAggregateOutputType | null
  }

  type GetFeaturedOnPageLinkGroupByPayload<T extends FeaturedOnPageLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedOnPageLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedOnPageLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedOnPageLinkGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedOnPageLinkGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedOnPageLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featuredOnId?: boolean
    pagePath?: boolean
    link?: boolean
    nofollow?: boolean
    featuredOn?: boolean | FeaturedOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredOnPageLink"]>

  export type FeaturedOnPageLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featuredOnId?: boolean
    pagePath?: boolean
    link?: boolean
    nofollow?: boolean
    featuredOn?: boolean | FeaturedOnDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredOnPageLink"]>

  export type FeaturedOnPageLinkSelectScalar = {
    id?: boolean
    featuredOnId?: boolean
    pagePath?: boolean
    link?: boolean
    nofollow?: boolean
  }

  export type FeaturedOnPageLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    featuredOn?: boolean | FeaturedOnDefaultArgs<ExtArgs>
  }
  export type FeaturedOnPageLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    featuredOn?: boolean | FeaturedOnDefaultArgs<ExtArgs>
  }

  export type $FeaturedOnPageLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedOnPageLink"
    objects: {
      featuredOn: Prisma.$FeaturedOnPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      featuredOnId: number
      pagePath: string
      link: string | null
      nofollow: boolean
    }, ExtArgs["result"]["featuredOnPageLink"]>
    composites: {}
  }

  type FeaturedOnPageLinkGetPayload<S extends boolean | null | undefined | FeaturedOnPageLinkDefaultArgs> = $Result.GetResult<Prisma.$FeaturedOnPageLinkPayload, S>

  type FeaturedOnPageLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeaturedOnPageLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeaturedOnPageLinkCountAggregateInputType | true
    }

  export interface FeaturedOnPageLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedOnPageLink'], meta: { name: 'FeaturedOnPageLink' } }
    /**
     * Find zero or one FeaturedOnPageLink that matches the filter.
     * @param {FeaturedOnPageLinkFindUniqueArgs} args - Arguments to find a FeaturedOnPageLink
     * @example
     * // Get one FeaturedOnPageLink
     * const featuredOnPageLink = await prisma.featuredOnPageLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedOnPageLinkFindUniqueArgs>(args: SelectSubset<T, FeaturedOnPageLinkFindUniqueArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeaturedOnPageLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeaturedOnPageLinkFindUniqueOrThrowArgs} args - Arguments to find a FeaturedOnPageLink
     * @example
     * // Get one FeaturedOnPageLink
     * const featuredOnPageLink = await prisma.featuredOnPageLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedOnPageLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedOnPageLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeaturedOnPageLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnPageLinkFindFirstArgs} args - Arguments to find a FeaturedOnPageLink
     * @example
     * // Get one FeaturedOnPageLink
     * const featuredOnPageLink = await prisma.featuredOnPageLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedOnPageLinkFindFirstArgs>(args?: SelectSubset<T, FeaturedOnPageLinkFindFirstArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeaturedOnPageLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnPageLinkFindFirstOrThrowArgs} args - Arguments to find a FeaturedOnPageLink
     * @example
     * // Get one FeaturedOnPageLink
     * const featuredOnPageLink = await prisma.featuredOnPageLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedOnPageLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedOnPageLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeaturedOnPageLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnPageLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedOnPageLinks
     * const featuredOnPageLinks = await prisma.featuredOnPageLink.findMany()
     * 
     * // Get first 10 FeaturedOnPageLinks
     * const featuredOnPageLinks = await prisma.featuredOnPageLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredOnPageLinkWithIdOnly = await prisma.featuredOnPageLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedOnPageLinkFindManyArgs>(args?: SelectSubset<T, FeaturedOnPageLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeaturedOnPageLink.
     * @param {FeaturedOnPageLinkCreateArgs} args - Arguments to create a FeaturedOnPageLink.
     * @example
     * // Create one FeaturedOnPageLink
     * const FeaturedOnPageLink = await prisma.featuredOnPageLink.create({
     *   data: {
     *     // ... data to create a FeaturedOnPageLink
     *   }
     * })
     * 
     */
    create<T extends FeaturedOnPageLinkCreateArgs>(args: SelectSubset<T, FeaturedOnPageLinkCreateArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeaturedOnPageLinks.
     * @param {FeaturedOnPageLinkCreateManyArgs} args - Arguments to create many FeaturedOnPageLinks.
     * @example
     * // Create many FeaturedOnPageLinks
     * const featuredOnPageLink = await prisma.featuredOnPageLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedOnPageLinkCreateManyArgs>(args?: SelectSubset<T, FeaturedOnPageLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedOnPageLinks and returns the data saved in the database.
     * @param {FeaturedOnPageLinkCreateManyAndReturnArgs} args - Arguments to create many FeaturedOnPageLinks.
     * @example
     * // Create many FeaturedOnPageLinks
     * const featuredOnPageLink = await prisma.featuredOnPageLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedOnPageLinks and only return the `id`
     * const featuredOnPageLinkWithIdOnly = await prisma.featuredOnPageLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedOnPageLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedOnPageLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeaturedOnPageLink.
     * @param {FeaturedOnPageLinkDeleteArgs} args - Arguments to delete one FeaturedOnPageLink.
     * @example
     * // Delete one FeaturedOnPageLink
     * const FeaturedOnPageLink = await prisma.featuredOnPageLink.delete({
     *   where: {
     *     // ... filter to delete one FeaturedOnPageLink
     *   }
     * })
     * 
     */
    delete<T extends FeaturedOnPageLinkDeleteArgs>(args: SelectSubset<T, FeaturedOnPageLinkDeleteArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeaturedOnPageLink.
     * @param {FeaturedOnPageLinkUpdateArgs} args - Arguments to update one FeaturedOnPageLink.
     * @example
     * // Update one FeaturedOnPageLink
     * const featuredOnPageLink = await prisma.featuredOnPageLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedOnPageLinkUpdateArgs>(args: SelectSubset<T, FeaturedOnPageLinkUpdateArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeaturedOnPageLinks.
     * @param {FeaturedOnPageLinkDeleteManyArgs} args - Arguments to filter FeaturedOnPageLinks to delete.
     * @example
     * // Delete a few FeaturedOnPageLinks
     * const { count } = await prisma.featuredOnPageLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedOnPageLinkDeleteManyArgs>(args?: SelectSubset<T, FeaturedOnPageLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedOnPageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnPageLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedOnPageLinks
     * const featuredOnPageLink = await prisma.featuredOnPageLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedOnPageLinkUpdateManyArgs>(args: SelectSubset<T, FeaturedOnPageLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeaturedOnPageLink.
     * @param {FeaturedOnPageLinkUpsertArgs} args - Arguments to update or create a FeaturedOnPageLink.
     * @example
     * // Update or create a FeaturedOnPageLink
     * const featuredOnPageLink = await prisma.featuredOnPageLink.upsert({
     *   create: {
     *     // ... data to create a FeaturedOnPageLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedOnPageLink we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedOnPageLinkUpsertArgs>(args: SelectSubset<T, FeaturedOnPageLinkUpsertArgs<ExtArgs>>): Prisma__FeaturedOnPageLinkClient<$Result.GetResult<Prisma.$FeaturedOnPageLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeaturedOnPageLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnPageLinkCountArgs} args - Arguments to filter FeaturedOnPageLinks to count.
     * @example
     * // Count the number of FeaturedOnPageLinks
     * const count = await prisma.featuredOnPageLink.count({
     *   where: {
     *     // ... the filter for the FeaturedOnPageLinks we want to count
     *   }
     * })
    **/
    count<T extends FeaturedOnPageLinkCountArgs>(
      args?: Subset<T, FeaturedOnPageLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedOnPageLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedOnPageLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnPageLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedOnPageLinkAggregateArgs>(args: Subset<T, FeaturedOnPageLinkAggregateArgs>): Prisma.PrismaPromise<GetFeaturedOnPageLinkAggregateType<T>>

    /**
     * Group by FeaturedOnPageLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedOnPageLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedOnPageLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedOnPageLinkGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedOnPageLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedOnPageLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedOnPageLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedOnPageLink model
   */
  readonly fields: FeaturedOnPageLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedOnPageLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedOnPageLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    featuredOn<T extends FeaturedOnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedOnDefaultArgs<ExtArgs>>): Prisma__FeaturedOnClient<$Result.GetResult<Prisma.$FeaturedOnPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedOnPageLink model
   */ 
  interface FeaturedOnPageLinkFieldRefs {
    readonly id: FieldRef<"FeaturedOnPageLink", 'Int'>
    readonly featuredOnId: FieldRef<"FeaturedOnPageLink", 'Int'>
    readonly pagePath: FieldRef<"FeaturedOnPageLink", 'String'>
    readonly link: FieldRef<"FeaturedOnPageLink", 'String'>
    readonly nofollow: FieldRef<"FeaturedOnPageLink", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedOnPageLink findUnique
   */
  export type FeaturedOnPageLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOnPageLink to fetch.
     */
    where: FeaturedOnPageLinkWhereUniqueInput
  }

  /**
   * FeaturedOnPageLink findUniqueOrThrow
   */
  export type FeaturedOnPageLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOnPageLink to fetch.
     */
    where: FeaturedOnPageLinkWhereUniqueInput
  }

  /**
   * FeaturedOnPageLink findFirst
   */
  export type FeaturedOnPageLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOnPageLink to fetch.
     */
    where?: FeaturedOnPageLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOnPageLinks to fetch.
     */
    orderBy?: FeaturedOnPageLinkOrderByWithRelationInput | FeaturedOnPageLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedOnPageLinks.
     */
    cursor?: FeaturedOnPageLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOnPageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOnPageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedOnPageLinks.
     */
    distinct?: FeaturedOnPageLinkScalarFieldEnum | FeaturedOnPageLinkScalarFieldEnum[]
  }

  /**
   * FeaturedOnPageLink findFirstOrThrow
   */
  export type FeaturedOnPageLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOnPageLink to fetch.
     */
    where?: FeaturedOnPageLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOnPageLinks to fetch.
     */
    orderBy?: FeaturedOnPageLinkOrderByWithRelationInput | FeaturedOnPageLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedOnPageLinks.
     */
    cursor?: FeaturedOnPageLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOnPageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOnPageLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedOnPageLinks.
     */
    distinct?: FeaturedOnPageLinkScalarFieldEnum | FeaturedOnPageLinkScalarFieldEnum[]
  }

  /**
   * FeaturedOnPageLink findMany
   */
  export type FeaturedOnPageLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedOnPageLinks to fetch.
     */
    where?: FeaturedOnPageLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedOnPageLinks to fetch.
     */
    orderBy?: FeaturedOnPageLinkOrderByWithRelationInput | FeaturedOnPageLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedOnPageLinks.
     */
    cursor?: FeaturedOnPageLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedOnPageLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedOnPageLinks.
     */
    skip?: number
    distinct?: FeaturedOnPageLinkScalarFieldEnum | FeaturedOnPageLinkScalarFieldEnum[]
  }

  /**
   * FeaturedOnPageLink create
   */
  export type FeaturedOnPageLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedOnPageLink.
     */
    data: XOR<FeaturedOnPageLinkCreateInput, FeaturedOnPageLinkUncheckedCreateInput>
  }

  /**
   * FeaturedOnPageLink createMany
   */
  export type FeaturedOnPageLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedOnPageLinks.
     */
    data: FeaturedOnPageLinkCreateManyInput | FeaturedOnPageLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedOnPageLink createManyAndReturn
   */
  export type FeaturedOnPageLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeaturedOnPageLinks.
     */
    data: FeaturedOnPageLinkCreateManyInput | FeaturedOnPageLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedOnPageLink update
   */
  export type FeaturedOnPageLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedOnPageLink.
     */
    data: XOR<FeaturedOnPageLinkUpdateInput, FeaturedOnPageLinkUncheckedUpdateInput>
    /**
     * Choose, which FeaturedOnPageLink to update.
     */
    where: FeaturedOnPageLinkWhereUniqueInput
  }

  /**
   * FeaturedOnPageLink updateMany
   */
  export type FeaturedOnPageLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedOnPageLinks.
     */
    data: XOR<FeaturedOnPageLinkUpdateManyMutationInput, FeaturedOnPageLinkUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedOnPageLinks to update
     */
    where?: FeaturedOnPageLinkWhereInput
  }

  /**
   * FeaturedOnPageLink upsert
   */
  export type FeaturedOnPageLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedOnPageLink to update in case it exists.
     */
    where: FeaturedOnPageLinkWhereUniqueInput
    /**
     * In case the FeaturedOnPageLink found by the `where` argument doesn't exist, create a new FeaturedOnPageLink with this data.
     */
    create: XOR<FeaturedOnPageLinkCreateInput, FeaturedOnPageLinkUncheckedCreateInput>
    /**
     * In case the FeaturedOnPageLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedOnPageLinkUpdateInput, FeaturedOnPageLinkUncheckedUpdateInput>
  }

  /**
   * FeaturedOnPageLink delete
   */
  export type FeaturedOnPageLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
    /**
     * Filter which FeaturedOnPageLink to delete.
     */
    where: FeaturedOnPageLinkWhereUniqueInput
  }

  /**
   * FeaturedOnPageLink deleteMany
   */
  export type FeaturedOnPageLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedOnPageLinks to delete
     */
    where?: FeaturedOnPageLinkWhereInput
  }

  /**
   * FeaturedOnPageLink without action
   */
  export type FeaturedOnPageLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedOnPageLink
     */
    select?: FeaturedOnPageLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedOnPageLinkInclude<ExtArgs> | null
  }


  /**
   * Model PlatformSection
   */

  export type AggregatePlatformSection = {
    _count: PlatformSectionCountAggregateOutputType | null
    _avg: PlatformSectionAvgAggregateOutputType | null
    _sum: PlatformSectionSumAggregateOutputType | null
    _min: PlatformSectionMinAggregateOutputType | null
    _max: PlatformSectionMaxAggregateOutputType | null
  }

  export type PlatformSectionAvgAggregateOutputType = {
    id: number | null
  }

  export type PlatformSectionSumAggregateOutputType = {
    id: number | null
  }

  export type PlatformSectionMinAggregateOutputType = {
    id: number | null
    platform: $Enums.Platform | null
    title: string | null
    description: string | null
    ctaText: string | null
    isActive: boolean | null
  }

  export type PlatformSectionMaxAggregateOutputType = {
    id: number | null
    platform: $Enums.Platform | null
    title: string | null
    description: string | null
    ctaText: string | null
    isActive: boolean | null
  }

  export type PlatformSectionCountAggregateOutputType = {
    id: number
    platform: number
    title: number
    description: number
    tags: number
    ctaText: number
    isActive: number
    _all: number
  }


  export type PlatformSectionAvgAggregateInputType = {
    id?: true
  }

  export type PlatformSectionSumAggregateInputType = {
    id?: true
  }

  export type PlatformSectionMinAggregateInputType = {
    id?: true
    platform?: true
    title?: true
    description?: true
    ctaText?: true
    isActive?: true
  }

  export type PlatformSectionMaxAggregateInputType = {
    id?: true
    platform?: true
    title?: true
    description?: true
    ctaText?: true
    isActive?: true
  }

  export type PlatformSectionCountAggregateInputType = {
    id?: true
    platform?: true
    title?: true
    description?: true
    tags?: true
    ctaText?: true
    isActive?: true
    _all?: true
  }

  export type PlatformSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSection to aggregate.
     */
    where?: PlatformSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSections to fetch.
     */
    orderBy?: PlatformSectionOrderByWithRelationInput | PlatformSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformSections
    **/
    _count?: true | PlatformSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformSectionMaxAggregateInputType
  }

  export type GetPlatformSectionAggregateType<T extends PlatformSectionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformSection[P]>
      : GetScalarType<T[P], AggregatePlatformSection[P]>
  }




  export type PlatformSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformSectionWhereInput
    orderBy?: PlatformSectionOrderByWithAggregationInput | PlatformSectionOrderByWithAggregationInput[]
    by: PlatformSectionScalarFieldEnum[] | PlatformSectionScalarFieldEnum
    having?: PlatformSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformSectionCountAggregateInputType | true
    _avg?: PlatformSectionAvgAggregateInputType
    _sum?: PlatformSectionSumAggregateInputType
    _min?: PlatformSectionMinAggregateInputType
    _max?: PlatformSectionMaxAggregateInputType
  }

  export type PlatformSectionGroupByOutputType = {
    id: number
    platform: $Enums.Platform
    title: string
    description: string
    tags: JsonValue
    ctaText: string
    isActive: boolean
    _count: PlatformSectionCountAggregateOutputType | null
    _avg: PlatformSectionAvgAggregateOutputType | null
    _sum: PlatformSectionSumAggregateOutputType | null
    _min: PlatformSectionMinAggregateOutputType | null
    _max: PlatformSectionMaxAggregateOutputType | null
  }

  type GetPlatformSectionGroupByPayload<T extends PlatformSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformSectionGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformSectionGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    ctaText?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["platformSection"]>

  export type PlatformSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    ctaText?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["platformSection"]>

  export type PlatformSectionSelectScalar = {
    id?: boolean
    platform?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    ctaText?: boolean
    isActive?: boolean
  }


  export type $PlatformSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformSection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      platform: $Enums.Platform
      title: string
      description: string
      tags: Prisma.JsonValue
      ctaText: string
      isActive: boolean
    }, ExtArgs["result"]["platformSection"]>
    composites: {}
  }

  type PlatformSectionGetPayload<S extends boolean | null | undefined | PlatformSectionDefaultArgs> = $Result.GetResult<Prisma.$PlatformSectionPayload, S>

  type PlatformSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlatformSectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlatformSectionCountAggregateInputType | true
    }

  export interface PlatformSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformSection'], meta: { name: 'PlatformSection' } }
    /**
     * Find zero or one PlatformSection that matches the filter.
     * @param {PlatformSectionFindUniqueArgs} args - Arguments to find a PlatformSection
     * @example
     * // Get one PlatformSection
     * const platformSection = await prisma.platformSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformSectionFindUniqueArgs>(args: SelectSubset<T, PlatformSectionFindUniqueArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlatformSection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlatformSectionFindUniqueOrThrowArgs} args - Arguments to find a PlatformSection
     * @example
     * // Get one PlatformSection
     * const platformSection = await prisma.platformSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlatformSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSectionFindFirstArgs} args - Arguments to find a PlatformSection
     * @example
     * // Get one PlatformSection
     * const platformSection = await prisma.platformSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformSectionFindFirstArgs>(args?: SelectSubset<T, PlatformSectionFindFirstArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlatformSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSectionFindFirstOrThrowArgs} args - Arguments to find a PlatformSection
     * @example
     * // Get one PlatformSection
     * const platformSection = await prisma.platformSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlatformSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformSections
     * const platformSections = await prisma.platformSection.findMany()
     * 
     * // Get first 10 PlatformSections
     * const platformSections = await prisma.platformSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformSectionWithIdOnly = await prisma.platformSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformSectionFindManyArgs>(args?: SelectSubset<T, PlatformSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlatformSection.
     * @param {PlatformSectionCreateArgs} args - Arguments to create a PlatformSection.
     * @example
     * // Create one PlatformSection
     * const PlatformSection = await prisma.platformSection.create({
     *   data: {
     *     // ... data to create a PlatformSection
     *   }
     * })
     * 
     */
    create<T extends PlatformSectionCreateArgs>(args: SelectSubset<T, PlatformSectionCreateArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlatformSections.
     * @param {PlatformSectionCreateManyArgs} args - Arguments to create many PlatformSections.
     * @example
     * // Create many PlatformSections
     * const platformSection = await prisma.platformSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformSectionCreateManyArgs>(args?: SelectSubset<T, PlatformSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformSections and returns the data saved in the database.
     * @param {PlatformSectionCreateManyAndReturnArgs} args - Arguments to create many PlatformSections.
     * @example
     * // Create many PlatformSections
     * const platformSection = await prisma.platformSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformSections and only return the `id`
     * const platformSectionWithIdOnly = await prisma.platformSection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlatformSection.
     * @param {PlatformSectionDeleteArgs} args - Arguments to delete one PlatformSection.
     * @example
     * // Delete one PlatformSection
     * const PlatformSection = await prisma.platformSection.delete({
     *   where: {
     *     // ... filter to delete one PlatformSection
     *   }
     * })
     * 
     */
    delete<T extends PlatformSectionDeleteArgs>(args: SelectSubset<T, PlatformSectionDeleteArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlatformSection.
     * @param {PlatformSectionUpdateArgs} args - Arguments to update one PlatformSection.
     * @example
     * // Update one PlatformSection
     * const platformSection = await prisma.platformSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformSectionUpdateArgs>(args: SelectSubset<T, PlatformSectionUpdateArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlatformSections.
     * @param {PlatformSectionDeleteManyArgs} args - Arguments to filter PlatformSections to delete.
     * @example
     * // Delete a few PlatformSections
     * const { count } = await prisma.platformSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformSectionDeleteManyArgs>(args?: SelectSubset<T, PlatformSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformSections
     * const platformSection = await prisma.platformSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformSectionUpdateManyArgs>(args: SelectSubset<T, PlatformSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlatformSection.
     * @param {PlatformSectionUpsertArgs} args - Arguments to update or create a PlatformSection.
     * @example
     * // Update or create a PlatformSection
     * const platformSection = await prisma.platformSection.upsert({
     *   create: {
     *     // ... data to create a PlatformSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformSection we want to update
     *   }
     * })
     */
    upsert<T extends PlatformSectionUpsertArgs>(args: SelectSubset<T, PlatformSectionUpsertArgs<ExtArgs>>): Prisma__PlatformSectionClient<$Result.GetResult<Prisma.$PlatformSectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlatformSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSectionCountArgs} args - Arguments to filter PlatformSections to count.
     * @example
     * // Count the number of PlatformSections
     * const count = await prisma.platformSection.count({
     *   where: {
     *     // ... the filter for the PlatformSections we want to count
     *   }
     * })
    **/
    count<T extends PlatformSectionCountArgs>(
      args?: Subset<T, PlatformSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformSectionAggregateArgs>(args: Subset<T, PlatformSectionAggregateArgs>): Prisma.PrismaPromise<GetPlatformSectionAggregateType<T>>

    /**
     * Group by PlatformSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformSectionGroupByArgs['orderBy'] }
        : { orderBy?: PlatformSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformSection model
   */
  readonly fields: PlatformSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformSection model
   */ 
  interface PlatformSectionFieldRefs {
    readonly id: FieldRef<"PlatformSection", 'Int'>
    readonly platform: FieldRef<"PlatformSection", 'Platform'>
    readonly title: FieldRef<"PlatformSection", 'String'>
    readonly description: FieldRef<"PlatformSection", 'String'>
    readonly tags: FieldRef<"PlatformSection", 'Json'>
    readonly ctaText: FieldRef<"PlatformSection", 'String'>
    readonly isActive: FieldRef<"PlatformSection", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PlatformSection findUnique
   */
  export type PlatformSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSection to fetch.
     */
    where: PlatformSectionWhereUniqueInput
  }

  /**
   * PlatformSection findUniqueOrThrow
   */
  export type PlatformSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSection to fetch.
     */
    where: PlatformSectionWhereUniqueInput
  }

  /**
   * PlatformSection findFirst
   */
  export type PlatformSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSection to fetch.
     */
    where?: PlatformSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSections to fetch.
     */
    orderBy?: PlatformSectionOrderByWithRelationInput | PlatformSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSections.
     */
    cursor?: PlatformSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSections.
     */
    distinct?: PlatformSectionScalarFieldEnum | PlatformSectionScalarFieldEnum[]
  }

  /**
   * PlatformSection findFirstOrThrow
   */
  export type PlatformSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSection to fetch.
     */
    where?: PlatformSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSections to fetch.
     */
    orderBy?: PlatformSectionOrderByWithRelationInput | PlatformSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSections.
     */
    cursor?: PlatformSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSections.
     */
    distinct?: PlatformSectionScalarFieldEnum | PlatformSectionScalarFieldEnum[]
  }

  /**
   * PlatformSection findMany
   */
  export type PlatformSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * Filter, which PlatformSections to fetch.
     */
    where?: PlatformSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSections to fetch.
     */
    orderBy?: PlatformSectionOrderByWithRelationInput | PlatformSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformSections.
     */
    cursor?: PlatformSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSections.
     */
    skip?: number
    distinct?: PlatformSectionScalarFieldEnum | PlatformSectionScalarFieldEnum[]
  }

  /**
   * PlatformSection create
   */
  export type PlatformSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * The data needed to create a PlatformSection.
     */
    data: XOR<PlatformSectionCreateInput, PlatformSectionUncheckedCreateInput>
  }

  /**
   * PlatformSection createMany
   */
  export type PlatformSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformSections.
     */
    data: PlatformSectionCreateManyInput | PlatformSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformSection createManyAndReturn
   */
  export type PlatformSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlatformSections.
     */
    data: PlatformSectionCreateManyInput | PlatformSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformSection update
   */
  export type PlatformSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * The data needed to update a PlatformSection.
     */
    data: XOR<PlatformSectionUpdateInput, PlatformSectionUncheckedUpdateInput>
    /**
     * Choose, which PlatformSection to update.
     */
    where: PlatformSectionWhereUniqueInput
  }

  /**
   * PlatformSection updateMany
   */
  export type PlatformSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformSections.
     */
    data: XOR<PlatformSectionUpdateManyMutationInput, PlatformSectionUncheckedUpdateManyInput>
    /**
     * Filter which PlatformSections to update
     */
    where?: PlatformSectionWhereInput
  }

  /**
   * PlatformSection upsert
   */
  export type PlatformSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * The filter to search for the PlatformSection to update in case it exists.
     */
    where: PlatformSectionWhereUniqueInput
    /**
     * In case the PlatformSection found by the `where` argument doesn't exist, create a new PlatformSection with this data.
     */
    create: XOR<PlatformSectionCreateInput, PlatformSectionUncheckedCreateInput>
    /**
     * In case the PlatformSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformSectionUpdateInput, PlatformSectionUncheckedUpdateInput>
  }

  /**
   * PlatformSection delete
   */
  export type PlatformSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
    /**
     * Filter which PlatformSection to delete.
     */
    where: PlatformSectionWhereUniqueInput
  }

  /**
   * PlatformSection deleteMany
   */
  export type PlatformSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSections to delete
     */
    where?: PlatformSectionWhereInput
  }

  /**
   * PlatformSection without action
   */
  export type PlatformSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSection
     */
    select?: PlatformSectionSelect<ExtArgs> | null
  }


  /**
   * Model GetStartedContent
   */

  export type AggregateGetStartedContent = {
    _count: GetStartedContentCountAggregateOutputType | null
    _avg: GetStartedContentAvgAggregateOutputType | null
    _sum: GetStartedContentSumAggregateOutputType | null
    _min: GetStartedContentMinAggregateOutputType | null
    _max: GetStartedContentMaxAggregateOutputType | null
  }

  export type GetStartedContentAvgAggregateOutputType = {
    id: number | null
  }

  export type GetStartedContentSumAggregateOutputType = {
    id: number | null
  }

  export type GetStartedContentMinAggregateOutputType = {
    id: number | null
    platform: $Enums.Platform | null
    packType: $Enums.ServiceType | null
    quality: string | null
    explanation: string | null
    isActive: boolean | null
  }

  export type GetStartedContentMaxAggregateOutputType = {
    id: number | null
    platform: $Enums.Platform | null
    packType: $Enums.ServiceType | null
    quality: string | null
    explanation: string | null
    isActive: boolean | null
  }

  export type GetStartedContentCountAggregateOutputType = {
    id: number
    platform: number
    packType: number
    quality: number
    features: number
    explanation: number
    pricing: number
    isActive: number
    _all: number
  }


  export type GetStartedContentAvgAggregateInputType = {
    id?: true
  }

  export type GetStartedContentSumAggregateInputType = {
    id?: true
  }

  export type GetStartedContentMinAggregateInputType = {
    id?: true
    platform?: true
    packType?: true
    quality?: true
    explanation?: true
    isActive?: true
  }

  export type GetStartedContentMaxAggregateInputType = {
    id?: true
    platform?: true
    packType?: true
    quality?: true
    explanation?: true
    isActive?: true
  }

  export type GetStartedContentCountAggregateInputType = {
    id?: true
    platform?: true
    packType?: true
    quality?: true
    features?: true
    explanation?: true
    pricing?: true
    isActive?: true
    _all?: true
  }

  export type GetStartedContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GetStartedContent to aggregate.
     */
    where?: GetStartedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetStartedContents to fetch.
     */
    orderBy?: GetStartedContentOrderByWithRelationInput | GetStartedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GetStartedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetStartedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetStartedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GetStartedContents
    **/
    _count?: true | GetStartedContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GetStartedContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GetStartedContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GetStartedContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GetStartedContentMaxAggregateInputType
  }

  export type GetGetStartedContentAggregateType<T extends GetStartedContentAggregateArgs> = {
        [P in keyof T & keyof AggregateGetStartedContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGetStartedContent[P]>
      : GetScalarType<T[P], AggregateGetStartedContent[P]>
  }




  export type GetStartedContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GetStartedContentWhereInput
    orderBy?: GetStartedContentOrderByWithAggregationInput | GetStartedContentOrderByWithAggregationInput[]
    by: GetStartedContentScalarFieldEnum[] | GetStartedContentScalarFieldEnum
    having?: GetStartedContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GetStartedContentCountAggregateInputType | true
    _avg?: GetStartedContentAvgAggregateInputType
    _sum?: GetStartedContentSumAggregateInputType
    _min?: GetStartedContentMinAggregateInputType
    _max?: GetStartedContentMaxAggregateInputType
  }

  export type GetStartedContentGroupByOutputType = {
    id: number
    platform: $Enums.Platform
    packType: $Enums.ServiceType
    quality: string
    features: JsonValue
    explanation: string | null
    pricing: JsonValue | null
    isActive: boolean
    _count: GetStartedContentCountAggregateOutputType | null
    _avg: GetStartedContentAvgAggregateOutputType | null
    _sum: GetStartedContentSumAggregateOutputType | null
    _min: GetStartedContentMinAggregateOutputType | null
    _max: GetStartedContentMaxAggregateOutputType | null
  }

  type GetGetStartedContentGroupByPayload<T extends GetStartedContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GetStartedContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GetStartedContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GetStartedContentGroupByOutputType[P]>
            : GetScalarType<T[P], GetStartedContentGroupByOutputType[P]>
        }
      >
    >


  export type GetStartedContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    packType?: boolean
    quality?: boolean
    features?: boolean
    explanation?: boolean
    pricing?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["getStartedContent"]>

  export type GetStartedContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    packType?: boolean
    quality?: boolean
    features?: boolean
    explanation?: boolean
    pricing?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["getStartedContent"]>

  export type GetStartedContentSelectScalar = {
    id?: boolean
    platform?: boolean
    packType?: boolean
    quality?: boolean
    features?: boolean
    explanation?: boolean
    pricing?: boolean
    isActive?: boolean
  }


  export type $GetStartedContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GetStartedContent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      platform: $Enums.Platform
      packType: $Enums.ServiceType
      quality: string
      features: Prisma.JsonValue
      explanation: string | null
      pricing: Prisma.JsonValue | null
      isActive: boolean
    }, ExtArgs["result"]["getStartedContent"]>
    composites: {}
  }

  type GetStartedContentGetPayload<S extends boolean | null | undefined | GetStartedContentDefaultArgs> = $Result.GetResult<Prisma.$GetStartedContentPayload, S>

  type GetStartedContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GetStartedContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GetStartedContentCountAggregateInputType | true
    }

  export interface GetStartedContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GetStartedContent'], meta: { name: 'GetStartedContent' } }
    /**
     * Find zero or one GetStartedContent that matches the filter.
     * @param {GetStartedContentFindUniqueArgs} args - Arguments to find a GetStartedContent
     * @example
     * // Get one GetStartedContent
     * const getStartedContent = await prisma.getStartedContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GetStartedContentFindUniqueArgs>(args: SelectSubset<T, GetStartedContentFindUniqueArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GetStartedContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GetStartedContentFindUniqueOrThrowArgs} args - Arguments to find a GetStartedContent
     * @example
     * // Get one GetStartedContent
     * const getStartedContent = await prisma.getStartedContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GetStartedContentFindUniqueOrThrowArgs>(args: SelectSubset<T, GetStartedContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GetStartedContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetStartedContentFindFirstArgs} args - Arguments to find a GetStartedContent
     * @example
     * // Get one GetStartedContent
     * const getStartedContent = await prisma.getStartedContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GetStartedContentFindFirstArgs>(args?: SelectSubset<T, GetStartedContentFindFirstArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GetStartedContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetStartedContentFindFirstOrThrowArgs} args - Arguments to find a GetStartedContent
     * @example
     * // Get one GetStartedContent
     * const getStartedContent = await prisma.getStartedContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GetStartedContentFindFirstOrThrowArgs>(args?: SelectSubset<T, GetStartedContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GetStartedContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetStartedContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GetStartedContents
     * const getStartedContents = await prisma.getStartedContent.findMany()
     * 
     * // Get first 10 GetStartedContents
     * const getStartedContents = await prisma.getStartedContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const getStartedContentWithIdOnly = await prisma.getStartedContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GetStartedContentFindManyArgs>(args?: SelectSubset<T, GetStartedContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GetStartedContent.
     * @param {GetStartedContentCreateArgs} args - Arguments to create a GetStartedContent.
     * @example
     * // Create one GetStartedContent
     * const GetStartedContent = await prisma.getStartedContent.create({
     *   data: {
     *     // ... data to create a GetStartedContent
     *   }
     * })
     * 
     */
    create<T extends GetStartedContentCreateArgs>(args: SelectSubset<T, GetStartedContentCreateArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GetStartedContents.
     * @param {GetStartedContentCreateManyArgs} args - Arguments to create many GetStartedContents.
     * @example
     * // Create many GetStartedContents
     * const getStartedContent = await prisma.getStartedContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GetStartedContentCreateManyArgs>(args?: SelectSubset<T, GetStartedContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GetStartedContents and returns the data saved in the database.
     * @param {GetStartedContentCreateManyAndReturnArgs} args - Arguments to create many GetStartedContents.
     * @example
     * // Create many GetStartedContents
     * const getStartedContent = await prisma.getStartedContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GetStartedContents and only return the `id`
     * const getStartedContentWithIdOnly = await prisma.getStartedContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GetStartedContentCreateManyAndReturnArgs>(args?: SelectSubset<T, GetStartedContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GetStartedContent.
     * @param {GetStartedContentDeleteArgs} args - Arguments to delete one GetStartedContent.
     * @example
     * // Delete one GetStartedContent
     * const GetStartedContent = await prisma.getStartedContent.delete({
     *   where: {
     *     // ... filter to delete one GetStartedContent
     *   }
     * })
     * 
     */
    delete<T extends GetStartedContentDeleteArgs>(args: SelectSubset<T, GetStartedContentDeleteArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GetStartedContent.
     * @param {GetStartedContentUpdateArgs} args - Arguments to update one GetStartedContent.
     * @example
     * // Update one GetStartedContent
     * const getStartedContent = await prisma.getStartedContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GetStartedContentUpdateArgs>(args: SelectSubset<T, GetStartedContentUpdateArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GetStartedContents.
     * @param {GetStartedContentDeleteManyArgs} args - Arguments to filter GetStartedContents to delete.
     * @example
     * // Delete a few GetStartedContents
     * const { count } = await prisma.getStartedContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GetStartedContentDeleteManyArgs>(args?: SelectSubset<T, GetStartedContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GetStartedContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetStartedContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GetStartedContents
     * const getStartedContent = await prisma.getStartedContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GetStartedContentUpdateManyArgs>(args: SelectSubset<T, GetStartedContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GetStartedContent.
     * @param {GetStartedContentUpsertArgs} args - Arguments to update or create a GetStartedContent.
     * @example
     * // Update or create a GetStartedContent
     * const getStartedContent = await prisma.getStartedContent.upsert({
     *   create: {
     *     // ... data to create a GetStartedContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GetStartedContent we want to update
     *   }
     * })
     */
    upsert<T extends GetStartedContentUpsertArgs>(args: SelectSubset<T, GetStartedContentUpsertArgs<ExtArgs>>): Prisma__GetStartedContentClient<$Result.GetResult<Prisma.$GetStartedContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GetStartedContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetStartedContentCountArgs} args - Arguments to filter GetStartedContents to count.
     * @example
     * // Count the number of GetStartedContents
     * const count = await prisma.getStartedContent.count({
     *   where: {
     *     // ... the filter for the GetStartedContents we want to count
     *   }
     * })
    **/
    count<T extends GetStartedContentCountArgs>(
      args?: Subset<T, GetStartedContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GetStartedContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GetStartedContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetStartedContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GetStartedContentAggregateArgs>(args: Subset<T, GetStartedContentAggregateArgs>): Prisma.PrismaPromise<GetGetStartedContentAggregateType<T>>

    /**
     * Group by GetStartedContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetStartedContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GetStartedContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GetStartedContentGroupByArgs['orderBy'] }
        : { orderBy?: GetStartedContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GetStartedContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGetStartedContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GetStartedContent model
   */
  readonly fields: GetStartedContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GetStartedContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GetStartedContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GetStartedContent model
   */ 
  interface GetStartedContentFieldRefs {
    readonly id: FieldRef<"GetStartedContent", 'Int'>
    readonly platform: FieldRef<"GetStartedContent", 'Platform'>
    readonly packType: FieldRef<"GetStartedContent", 'ServiceType'>
    readonly quality: FieldRef<"GetStartedContent", 'String'>
    readonly features: FieldRef<"GetStartedContent", 'Json'>
    readonly explanation: FieldRef<"GetStartedContent", 'String'>
    readonly pricing: FieldRef<"GetStartedContent", 'Json'>
    readonly isActive: FieldRef<"GetStartedContent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * GetStartedContent findUnique
   */
  export type GetStartedContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * Filter, which GetStartedContent to fetch.
     */
    where: GetStartedContentWhereUniqueInput
  }

  /**
   * GetStartedContent findUniqueOrThrow
   */
  export type GetStartedContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * Filter, which GetStartedContent to fetch.
     */
    where: GetStartedContentWhereUniqueInput
  }

  /**
   * GetStartedContent findFirst
   */
  export type GetStartedContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * Filter, which GetStartedContent to fetch.
     */
    where?: GetStartedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetStartedContents to fetch.
     */
    orderBy?: GetStartedContentOrderByWithRelationInput | GetStartedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GetStartedContents.
     */
    cursor?: GetStartedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetStartedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetStartedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GetStartedContents.
     */
    distinct?: GetStartedContentScalarFieldEnum | GetStartedContentScalarFieldEnum[]
  }

  /**
   * GetStartedContent findFirstOrThrow
   */
  export type GetStartedContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * Filter, which GetStartedContent to fetch.
     */
    where?: GetStartedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetStartedContents to fetch.
     */
    orderBy?: GetStartedContentOrderByWithRelationInput | GetStartedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GetStartedContents.
     */
    cursor?: GetStartedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetStartedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetStartedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GetStartedContents.
     */
    distinct?: GetStartedContentScalarFieldEnum | GetStartedContentScalarFieldEnum[]
  }

  /**
   * GetStartedContent findMany
   */
  export type GetStartedContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * Filter, which GetStartedContents to fetch.
     */
    where?: GetStartedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetStartedContents to fetch.
     */
    orderBy?: GetStartedContentOrderByWithRelationInput | GetStartedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GetStartedContents.
     */
    cursor?: GetStartedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetStartedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetStartedContents.
     */
    skip?: number
    distinct?: GetStartedContentScalarFieldEnum | GetStartedContentScalarFieldEnum[]
  }

  /**
   * GetStartedContent create
   */
  export type GetStartedContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * The data needed to create a GetStartedContent.
     */
    data: XOR<GetStartedContentCreateInput, GetStartedContentUncheckedCreateInput>
  }

  /**
   * GetStartedContent createMany
   */
  export type GetStartedContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GetStartedContents.
     */
    data: GetStartedContentCreateManyInput | GetStartedContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GetStartedContent createManyAndReturn
   */
  export type GetStartedContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GetStartedContents.
     */
    data: GetStartedContentCreateManyInput | GetStartedContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GetStartedContent update
   */
  export type GetStartedContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * The data needed to update a GetStartedContent.
     */
    data: XOR<GetStartedContentUpdateInput, GetStartedContentUncheckedUpdateInput>
    /**
     * Choose, which GetStartedContent to update.
     */
    where: GetStartedContentWhereUniqueInput
  }

  /**
   * GetStartedContent updateMany
   */
  export type GetStartedContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GetStartedContents.
     */
    data: XOR<GetStartedContentUpdateManyMutationInput, GetStartedContentUncheckedUpdateManyInput>
    /**
     * Filter which GetStartedContents to update
     */
    where?: GetStartedContentWhereInput
  }

  /**
   * GetStartedContent upsert
   */
  export type GetStartedContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * The filter to search for the GetStartedContent to update in case it exists.
     */
    where: GetStartedContentWhereUniqueInput
    /**
     * In case the GetStartedContent found by the `where` argument doesn't exist, create a new GetStartedContent with this data.
     */
    create: XOR<GetStartedContentCreateInput, GetStartedContentUncheckedCreateInput>
    /**
     * In case the GetStartedContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GetStartedContentUpdateInput, GetStartedContentUncheckedUpdateInput>
  }

  /**
   * GetStartedContent delete
   */
  export type GetStartedContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
    /**
     * Filter which GetStartedContent to delete.
     */
    where: GetStartedContentWhereUniqueInput
  }

  /**
   * GetStartedContent deleteMany
   */
  export type GetStartedContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GetStartedContents to delete
     */
    where?: GetStartedContentWhereInput
  }

  /**
   * GetStartedContent without action
   */
  export type GetStartedContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetStartedContent
     */
    select?: GetStartedContentSelect<ExtArgs> | null
  }


  /**
   * Model InfluenceSection
   */

  export type AggregateInfluenceSection = {
    _count: InfluenceSectionCountAggregateOutputType | null
    _avg: InfluenceSectionAvgAggregateOutputType | null
    _sum: InfluenceSectionSumAggregateOutputType | null
    _min: InfluenceSectionMinAggregateOutputType | null
    _max: InfluenceSectionMaxAggregateOutputType | null
  }

  export type InfluenceSectionAvgAggregateOutputType = {
    id: number | null
  }

  export type InfluenceSectionSumAggregateOutputType = {
    id: number | null
  }

  export type InfluenceSectionMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
  }

  export type InfluenceSectionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
  }

  export type InfluenceSectionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    steps: number
    isActive: number
    _all: number
  }


  export type InfluenceSectionAvgAggregateInputType = {
    id?: true
  }

  export type InfluenceSectionSumAggregateInputType = {
    id?: true
  }

  export type InfluenceSectionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isActive?: true
  }

  export type InfluenceSectionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isActive?: true
  }

  export type InfluenceSectionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    steps?: true
    isActive?: true
    _all?: true
  }

  export type InfluenceSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfluenceSection to aggregate.
     */
    where?: InfluenceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluenceSections to fetch.
     */
    orderBy?: InfluenceSectionOrderByWithRelationInput | InfluenceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfluenceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluenceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluenceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InfluenceSections
    **/
    _count?: true | InfluenceSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfluenceSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfluenceSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfluenceSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfluenceSectionMaxAggregateInputType
  }

  export type GetInfluenceSectionAggregateType<T extends InfluenceSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateInfluenceSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfluenceSection[P]>
      : GetScalarType<T[P], AggregateInfluenceSection[P]>
  }




  export type InfluenceSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluenceSectionWhereInput
    orderBy?: InfluenceSectionOrderByWithAggregationInput | InfluenceSectionOrderByWithAggregationInput[]
    by: InfluenceSectionScalarFieldEnum[] | InfluenceSectionScalarFieldEnum
    having?: InfluenceSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfluenceSectionCountAggregateInputType | true
    _avg?: InfluenceSectionAvgAggregateInputType
    _sum?: InfluenceSectionSumAggregateInputType
    _min?: InfluenceSectionMinAggregateInputType
    _max?: InfluenceSectionMaxAggregateInputType
  }

  export type InfluenceSectionGroupByOutputType = {
    id: number
    title: string
    description: string
    steps: JsonValue
    isActive: boolean
    _count: InfluenceSectionCountAggregateOutputType | null
    _avg: InfluenceSectionAvgAggregateOutputType | null
    _sum: InfluenceSectionSumAggregateOutputType | null
    _min: InfluenceSectionMinAggregateOutputType | null
    _max: InfluenceSectionMaxAggregateOutputType | null
  }

  type GetInfluenceSectionGroupByPayload<T extends InfluenceSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfluenceSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfluenceSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfluenceSectionGroupByOutputType[P]>
            : GetScalarType<T[P], InfluenceSectionGroupByOutputType[P]>
        }
      >
    >


  export type InfluenceSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    steps?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["influenceSection"]>

  export type InfluenceSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    steps?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["influenceSection"]>

  export type InfluenceSectionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    steps?: boolean
    isActive?: boolean
  }


  export type $InfluenceSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InfluenceSection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      steps: Prisma.JsonValue
      isActive: boolean
    }, ExtArgs["result"]["influenceSection"]>
    composites: {}
  }

  type InfluenceSectionGetPayload<S extends boolean | null | undefined | InfluenceSectionDefaultArgs> = $Result.GetResult<Prisma.$InfluenceSectionPayload, S>

  type InfluenceSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InfluenceSectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InfluenceSectionCountAggregateInputType | true
    }

  export interface InfluenceSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InfluenceSection'], meta: { name: 'InfluenceSection' } }
    /**
     * Find zero or one InfluenceSection that matches the filter.
     * @param {InfluenceSectionFindUniqueArgs} args - Arguments to find a InfluenceSection
     * @example
     * // Get one InfluenceSection
     * const influenceSection = await prisma.influenceSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfluenceSectionFindUniqueArgs>(args: SelectSubset<T, InfluenceSectionFindUniqueArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InfluenceSection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InfluenceSectionFindUniqueOrThrowArgs} args - Arguments to find a InfluenceSection
     * @example
     * // Get one InfluenceSection
     * const influenceSection = await prisma.influenceSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfluenceSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, InfluenceSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InfluenceSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceSectionFindFirstArgs} args - Arguments to find a InfluenceSection
     * @example
     * // Get one InfluenceSection
     * const influenceSection = await prisma.influenceSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfluenceSectionFindFirstArgs>(args?: SelectSubset<T, InfluenceSectionFindFirstArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InfluenceSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceSectionFindFirstOrThrowArgs} args - Arguments to find a InfluenceSection
     * @example
     * // Get one InfluenceSection
     * const influenceSection = await prisma.influenceSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfluenceSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, InfluenceSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InfluenceSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InfluenceSections
     * const influenceSections = await prisma.influenceSection.findMany()
     * 
     * // Get first 10 InfluenceSections
     * const influenceSections = await prisma.influenceSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const influenceSectionWithIdOnly = await prisma.influenceSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfluenceSectionFindManyArgs>(args?: SelectSubset<T, InfluenceSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InfluenceSection.
     * @param {InfluenceSectionCreateArgs} args - Arguments to create a InfluenceSection.
     * @example
     * // Create one InfluenceSection
     * const InfluenceSection = await prisma.influenceSection.create({
     *   data: {
     *     // ... data to create a InfluenceSection
     *   }
     * })
     * 
     */
    create<T extends InfluenceSectionCreateArgs>(args: SelectSubset<T, InfluenceSectionCreateArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InfluenceSections.
     * @param {InfluenceSectionCreateManyArgs} args - Arguments to create many InfluenceSections.
     * @example
     * // Create many InfluenceSections
     * const influenceSection = await prisma.influenceSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfluenceSectionCreateManyArgs>(args?: SelectSubset<T, InfluenceSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InfluenceSections and returns the data saved in the database.
     * @param {InfluenceSectionCreateManyAndReturnArgs} args - Arguments to create many InfluenceSections.
     * @example
     * // Create many InfluenceSections
     * const influenceSection = await prisma.influenceSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InfluenceSections and only return the `id`
     * const influenceSectionWithIdOnly = await prisma.influenceSection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfluenceSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, InfluenceSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InfluenceSection.
     * @param {InfluenceSectionDeleteArgs} args - Arguments to delete one InfluenceSection.
     * @example
     * // Delete one InfluenceSection
     * const InfluenceSection = await prisma.influenceSection.delete({
     *   where: {
     *     // ... filter to delete one InfluenceSection
     *   }
     * })
     * 
     */
    delete<T extends InfluenceSectionDeleteArgs>(args: SelectSubset<T, InfluenceSectionDeleteArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InfluenceSection.
     * @param {InfluenceSectionUpdateArgs} args - Arguments to update one InfluenceSection.
     * @example
     * // Update one InfluenceSection
     * const influenceSection = await prisma.influenceSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfluenceSectionUpdateArgs>(args: SelectSubset<T, InfluenceSectionUpdateArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InfluenceSections.
     * @param {InfluenceSectionDeleteManyArgs} args - Arguments to filter InfluenceSections to delete.
     * @example
     * // Delete a few InfluenceSections
     * const { count } = await prisma.influenceSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfluenceSectionDeleteManyArgs>(args?: SelectSubset<T, InfluenceSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfluenceSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InfluenceSections
     * const influenceSection = await prisma.influenceSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfluenceSectionUpdateManyArgs>(args: SelectSubset<T, InfluenceSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InfluenceSection.
     * @param {InfluenceSectionUpsertArgs} args - Arguments to update or create a InfluenceSection.
     * @example
     * // Update or create a InfluenceSection
     * const influenceSection = await prisma.influenceSection.upsert({
     *   create: {
     *     // ... data to create a InfluenceSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InfluenceSection we want to update
     *   }
     * })
     */
    upsert<T extends InfluenceSectionUpsertArgs>(args: SelectSubset<T, InfluenceSectionUpsertArgs<ExtArgs>>): Prisma__InfluenceSectionClient<$Result.GetResult<Prisma.$InfluenceSectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InfluenceSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceSectionCountArgs} args - Arguments to filter InfluenceSections to count.
     * @example
     * // Count the number of InfluenceSections
     * const count = await prisma.influenceSection.count({
     *   where: {
     *     // ... the filter for the InfluenceSections we want to count
     *   }
     * })
    **/
    count<T extends InfluenceSectionCountArgs>(
      args?: Subset<T, InfluenceSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfluenceSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InfluenceSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfluenceSectionAggregateArgs>(args: Subset<T, InfluenceSectionAggregateArgs>): Prisma.PrismaPromise<GetInfluenceSectionAggregateType<T>>

    /**
     * Group by InfluenceSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluenceSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfluenceSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfluenceSectionGroupByArgs['orderBy'] }
        : { orderBy?: InfluenceSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfluenceSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfluenceSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InfluenceSection model
   */
  readonly fields: InfluenceSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InfluenceSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfluenceSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InfluenceSection model
   */ 
  interface InfluenceSectionFieldRefs {
    readonly id: FieldRef<"InfluenceSection", 'Int'>
    readonly title: FieldRef<"InfluenceSection", 'String'>
    readonly description: FieldRef<"InfluenceSection", 'String'>
    readonly steps: FieldRef<"InfluenceSection", 'Json'>
    readonly isActive: FieldRef<"InfluenceSection", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InfluenceSection findUnique
   */
  export type InfluenceSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * Filter, which InfluenceSection to fetch.
     */
    where: InfluenceSectionWhereUniqueInput
  }

  /**
   * InfluenceSection findUniqueOrThrow
   */
  export type InfluenceSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * Filter, which InfluenceSection to fetch.
     */
    where: InfluenceSectionWhereUniqueInput
  }

  /**
   * InfluenceSection findFirst
   */
  export type InfluenceSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * Filter, which InfluenceSection to fetch.
     */
    where?: InfluenceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluenceSections to fetch.
     */
    orderBy?: InfluenceSectionOrderByWithRelationInput | InfluenceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfluenceSections.
     */
    cursor?: InfluenceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluenceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluenceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfluenceSections.
     */
    distinct?: InfluenceSectionScalarFieldEnum | InfluenceSectionScalarFieldEnum[]
  }

  /**
   * InfluenceSection findFirstOrThrow
   */
  export type InfluenceSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * Filter, which InfluenceSection to fetch.
     */
    where?: InfluenceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluenceSections to fetch.
     */
    orderBy?: InfluenceSectionOrderByWithRelationInput | InfluenceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfluenceSections.
     */
    cursor?: InfluenceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluenceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluenceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfluenceSections.
     */
    distinct?: InfluenceSectionScalarFieldEnum | InfluenceSectionScalarFieldEnum[]
  }

  /**
   * InfluenceSection findMany
   */
  export type InfluenceSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * Filter, which InfluenceSections to fetch.
     */
    where?: InfluenceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluenceSections to fetch.
     */
    orderBy?: InfluenceSectionOrderByWithRelationInput | InfluenceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InfluenceSections.
     */
    cursor?: InfluenceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluenceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluenceSections.
     */
    skip?: number
    distinct?: InfluenceSectionScalarFieldEnum | InfluenceSectionScalarFieldEnum[]
  }

  /**
   * InfluenceSection create
   */
  export type InfluenceSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * The data needed to create a InfluenceSection.
     */
    data: XOR<InfluenceSectionCreateInput, InfluenceSectionUncheckedCreateInput>
  }

  /**
   * InfluenceSection createMany
   */
  export type InfluenceSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InfluenceSections.
     */
    data: InfluenceSectionCreateManyInput | InfluenceSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfluenceSection createManyAndReturn
   */
  export type InfluenceSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InfluenceSections.
     */
    data: InfluenceSectionCreateManyInput | InfluenceSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfluenceSection update
   */
  export type InfluenceSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * The data needed to update a InfluenceSection.
     */
    data: XOR<InfluenceSectionUpdateInput, InfluenceSectionUncheckedUpdateInput>
    /**
     * Choose, which InfluenceSection to update.
     */
    where: InfluenceSectionWhereUniqueInput
  }

  /**
   * InfluenceSection updateMany
   */
  export type InfluenceSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InfluenceSections.
     */
    data: XOR<InfluenceSectionUpdateManyMutationInput, InfluenceSectionUncheckedUpdateManyInput>
    /**
     * Filter which InfluenceSections to update
     */
    where?: InfluenceSectionWhereInput
  }

  /**
   * InfluenceSection upsert
   */
  export type InfluenceSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * The filter to search for the InfluenceSection to update in case it exists.
     */
    where: InfluenceSectionWhereUniqueInput
    /**
     * In case the InfluenceSection found by the `where` argument doesn't exist, create a new InfluenceSection with this data.
     */
    create: XOR<InfluenceSectionCreateInput, InfluenceSectionUncheckedCreateInput>
    /**
     * In case the InfluenceSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfluenceSectionUpdateInput, InfluenceSectionUncheckedUpdateInput>
  }

  /**
   * InfluenceSection delete
   */
  export type InfluenceSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
    /**
     * Filter which InfluenceSection to delete.
     */
    where: InfluenceSectionWhereUniqueInput
  }

  /**
   * InfluenceSection deleteMany
   */
  export type InfluenceSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfluenceSections to delete
     */
    where?: InfluenceSectionWhereInput
  }

  /**
   * InfluenceSection without action
   */
  export type InfluenceSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluenceSection
     */
    select?: InfluenceSectionSelect<ExtArgs> | null
  }


  /**
   * Model AdvantageSection
   */

  export type AggregateAdvantageSection = {
    _count: AdvantageSectionCountAggregateOutputType | null
    _avg: AdvantageSectionAvgAggregateOutputType | null
    _sum: AdvantageSectionSumAggregateOutputType | null
    _min: AdvantageSectionMinAggregateOutputType | null
    _max: AdvantageSectionMaxAggregateOutputType | null
  }

  export type AdvantageSectionAvgAggregateOutputType = {
    id: number | null
  }

  export type AdvantageSectionSumAggregateOutputType = {
    id: number | null
  }

  export type AdvantageSectionMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    isActive: boolean | null
  }

  export type AdvantageSectionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    isActive: boolean | null
  }

  export type AdvantageSectionCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    items: number
    isActive: number
    _all: number
  }


  export type AdvantageSectionAvgAggregateInputType = {
    id?: true
  }

  export type AdvantageSectionSumAggregateInputType = {
    id?: true
  }

  export type AdvantageSectionMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    isActive?: true
  }

  export type AdvantageSectionMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    isActive?: true
  }

  export type AdvantageSectionCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    items?: true
    isActive?: true
    _all?: true
  }

  export type AdvantageSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvantageSection to aggregate.
     */
    where?: AdvantageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageSections to fetch.
     */
    orderBy?: AdvantageSectionOrderByWithRelationInput | AdvantageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvantageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdvantageSections
    **/
    _count?: true | AdvantageSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvantageSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvantageSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvantageSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvantageSectionMaxAggregateInputType
  }

  export type GetAdvantageSectionAggregateType<T extends AdvantageSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvantageSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvantageSection[P]>
      : GetScalarType<T[P], AggregateAdvantageSection[P]>
  }




  export type AdvantageSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvantageSectionWhereInput
    orderBy?: AdvantageSectionOrderByWithAggregationInput | AdvantageSectionOrderByWithAggregationInput[]
    by: AdvantageSectionScalarFieldEnum[] | AdvantageSectionScalarFieldEnum
    having?: AdvantageSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvantageSectionCountAggregateInputType | true
    _avg?: AdvantageSectionAvgAggregateInputType
    _sum?: AdvantageSectionSumAggregateInputType
    _min?: AdvantageSectionMinAggregateInputType
    _max?: AdvantageSectionMaxAggregateInputType
  }

  export type AdvantageSectionGroupByOutputType = {
    id: number
    title: string
    subtitle: string
    items: JsonValue
    isActive: boolean
    _count: AdvantageSectionCountAggregateOutputType | null
    _avg: AdvantageSectionAvgAggregateOutputType | null
    _sum: AdvantageSectionSumAggregateOutputType | null
    _min: AdvantageSectionMinAggregateOutputType | null
    _max: AdvantageSectionMaxAggregateOutputType | null
  }

  type GetAdvantageSectionGroupByPayload<T extends AdvantageSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvantageSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvantageSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvantageSectionGroupByOutputType[P]>
            : GetScalarType<T[P], AdvantageSectionGroupByOutputType[P]>
        }
      >
    >


  export type AdvantageSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    items?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["advantageSection"]>

  export type AdvantageSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    items?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["advantageSection"]>

  export type AdvantageSectionSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    items?: boolean
    isActive?: boolean
  }


  export type $AdvantageSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdvantageSection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      subtitle: string
      items: Prisma.JsonValue
      isActive: boolean
    }, ExtArgs["result"]["advantageSection"]>
    composites: {}
  }

  type AdvantageSectionGetPayload<S extends boolean | null | undefined | AdvantageSectionDefaultArgs> = $Result.GetResult<Prisma.$AdvantageSectionPayload, S>

  type AdvantageSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvantageSectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvantageSectionCountAggregateInputType | true
    }

  export interface AdvantageSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvantageSection'], meta: { name: 'AdvantageSection' } }
    /**
     * Find zero or one AdvantageSection that matches the filter.
     * @param {AdvantageSectionFindUniqueArgs} args - Arguments to find a AdvantageSection
     * @example
     * // Get one AdvantageSection
     * const advantageSection = await prisma.advantageSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvantageSectionFindUniqueArgs>(args: SelectSubset<T, AdvantageSectionFindUniqueArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdvantageSection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvantageSectionFindUniqueOrThrowArgs} args - Arguments to find a AdvantageSection
     * @example
     * // Get one AdvantageSection
     * const advantageSection = await prisma.advantageSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvantageSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvantageSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdvantageSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageSectionFindFirstArgs} args - Arguments to find a AdvantageSection
     * @example
     * // Get one AdvantageSection
     * const advantageSection = await prisma.advantageSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvantageSectionFindFirstArgs>(args?: SelectSubset<T, AdvantageSectionFindFirstArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdvantageSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageSectionFindFirstOrThrowArgs} args - Arguments to find a AdvantageSection
     * @example
     * // Get one AdvantageSection
     * const advantageSection = await prisma.advantageSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvantageSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvantageSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdvantageSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvantageSections
     * const advantageSections = await prisma.advantageSection.findMany()
     * 
     * // Get first 10 AdvantageSections
     * const advantageSections = await prisma.advantageSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advantageSectionWithIdOnly = await prisma.advantageSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvantageSectionFindManyArgs>(args?: SelectSubset<T, AdvantageSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdvantageSection.
     * @param {AdvantageSectionCreateArgs} args - Arguments to create a AdvantageSection.
     * @example
     * // Create one AdvantageSection
     * const AdvantageSection = await prisma.advantageSection.create({
     *   data: {
     *     // ... data to create a AdvantageSection
     *   }
     * })
     * 
     */
    create<T extends AdvantageSectionCreateArgs>(args: SelectSubset<T, AdvantageSectionCreateArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdvantageSections.
     * @param {AdvantageSectionCreateManyArgs} args - Arguments to create many AdvantageSections.
     * @example
     * // Create many AdvantageSections
     * const advantageSection = await prisma.advantageSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvantageSectionCreateManyArgs>(args?: SelectSubset<T, AdvantageSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdvantageSections and returns the data saved in the database.
     * @param {AdvantageSectionCreateManyAndReturnArgs} args - Arguments to create many AdvantageSections.
     * @example
     * // Create many AdvantageSections
     * const advantageSection = await prisma.advantageSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdvantageSections and only return the `id`
     * const advantageSectionWithIdOnly = await prisma.advantageSection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvantageSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvantageSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdvantageSection.
     * @param {AdvantageSectionDeleteArgs} args - Arguments to delete one AdvantageSection.
     * @example
     * // Delete one AdvantageSection
     * const AdvantageSection = await prisma.advantageSection.delete({
     *   where: {
     *     // ... filter to delete one AdvantageSection
     *   }
     * })
     * 
     */
    delete<T extends AdvantageSectionDeleteArgs>(args: SelectSubset<T, AdvantageSectionDeleteArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdvantageSection.
     * @param {AdvantageSectionUpdateArgs} args - Arguments to update one AdvantageSection.
     * @example
     * // Update one AdvantageSection
     * const advantageSection = await prisma.advantageSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvantageSectionUpdateArgs>(args: SelectSubset<T, AdvantageSectionUpdateArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdvantageSections.
     * @param {AdvantageSectionDeleteManyArgs} args - Arguments to filter AdvantageSections to delete.
     * @example
     * // Delete a few AdvantageSections
     * const { count } = await prisma.advantageSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvantageSectionDeleteManyArgs>(args?: SelectSubset<T, AdvantageSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvantageSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvantageSections
     * const advantageSection = await prisma.advantageSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvantageSectionUpdateManyArgs>(args: SelectSubset<T, AdvantageSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdvantageSection.
     * @param {AdvantageSectionUpsertArgs} args - Arguments to update or create a AdvantageSection.
     * @example
     * // Update or create a AdvantageSection
     * const advantageSection = await prisma.advantageSection.upsert({
     *   create: {
     *     // ... data to create a AdvantageSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvantageSection we want to update
     *   }
     * })
     */
    upsert<T extends AdvantageSectionUpsertArgs>(args: SelectSubset<T, AdvantageSectionUpsertArgs<ExtArgs>>): Prisma__AdvantageSectionClient<$Result.GetResult<Prisma.$AdvantageSectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdvantageSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageSectionCountArgs} args - Arguments to filter AdvantageSections to count.
     * @example
     * // Count the number of AdvantageSections
     * const count = await prisma.advantageSection.count({
     *   where: {
     *     // ... the filter for the AdvantageSections we want to count
     *   }
     * })
    **/
    count<T extends AdvantageSectionCountArgs>(
      args?: Subset<T, AdvantageSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvantageSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdvantageSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvantageSectionAggregateArgs>(args: Subset<T, AdvantageSectionAggregateArgs>): Prisma.PrismaPromise<GetAdvantageSectionAggregateType<T>>

    /**
     * Group by AdvantageSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantageSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvantageSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvantageSectionGroupByArgs['orderBy'] }
        : { orderBy?: AdvantageSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvantageSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvantageSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdvantageSection model
   */
  readonly fields: AdvantageSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvantageSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvantageSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdvantageSection model
   */ 
  interface AdvantageSectionFieldRefs {
    readonly id: FieldRef<"AdvantageSection", 'Int'>
    readonly title: FieldRef<"AdvantageSection", 'String'>
    readonly subtitle: FieldRef<"AdvantageSection", 'String'>
    readonly items: FieldRef<"AdvantageSection", 'Json'>
    readonly isActive: FieldRef<"AdvantageSection", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AdvantageSection findUnique
   */
  export type AdvantageSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * Filter, which AdvantageSection to fetch.
     */
    where: AdvantageSectionWhereUniqueInput
  }

  /**
   * AdvantageSection findUniqueOrThrow
   */
  export type AdvantageSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * Filter, which AdvantageSection to fetch.
     */
    where: AdvantageSectionWhereUniqueInput
  }

  /**
   * AdvantageSection findFirst
   */
  export type AdvantageSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * Filter, which AdvantageSection to fetch.
     */
    where?: AdvantageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageSections to fetch.
     */
    orderBy?: AdvantageSectionOrderByWithRelationInput | AdvantageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvantageSections.
     */
    cursor?: AdvantageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvantageSections.
     */
    distinct?: AdvantageSectionScalarFieldEnum | AdvantageSectionScalarFieldEnum[]
  }

  /**
   * AdvantageSection findFirstOrThrow
   */
  export type AdvantageSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * Filter, which AdvantageSection to fetch.
     */
    where?: AdvantageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageSections to fetch.
     */
    orderBy?: AdvantageSectionOrderByWithRelationInput | AdvantageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvantageSections.
     */
    cursor?: AdvantageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvantageSections.
     */
    distinct?: AdvantageSectionScalarFieldEnum | AdvantageSectionScalarFieldEnum[]
  }

  /**
   * AdvantageSection findMany
   */
  export type AdvantageSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * Filter, which AdvantageSections to fetch.
     */
    where?: AdvantageSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvantageSections to fetch.
     */
    orderBy?: AdvantageSectionOrderByWithRelationInput | AdvantageSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdvantageSections.
     */
    cursor?: AdvantageSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvantageSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvantageSections.
     */
    skip?: number
    distinct?: AdvantageSectionScalarFieldEnum | AdvantageSectionScalarFieldEnum[]
  }

  /**
   * AdvantageSection create
   */
  export type AdvantageSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * The data needed to create a AdvantageSection.
     */
    data: XOR<AdvantageSectionCreateInput, AdvantageSectionUncheckedCreateInput>
  }

  /**
   * AdvantageSection createMany
   */
  export type AdvantageSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdvantageSections.
     */
    data: AdvantageSectionCreateManyInput | AdvantageSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdvantageSection createManyAndReturn
   */
  export type AdvantageSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdvantageSections.
     */
    data: AdvantageSectionCreateManyInput | AdvantageSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdvantageSection update
   */
  export type AdvantageSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * The data needed to update a AdvantageSection.
     */
    data: XOR<AdvantageSectionUpdateInput, AdvantageSectionUncheckedUpdateInput>
    /**
     * Choose, which AdvantageSection to update.
     */
    where: AdvantageSectionWhereUniqueInput
  }

  /**
   * AdvantageSection updateMany
   */
  export type AdvantageSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdvantageSections.
     */
    data: XOR<AdvantageSectionUpdateManyMutationInput, AdvantageSectionUncheckedUpdateManyInput>
    /**
     * Filter which AdvantageSections to update
     */
    where?: AdvantageSectionWhereInput
  }

  /**
   * AdvantageSection upsert
   */
  export type AdvantageSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * The filter to search for the AdvantageSection to update in case it exists.
     */
    where: AdvantageSectionWhereUniqueInput
    /**
     * In case the AdvantageSection found by the `where` argument doesn't exist, create a new AdvantageSection with this data.
     */
    create: XOR<AdvantageSectionCreateInput, AdvantageSectionUncheckedCreateInput>
    /**
     * In case the AdvantageSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvantageSectionUpdateInput, AdvantageSectionUncheckedUpdateInput>
  }

  /**
   * AdvantageSection delete
   */
  export type AdvantageSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
    /**
     * Filter which AdvantageSection to delete.
     */
    where: AdvantageSectionWhereUniqueInput
  }

  /**
   * AdvantageSection deleteMany
   */
  export type AdvantageSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvantageSections to delete
     */
    where?: AdvantageSectionWhereInput
  }

  /**
   * AdvantageSection without action
   */
  export type AdvantageSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantageSection
     */
    select?: AdvantageSectionSelect<ExtArgs> | null
  }


  /**
   * Model QuickStartSection
   */

  export type AggregateQuickStartSection = {
    _count: QuickStartSectionCountAggregateOutputType | null
    _avg: QuickStartSectionAvgAggregateOutputType | null
    _sum: QuickStartSectionSumAggregateOutputType | null
    _min: QuickStartSectionMinAggregateOutputType | null
    _max: QuickStartSectionMaxAggregateOutputType | null
  }

  export type QuickStartSectionAvgAggregateOutputType = {
    id: number | null
  }

  export type QuickStartSectionSumAggregateOutputType = {
    id: number | null
  }

  export type QuickStartSectionMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
  }

  export type QuickStartSectionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
  }

  export type QuickStartSectionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    buttons: number
    isActive: number
    _all: number
  }


  export type QuickStartSectionAvgAggregateInputType = {
    id?: true
  }

  export type QuickStartSectionSumAggregateInputType = {
    id?: true
  }

  export type QuickStartSectionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isActive?: true
  }

  export type QuickStartSectionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isActive?: true
  }

  export type QuickStartSectionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    buttons?: true
    isActive?: true
    _all?: true
  }

  export type QuickStartSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickStartSection to aggregate.
     */
    where?: QuickStartSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickStartSections to fetch.
     */
    orderBy?: QuickStartSectionOrderByWithRelationInput | QuickStartSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuickStartSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickStartSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickStartSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuickStartSections
    **/
    _count?: true | QuickStartSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuickStartSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuickStartSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuickStartSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuickStartSectionMaxAggregateInputType
  }

  export type GetQuickStartSectionAggregateType<T extends QuickStartSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuickStartSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuickStartSection[P]>
      : GetScalarType<T[P], AggregateQuickStartSection[P]>
  }




  export type QuickStartSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickStartSectionWhereInput
    orderBy?: QuickStartSectionOrderByWithAggregationInput | QuickStartSectionOrderByWithAggregationInput[]
    by: QuickStartSectionScalarFieldEnum[] | QuickStartSectionScalarFieldEnum
    having?: QuickStartSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuickStartSectionCountAggregateInputType | true
    _avg?: QuickStartSectionAvgAggregateInputType
    _sum?: QuickStartSectionSumAggregateInputType
    _min?: QuickStartSectionMinAggregateInputType
    _max?: QuickStartSectionMaxAggregateInputType
  }

  export type QuickStartSectionGroupByOutputType = {
    id: number
    title: string
    description: string
    buttons: JsonValue
    isActive: boolean
    _count: QuickStartSectionCountAggregateOutputType | null
    _avg: QuickStartSectionAvgAggregateOutputType | null
    _sum: QuickStartSectionSumAggregateOutputType | null
    _min: QuickStartSectionMinAggregateOutputType | null
    _max: QuickStartSectionMaxAggregateOutputType | null
  }

  type GetQuickStartSectionGroupByPayload<T extends QuickStartSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuickStartSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuickStartSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuickStartSectionGroupByOutputType[P]>
            : GetScalarType<T[P], QuickStartSectionGroupByOutputType[P]>
        }
      >
    >


  export type QuickStartSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    buttons?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["quickStartSection"]>

  export type QuickStartSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    buttons?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["quickStartSection"]>

  export type QuickStartSectionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    buttons?: boolean
    isActive?: boolean
  }


  export type $QuickStartSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuickStartSection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      buttons: Prisma.JsonValue
      isActive: boolean
    }, ExtArgs["result"]["quickStartSection"]>
    composites: {}
  }

  type QuickStartSectionGetPayload<S extends boolean | null | undefined | QuickStartSectionDefaultArgs> = $Result.GetResult<Prisma.$QuickStartSectionPayload, S>

  type QuickStartSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuickStartSectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuickStartSectionCountAggregateInputType | true
    }

  export interface QuickStartSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuickStartSection'], meta: { name: 'QuickStartSection' } }
    /**
     * Find zero or one QuickStartSection that matches the filter.
     * @param {QuickStartSectionFindUniqueArgs} args - Arguments to find a QuickStartSection
     * @example
     * // Get one QuickStartSection
     * const quickStartSection = await prisma.quickStartSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuickStartSectionFindUniqueArgs>(args: SelectSubset<T, QuickStartSectionFindUniqueArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuickStartSection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuickStartSectionFindUniqueOrThrowArgs} args - Arguments to find a QuickStartSection
     * @example
     * // Get one QuickStartSection
     * const quickStartSection = await prisma.quickStartSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuickStartSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuickStartSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuickStartSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickStartSectionFindFirstArgs} args - Arguments to find a QuickStartSection
     * @example
     * // Get one QuickStartSection
     * const quickStartSection = await prisma.quickStartSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuickStartSectionFindFirstArgs>(args?: SelectSubset<T, QuickStartSectionFindFirstArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuickStartSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickStartSectionFindFirstOrThrowArgs} args - Arguments to find a QuickStartSection
     * @example
     * // Get one QuickStartSection
     * const quickStartSection = await prisma.quickStartSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuickStartSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuickStartSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuickStartSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickStartSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuickStartSections
     * const quickStartSections = await prisma.quickStartSection.findMany()
     * 
     * // Get first 10 QuickStartSections
     * const quickStartSections = await prisma.quickStartSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quickStartSectionWithIdOnly = await prisma.quickStartSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuickStartSectionFindManyArgs>(args?: SelectSubset<T, QuickStartSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuickStartSection.
     * @param {QuickStartSectionCreateArgs} args - Arguments to create a QuickStartSection.
     * @example
     * // Create one QuickStartSection
     * const QuickStartSection = await prisma.quickStartSection.create({
     *   data: {
     *     // ... data to create a QuickStartSection
     *   }
     * })
     * 
     */
    create<T extends QuickStartSectionCreateArgs>(args: SelectSubset<T, QuickStartSectionCreateArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuickStartSections.
     * @param {QuickStartSectionCreateManyArgs} args - Arguments to create many QuickStartSections.
     * @example
     * // Create many QuickStartSections
     * const quickStartSection = await prisma.quickStartSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuickStartSectionCreateManyArgs>(args?: SelectSubset<T, QuickStartSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuickStartSections and returns the data saved in the database.
     * @param {QuickStartSectionCreateManyAndReturnArgs} args - Arguments to create many QuickStartSections.
     * @example
     * // Create many QuickStartSections
     * const quickStartSection = await prisma.quickStartSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuickStartSections and only return the `id`
     * const quickStartSectionWithIdOnly = await prisma.quickStartSection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuickStartSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuickStartSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuickStartSection.
     * @param {QuickStartSectionDeleteArgs} args - Arguments to delete one QuickStartSection.
     * @example
     * // Delete one QuickStartSection
     * const QuickStartSection = await prisma.quickStartSection.delete({
     *   where: {
     *     // ... filter to delete one QuickStartSection
     *   }
     * })
     * 
     */
    delete<T extends QuickStartSectionDeleteArgs>(args: SelectSubset<T, QuickStartSectionDeleteArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuickStartSection.
     * @param {QuickStartSectionUpdateArgs} args - Arguments to update one QuickStartSection.
     * @example
     * // Update one QuickStartSection
     * const quickStartSection = await prisma.quickStartSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuickStartSectionUpdateArgs>(args: SelectSubset<T, QuickStartSectionUpdateArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuickStartSections.
     * @param {QuickStartSectionDeleteManyArgs} args - Arguments to filter QuickStartSections to delete.
     * @example
     * // Delete a few QuickStartSections
     * const { count } = await prisma.quickStartSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuickStartSectionDeleteManyArgs>(args?: SelectSubset<T, QuickStartSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuickStartSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickStartSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuickStartSections
     * const quickStartSection = await prisma.quickStartSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuickStartSectionUpdateManyArgs>(args: SelectSubset<T, QuickStartSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuickStartSection.
     * @param {QuickStartSectionUpsertArgs} args - Arguments to update or create a QuickStartSection.
     * @example
     * // Update or create a QuickStartSection
     * const quickStartSection = await prisma.quickStartSection.upsert({
     *   create: {
     *     // ... data to create a QuickStartSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuickStartSection we want to update
     *   }
     * })
     */
    upsert<T extends QuickStartSectionUpsertArgs>(args: SelectSubset<T, QuickStartSectionUpsertArgs<ExtArgs>>): Prisma__QuickStartSectionClient<$Result.GetResult<Prisma.$QuickStartSectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuickStartSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickStartSectionCountArgs} args - Arguments to filter QuickStartSections to count.
     * @example
     * // Count the number of QuickStartSections
     * const count = await prisma.quickStartSection.count({
     *   where: {
     *     // ... the filter for the QuickStartSections we want to count
     *   }
     * })
    **/
    count<T extends QuickStartSectionCountArgs>(
      args?: Subset<T, QuickStartSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuickStartSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuickStartSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickStartSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuickStartSectionAggregateArgs>(args: Subset<T, QuickStartSectionAggregateArgs>): Prisma.PrismaPromise<GetQuickStartSectionAggregateType<T>>

    /**
     * Group by QuickStartSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickStartSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuickStartSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuickStartSectionGroupByArgs['orderBy'] }
        : { orderBy?: QuickStartSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuickStartSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuickStartSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuickStartSection model
   */
  readonly fields: QuickStartSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuickStartSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuickStartSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuickStartSection model
   */ 
  interface QuickStartSectionFieldRefs {
    readonly id: FieldRef<"QuickStartSection", 'Int'>
    readonly title: FieldRef<"QuickStartSection", 'String'>
    readonly description: FieldRef<"QuickStartSection", 'String'>
    readonly buttons: FieldRef<"QuickStartSection", 'Json'>
    readonly isActive: FieldRef<"QuickStartSection", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * QuickStartSection findUnique
   */
  export type QuickStartSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * Filter, which QuickStartSection to fetch.
     */
    where: QuickStartSectionWhereUniqueInput
  }

  /**
   * QuickStartSection findUniqueOrThrow
   */
  export type QuickStartSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * Filter, which QuickStartSection to fetch.
     */
    where: QuickStartSectionWhereUniqueInput
  }

  /**
   * QuickStartSection findFirst
   */
  export type QuickStartSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * Filter, which QuickStartSection to fetch.
     */
    where?: QuickStartSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickStartSections to fetch.
     */
    orderBy?: QuickStartSectionOrderByWithRelationInput | QuickStartSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickStartSections.
     */
    cursor?: QuickStartSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickStartSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickStartSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickStartSections.
     */
    distinct?: QuickStartSectionScalarFieldEnum | QuickStartSectionScalarFieldEnum[]
  }

  /**
   * QuickStartSection findFirstOrThrow
   */
  export type QuickStartSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * Filter, which QuickStartSection to fetch.
     */
    where?: QuickStartSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickStartSections to fetch.
     */
    orderBy?: QuickStartSectionOrderByWithRelationInput | QuickStartSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickStartSections.
     */
    cursor?: QuickStartSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickStartSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickStartSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickStartSections.
     */
    distinct?: QuickStartSectionScalarFieldEnum | QuickStartSectionScalarFieldEnum[]
  }

  /**
   * QuickStartSection findMany
   */
  export type QuickStartSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * Filter, which QuickStartSections to fetch.
     */
    where?: QuickStartSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickStartSections to fetch.
     */
    orderBy?: QuickStartSectionOrderByWithRelationInput | QuickStartSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuickStartSections.
     */
    cursor?: QuickStartSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickStartSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickStartSections.
     */
    skip?: number
    distinct?: QuickStartSectionScalarFieldEnum | QuickStartSectionScalarFieldEnum[]
  }

  /**
   * QuickStartSection create
   */
  export type QuickStartSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * The data needed to create a QuickStartSection.
     */
    data: XOR<QuickStartSectionCreateInput, QuickStartSectionUncheckedCreateInput>
  }

  /**
   * QuickStartSection createMany
   */
  export type QuickStartSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuickStartSections.
     */
    data: QuickStartSectionCreateManyInput | QuickStartSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuickStartSection createManyAndReturn
   */
  export type QuickStartSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuickStartSections.
     */
    data: QuickStartSectionCreateManyInput | QuickStartSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuickStartSection update
   */
  export type QuickStartSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * The data needed to update a QuickStartSection.
     */
    data: XOR<QuickStartSectionUpdateInput, QuickStartSectionUncheckedUpdateInput>
    /**
     * Choose, which QuickStartSection to update.
     */
    where: QuickStartSectionWhereUniqueInput
  }

  /**
   * QuickStartSection updateMany
   */
  export type QuickStartSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuickStartSections.
     */
    data: XOR<QuickStartSectionUpdateManyMutationInput, QuickStartSectionUncheckedUpdateManyInput>
    /**
     * Filter which QuickStartSections to update
     */
    where?: QuickStartSectionWhereInput
  }

  /**
   * QuickStartSection upsert
   */
  export type QuickStartSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * The filter to search for the QuickStartSection to update in case it exists.
     */
    where: QuickStartSectionWhereUniqueInput
    /**
     * In case the QuickStartSection found by the `where` argument doesn't exist, create a new QuickStartSection with this data.
     */
    create: XOR<QuickStartSectionCreateInput, QuickStartSectionUncheckedCreateInput>
    /**
     * In case the QuickStartSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuickStartSectionUpdateInput, QuickStartSectionUncheckedUpdateInput>
  }

  /**
   * QuickStartSection delete
   */
  export type QuickStartSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
    /**
     * Filter which QuickStartSection to delete.
     */
    where: QuickStartSectionWhereUniqueInput
  }

  /**
   * QuickStartSection deleteMany
   */
  export type QuickStartSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickStartSections to delete
     */
    where?: QuickStartSectionWhereInput
  }

  /**
   * QuickStartSection without action
   */
  export type QuickStartSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickStartSection
     */
    select?: QuickStartSectionSelect<ExtArgs> | null
  }


  /**
   * Model ServicePageContent
   */

  export type AggregateServicePageContent = {
    _count: ServicePageContentCountAggregateOutputType | null
    _avg: ServicePageContentAvgAggregateOutputType | null
    _sum: ServicePageContentSumAggregateOutputType | null
    _min: ServicePageContentMinAggregateOutputType | null
    _max: ServicePageContentMaxAggregateOutputType | null
  }

  export type ServicePageContentAvgAggregateOutputType = {
    id: number | null
  }

  export type ServicePageContentSumAggregateOutputType = {
    id: number | null
  }

  export type ServicePageContentMinAggregateOutputType = {
    id: number | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    slug: string | null
    metaTitle: string | null
    metaDescription: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    heroRating: string | null
    heroReviewCount: string | null
    assuranceCardText: string | null
    learnMoreText: string | null
    learnMoreModalContent: string | null
    isActive: boolean | null
    updatedAt: Date | null
    moreServicesTitle: string | null
    moreServicesHighlight: string | null
    moreServicesBody: string | null
  }

  export type ServicePageContentMaxAggregateOutputType = {
    id: number | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    slug: string | null
    metaTitle: string | null
    metaDescription: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    heroRating: string | null
    heroReviewCount: string | null
    assuranceCardText: string | null
    learnMoreText: string | null
    learnMoreModalContent: string | null
    isActive: boolean | null
    updatedAt: Date | null
    moreServicesTitle: string | null
    moreServicesHighlight: string | null
    moreServicesBody: string | null
  }

  export type ServicePageContentCountAggregateOutputType = {
    id: number
    platform: number
    serviceType: number
    slug: number
    metaTitle: number
    metaDescription: number
    heroTitle: number
    heroSubtitle: number
    heroRating: number
    heroReviewCount: number
    assuranceCardText: number
    learnMoreText: number
    learnMoreModalContent: number
    packages: number
    qualityCompare: number
    howItWorks: number
    isActive: number
    updatedAt: number
    benefits: number
    moreServicesTitle: number
    moreServicesHighlight: number
    moreServicesBody: number
    moreServicesButtons: number
    _all: number
  }


  export type ServicePageContentAvgAggregateInputType = {
    id?: true
  }

  export type ServicePageContentSumAggregateInputType = {
    id?: true
  }

  export type ServicePageContentMinAggregateInputType = {
    id?: true
    platform?: true
    serviceType?: true
    slug?: true
    metaTitle?: true
    metaDescription?: true
    heroTitle?: true
    heroSubtitle?: true
    heroRating?: true
    heroReviewCount?: true
    assuranceCardText?: true
    learnMoreText?: true
    learnMoreModalContent?: true
    isActive?: true
    updatedAt?: true
    moreServicesTitle?: true
    moreServicesHighlight?: true
    moreServicesBody?: true
  }

  export type ServicePageContentMaxAggregateInputType = {
    id?: true
    platform?: true
    serviceType?: true
    slug?: true
    metaTitle?: true
    metaDescription?: true
    heroTitle?: true
    heroSubtitle?: true
    heroRating?: true
    heroReviewCount?: true
    assuranceCardText?: true
    learnMoreText?: true
    learnMoreModalContent?: true
    isActive?: true
    updatedAt?: true
    moreServicesTitle?: true
    moreServicesHighlight?: true
    moreServicesBody?: true
  }

  export type ServicePageContentCountAggregateInputType = {
    id?: true
    platform?: true
    serviceType?: true
    slug?: true
    metaTitle?: true
    metaDescription?: true
    heroTitle?: true
    heroSubtitle?: true
    heroRating?: true
    heroReviewCount?: true
    assuranceCardText?: true
    learnMoreText?: true
    learnMoreModalContent?: true
    packages?: true
    qualityCompare?: true
    howItWorks?: true
    isActive?: true
    updatedAt?: true
    benefits?: true
    moreServicesTitle?: true
    moreServicesHighlight?: true
    moreServicesBody?: true
    moreServicesButtons?: true
    _all?: true
  }

  export type ServicePageContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePageContent to aggregate.
     */
    where?: ServicePageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePageContents to fetch.
     */
    orderBy?: ServicePageContentOrderByWithRelationInput | ServicePageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePageContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePageContents
    **/
    _count?: true | ServicePageContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicePageContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicePageContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePageContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePageContentMaxAggregateInputType
  }

  export type GetServicePageContentAggregateType<T extends ServicePageContentAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePageContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePageContent[P]>
      : GetScalarType<T[P], AggregateServicePageContent[P]>
  }




  export type ServicePageContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePageContentWhereInput
    orderBy?: ServicePageContentOrderByWithAggregationInput | ServicePageContentOrderByWithAggregationInput[]
    by: ServicePageContentScalarFieldEnum[] | ServicePageContentScalarFieldEnum
    having?: ServicePageContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePageContentCountAggregateInputType | true
    _avg?: ServicePageContentAvgAggregateInputType
    _sum?: ServicePageContentSumAggregateInputType
    _min?: ServicePageContentMinAggregateInputType
    _max?: ServicePageContentMaxAggregateInputType
  }

  export type ServicePageContentGroupByOutputType = {
    id: number
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    slug: string | null
    metaTitle: string | null
    metaDescription: string | null
    heroTitle: string
    heroSubtitle: string
    heroRating: string | null
    heroReviewCount: string | null
    assuranceCardText: string | null
    learnMoreText: string | null
    learnMoreModalContent: string | null
    packages: JsonValue
    qualityCompare: JsonValue | null
    howItWorks: JsonValue | null
    isActive: boolean
    updatedAt: Date
    benefits: JsonValue | null
    moreServicesTitle: string | null
    moreServicesHighlight: string | null
    moreServicesBody: string | null
    moreServicesButtons: JsonValue | null
    _count: ServicePageContentCountAggregateOutputType | null
    _avg: ServicePageContentAvgAggregateOutputType | null
    _sum: ServicePageContentSumAggregateOutputType | null
    _min: ServicePageContentMinAggregateOutputType | null
    _max: ServicePageContentMaxAggregateOutputType | null
  }

  type GetServicePageContentGroupByPayload<T extends ServicePageContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePageContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePageContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePageContentGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePageContentGroupByOutputType[P]>
        }
      >
    >


  export type ServicePageContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    serviceType?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroRating?: boolean
    heroReviewCount?: boolean
    assuranceCardText?: boolean
    learnMoreText?: boolean
    learnMoreModalContent?: boolean
    packages?: boolean
    qualityCompare?: boolean
    howItWorks?: boolean
    isActive?: boolean
    updatedAt?: boolean
    benefits?: boolean
    moreServicesTitle?: boolean
    moreServicesHighlight?: boolean
    moreServicesBody?: boolean
    moreServicesButtons?: boolean
  }, ExtArgs["result"]["servicePageContent"]>

  export type ServicePageContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    serviceType?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroRating?: boolean
    heroReviewCount?: boolean
    assuranceCardText?: boolean
    learnMoreText?: boolean
    learnMoreModalContent?: boolean
    packages?: boolean
    qualityCompare?: boolean
    howItWorks?: boolean
    isActive?: boolean
    updatedAt?: boolean
    benefits?: boolean
    moreServicesTitle?: boolean
    moreServicesHighlight?: boolean
    moreServicesBody?: boolean
    moreServicesButtons?: boolean
  }, ExtArgs["result"]["servicePageContent"]>

  export type ServicePageContentSelectScalar = {
    id?: boolean
    platform?: boolean
    serviceType?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    heroRating?: boolean
    heroReviewCount?: boolean
    assuranceCardText?: boolean
    learnMoreText?: boolean
    learnMoreModalContent?: boolean
    packages?: boolean
    qualityCompare?: boolean
    howItWorks?: boolean
    isActive?: boolean
    updatedAt?: boolean
    benefits?: boolean
    moreServicesTitle?: boolean
    moreServicesHighlight?: boolean
    moreServicesBody?: boolean
    moreServicesButtons?: boolean
  }


  export type $ServicePageContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePageContent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      platform: $Enums.Platform
      serviceType: $Enums.ServiceType
      slug: string | null
      metaTitle: string | null
      metaDescription: string | null
      heroTitle: string
      heroSubtitle: string
      heroRating: string | null
      heroReviewCount: string | null
      assuranceCardText: string | null
      learnMoreText: string | null
      learnMoreModalContent: string | null
      packages: Prisma.JsonValue
      qualityCompare: Prisma.JsonValue | null
      howItWorks: Prisma.JsonValue | null
      isActive: boolean
      updatedAt: Date
      benefits: Prisma.JsonValue | null
      moreServicesTitle: string | null
      moreServicesHighlight: string | null
      moreServicesBody: string | null
      moreServicesButtons: Prisma.JsonValue | null
    }, ExtArgs["result"]["servicePageContent"]>
    composites: {}
  }

  type ServicePageContentGetPayload<S extends boolean | null | undefined | ServicePageContentDefaultArgs> = $Result.GetResult<Prisma.$ServicePageContentPayload, S>

  type ServicePageContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicePageContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicePageContentCountAggregateInputType | true
    }

  export interface ServicePageContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePageContent'], meta: { name: 'ServicePageContent' } }
    /**
     * Find zero or one ServicePageContent that matches the filter.
     * @param {ServicePageContentFindUniqueArgs} args - Arguments to find a ServicePageContent
     * @example
     * // Get one ServicePageContent
     * const servicePageContent = await prisma.servicePageContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePageContentFindUniqueArgs>(args: SelectSubset<T, ServicePageContentFindUniqueArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServicePageContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicePageContentFindUniqueOrThrowArgs} args - Arguments to find a ServicePageContent
     * @example
     * // Get one ServicePageContent
     * const servicePageContent = await prisma.servicePageContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePageContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePageContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServicePageContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePageContentFindFirstArgs} args - Arguments to find a ServicePageContent
     * @example
     * // Get one ServicePageContent
     * const servicePageContent = await prisma.servicePageContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePageContentFindFirstArgs>(args?: SelectSubset<T, ServicePageContentFindFirstArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServicePageContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePageContentFindFirstOrThrowArgs} args - Arguments to find a ServicePageContent
     * @example
     * // Get one ServicePageContent
     * const servicePageContent = await prisma.servicePageContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePageContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePageContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServicePageContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePageContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePageContents
     * const servicePageContents = await prisma.servicePageContent.findMany()
     * 
     * // Get first 10 ServicePageContents
     * const servicePageContents = await prisma.servicePageContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePageContentWithIdOnly = await prisma.servicePageContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePageContentFindManyArgs>(args?: SelectSubset<T, ServicePageContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServicePageContent.
     * @param {ServicePageContentCreateArgs} args - Arguments to create a ServicePageContent.
     * @example
     * // Create one ServicePageContent
     * const ServicePageContent = await prisma.servicePageContent.create({
     *   data: {
     *     // ... data to create a ServicePageContent
     *   }
     * })
     * 
     */
    create<T extends ServicePageContentCreateArgs>(args: SelectSubset<T, ServicePageContentCreateArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServicePageContents.
     * @param {ServicePageContentCreateManyArgs} args - Arguments to create many ServicePageContents.
     * @example
     * // Create many ServicePageContents
     * const servicePageContent = await prisma.servicePageContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePageContentCreateManyArgs>(args?: SelectSubset<T, ServicePageContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicePageContents and returns the data saved in the database.
     * @param {ServicePageContentCreateManyAndReturnArgs} args - Arguments to create many ServicePageContents.
     * @example
     * // Create many ServicePageContents
     * const servicePageContent = await prisma.servicePageContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicePageContents and only return the `id`
     * const servicePageContentWithIdOnly = await prisma.servicePageContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePageContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePageContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServicePageContent.
     * @param {ServicePageContentDeleteArgs} args - Arguments to delete one ServicePageContent.
     * @example
     * // Delete one ServicePageContent
     * const ServicePageContent = await prisma.servicePageContent.delete({
     *   where: {
     *     // ... filter to delete one ServicePageContent
     *   }
     * })
     * 
     */
    delete<T extends ServicePageContentDeleteArgs>(args: SelectSubset<T, ServicePageContentDeleteArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServicePageContent.
     * @param {ServicePageContentUpdateArgs} args - Arguments to update one ServicePageContent.
     * @example
     * // Update one ServicePageContent
     * const servicePageContent = await prisma.servicePageContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePageContentUpdateArgs>(args: SelectSubset<T, ServicePageContentUpdateArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServicePageContents.
     * @param {ServicePageContentDeleteManyArgs} args - Arguments to filter ServicePageContents to delete.
     * @example
     * // Delete a few ServicePageContents
     * const { count } = await prisma.servicePageContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePageContentDeleteManyArgs>(args?: SelectSubset<T, ServicePageContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePageContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePageContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePageContents
     * const servicePageContent = await prisma.servicePageContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePageContentUpdateManyArgs>(args: SelectSubset<T, ServicePageContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicePageContent.
     * @param {ServicePageContentUpsertArgs} args - Arguments to update or create a ServicePageContent.
     * @example
     * // Update or create a ServicePageContent
     * const servicePageContent = await prisma.servicePageContent.upsert({
     *   create: {
     *     // ... data to create a ServicePageContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePageContent we want to update
     *   }
     * })
     */
    upsert<T extends ServicePageContentUpsertArgs>(args: SelectSubset<T, ServicePageContentUpsertArgs<ExtArgs>>): Prisma__ServicePageContentClient<$Result.GetResult<Prisma.$ServicePageContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServicePageContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePageContentCountArgs} args - Arguments to filter ServicePageContents to count.
     * @example
     * // Count the number of ServicePageContents
     * const count = await prisma.servicePageContent.count({
     *   where: {
     *     // ... the filter for the ServicePageContents we want to count
     *   }
     * })
    **/
    count<T extends ServicePageContentCountArgs>(
      args?: Subset<T, ServicePageContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePageContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePageContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePageContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePageContentAggregateArgs>(args: Subset<T, ServicePageContentAggregateArgs>): Prisma.PrismaPromise<GetServicePageContentAggregateType<T>>

    /**
     * Group by ServicePageContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePageContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePageContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePageContentGroupByArgs['orderBy'] }
        : { orderBy?: ServicePageContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePageContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePageContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePageContent model
   */
  readonly fields: ServicePageContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePageContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePageContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePageContent model
   */ 
  interface ServicePageContentFieldRefs {
    readonly id: FieldRef<"ServicePageContent", 'Int'>
    readonly platform: FieldRef<"ServicePageContent", 'Platform'>
    readonly serviceType: FieldRef<"ServicePageContent", 'ServiceType'>
    readonly slug: FieldRef<"ServicePageContent", 'String'>
    readonly metaTitle: FieldRef<"ServicePageContent", 'String'>
    readonly metaDescription: FieldRef<"ServicePageContent", 'String'>
    readonly heroTitle: FieldRef<"ServicePageContent", 'String'>
    readonly heroSubtitle: FieldRef<"ServicePageContent", 'String'>
    readonly heroRating: FieldRef<"ServicePageContent", 'String'>
    readonly heroReviewCount: FieldRef<"ServicePageContent", 'String'>
    readonly assuranceCardText: FieldRef<"ServicePageContent", 'String'>
    readonly learnMoreText: FieldRef<"ServicePageContent", 'String'>
    readonly learnMoreModalContent: FieldRef<"ServicePageContent", 'String'>
    readonly packages: FieldRef<"ServicePageContent", 'Json'>
    readonly qualityCompare: FieldRef<"ServicePageContent", 'Json'>
    readonly howItWorks: FieldRef<"ServicePageContent", 'Json'>
    readonly isActive: FieldRef<"ServicePageContent", 'Boolean'>
    readonly updatedAt: FieldRef<"ServicePageContent", 'DateTime'>
    readonly benefits: FieldRef<"ServicePageContent", 'Json'>
    readonly moreServicesTitle: FieldRef<"ServicePageContent", 'String'>
    readonly moreServicesHighlight: FieldRef<"ServicePageContent", 'String'>
    readonly moreServicesBody: FieldRef<"ServicePageContent", 'String'>
    readonly moreServicesButtons: FieldRef<"ServicePageContent", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ServicePageContent findUnique
   */
  export type ServicePageContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * Filter, which ServicePageContent to fetch.
     */
    where: ServicePageContentWhereUniqueInput
  }

  /**
   * ServicePageContent findUniqueOrThrow
   */
  export type ServicePageContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * Filter, which ServicePageContent to fetch.
     */
    where: ServicePageContentWhereUniqueInput
  }

  /**
   * ServicePageContent findFirst
   */
  export type ServicePageContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * Filter, which ServicePageContent to fetch.
     */
    where?: ServicePageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePageContents to fetch.
     */
    orderBy?: ServicePageContentOrderByWithRelationInput | ServicePageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePageContents.
     */
    cursor?: ServicePageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePageContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePageContents.
     */
    distinct?: ServicePageContentScalarFieldEnum | ServicePageContentScalarFieldEnum[]
  }

  /**
   * ServicePageContent findFirstOrThrow
   */
  export type ServicePageContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * Filter, which ServicePageContent to fetch.
     */
    where?: ServicePageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePageContents to fetch.
     */
    orderBy?: ServicePageContentOrderByWithRelationInput | ServicePageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePageContents.
     */
    cursor?: ServicePageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePageContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePageContents.
     */
    distinct?: ServicePageContentScalarFieldEnum | ServicePageContentScalarFieldEnum[]
  }

  /**
   * ServicePageContent findMany
   */
  export type ServicePageContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * Filter, which ServicePageContents to fetch.
     */
    where?: ServicePageContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePageContents to fetch.
     */
    orderBy?: ServicePageContentOrderByWithRelationInput | ServicePageContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePageContents.
     */
    cursor?: ServicePageContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePageContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePageContents.
     */
    skip?: number
    distinct?: ServicePageContentScalarFieldEnum | ServicePageContentScalarFieldEnum[]
  }

  /**
   * ServicePageContent create
   */
  export type ServicePageContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * The data needed to create a ServicePageContent.
     */
    data: XOR<ServicePageContentCreateInput, ServicePageContentUncheckedCreateInput>
  }

  /**
   * ServicePageContent createMany
   */
  export type ServicePageContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePageContents.
     */
    data: ServicePageContentCreateManyInput | ServicePageContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePageContent createManyAndReturn
   */
  export type ServicePageContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServicePageContents.
     */
    data: ServicePageContentCreateManyInput | ServicePageContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePageContent update
   */
  export type ServicePageContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * The data needed to update a ServicePageContent.
     */
    data: XOR<ServicePageContentUpdateInput, ServicePageContentUncheckedUpdateInput>
    /**
     * Choose, which ServicePageContent to update.
     */
    where: ServicePageContentWhereUniqueInput
  }

  /**
   * ServicePageContent updateMany
   */
  export type ServicePageContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePageContents.
     */
    data: XOR<ServicePageContentUpdateManyMutationInput, ServicePageContentUncheckedUpdateManyInput>
    /**
     * Filter which ServicePageContents to update
     */
    where?: ServicePageContentWhereInput
  }

  /**
   * ServicePageContent upsert
   */
  export type ServicePageContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * The filter to search for the ServicePageContent to update in case it exists.
     */
    where: ServicePageContentWhereUniqueInput
    /**
     * In case the ServicePageContent found by the `where` argument doesn't exist, create a new ServicePageContent with this data.
     */
    create: XOR<ServicePageContentCreateInput, ServicePageContentUncheckedCreateInput>
    /**
     * In case the ServicePageContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePageContentUpdateInput, ServicePageContentUncheckedUpdateInput>
  }

  /**
   * ServicePageContent delete
   */
  export type ServicePageContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
    /**
     * Filter which ServicePageContent to delete.
     */
    where: ServicePageContentWhereUniqueInput
  }

  /**
   * ServicePageContent deleteMany
   */
  export type ServicePageContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePageContents to delete
     */
    where?: ServicePageContentWhereInput
  }

  /**
   * ServicePageContent without action
   */
  export type ServicePageContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePageContent
     */
    select?: ServicePageContentSelect<ExtArgs> | null
  }


  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type FAQSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type FAQMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    platform: number
    serviceType: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FAQAvgAggregateInputType = {
    displayOrder?: true
  }

  export type FAQSumAggregateInputType = {
    displayOrder?: true
  }

  export type FAQMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    platform?: true
    serviceType?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    platform?: true
    serviceType?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    platform?: true
    serviceType?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FAQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FAQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _avg?: FAQAvgAggregateInputType
    _sum?: FAQSumAggregateInputType
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    id: string
    question: string
    answer: string
    category: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    displayOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    platform?: boolean
    serviceType?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    platform?: boolean
    serviceType?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    platform?: boolean
    serviceType?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      category: string | null
      platform: $Enums.Platform | null
      serviceType: $Enums.ServiceType | null
      displayOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FAQFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQFindManyArgs>(args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
     */
    create<T extends FAQCreateArgs>(args: SelectSubset<T, FAQCreateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQCreateManyArgs>(args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
     */
    delete<T extends FAQDeleteArgs>(args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQUpdateArgs>(args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQDeleteManyArgs>(args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQUpdateManyArgs>(args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQ model
   */ 
  interface FAQFieldRefs {
    readonly id: FieldRef<"FAQ", 'String'>
    readonly question: FieldRef<"FAQ", 'String'>
    readonly answer: FieldRef<"FAQ", 'String'>
    readonly category: FieldRef<"FAQ", 'String'>
    readonly platform: FieldRef<"FAQ", 'Platform'>
    readonly serviceType: FieldRef<"FAQ", 'ServiceType'>
    readonly displayOrder: FieldRef<"FAQ", 'Int'>
    readonly isActive: FieldRef<"FAQ", 'Boolean'>
    readonly createdAt: FieldRef<"FAQ", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQ", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
  }

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
  }

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    rating: number | null
    comment: string | null
    authorName: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    rating: number | null
    comment: string | null
    authorName: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    orderId: number
    rating: number
    comment: number
    authorName: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
    comment?: true
    authorName?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
    comment?: true
    authorName?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    rating?: true
    comment?: true
    authorName?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string | null
    orderId: string | null
    rating: number
    comment: string
    authorName: string | null
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    authorName?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | Review$orderArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    authorName?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | Review$orderArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    authorName?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Review$orderArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Review$orderArgs<ExtArgs>
    user?: boolean | Review$userArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      orderId: string | null
      rating: number
      comment: string
      authorName: string | null
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Review$orderArgs<ExtArgs> = {}>(args?: Subset<T, Review$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Review$userArgs<ExtArgs> = {}>(args?: Subset<T, Review$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly orderId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly authorName: FieldRef<"Review", 'String'>
    readonly isPublished: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review.order
   */
  export type Review$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Review.user
   */
  export type Review$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly tokenHash: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    rating: number | null
    displayOrder: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    rating: number | null
    displayOrder: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    handle: string | null
    text: string | null
    rating: number | null
    role: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    isApproved: boolean | null
    isFeatured: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    handle: string | null
    text: string | null
    rating: number | null
    role: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    isApproved: boolean | null
    isFeatured: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    handle: number
    text: number
    rating: number
    role: number
    platform: number
    serviceType: number
    isApproved: number
    isFeatured: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    rating?: true
    displayOrder?: true
  }

  export type TestimonialSumAggregateInputType = {
    rating?: true
    displayOrder?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    handle?: true
    text?: true
    rating?: true
    role?: true
    platform?: true
    serviceType?: true
    isApproved?: true
    isFeatured?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    handle?: true
    text?: true
    rating?: true
    role?: true
    platform?: true
    serviceType?: true
    isApproved?: true
    isFeatured?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    handle?: true
    text?: true
    rating?: true
    role?: true
    platform?: true
    serviceType?: true
    isApproved?: true
    isFeatured?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    handle: string
    text: string
    rating: number
    role: string | null
    platform: $Enums.Platform | null
    serviceType: $Enums.ServiceType | null
    isApproved: boolean
    isFeatured: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    handle?: boolean
    text?: boolean
    rating?: boolean
    role?: boolean
    platform?: boolean
    serviceType?: boolean
    isApproved?: boolean
    isFeatured?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    handle?: boolean
    text?: boolean
    rating?: boolean
    role?: boolean
    platform?: boolean
    serviceType?: boolean
    isApproved?: boolean
    isFeatured?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testimonial"]>

  export type TestimonialSelectScalar = {
    id?: boolean
    handle?: boolean
    text?: boolean
    rating?: boolean
    role?: boolean
    platform?: boolean
    serviceType?: boolean
    isApproved?: boolean
    isFeatured?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      handle: string
      text: string
      rating: number
      role: string | null
      platform: $Enums.Platform | null
      serviceType: $Enums.ServiceType | null
      isApproved: boolean
      isFeatured: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Testimonials and returns the data saved in the database.
     * @param {TestimonialCreateManyAndReturnArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Testimonials and only return the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestimonialCreateManyAndReturnArgs>(args?: SelectSubset<T, TestimonialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */ 
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly handle: FieldRef<"Testimonial", 'String'>
    readonly text: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly role: FieldRef<"Testimonial", 'String'>
    readonly platform: FieldRef<"Testimonial", 'Platform'>
    readonly serviceType: FieldRef<"Testimonial", 'ServiceType'>
    readonly isApproved: FieldRef<"Testimonial", 'Boolean'>
    readonly isFeatured: FieldRef<"Testimonial", 'Boolean'>
    readonly displayOrder: FieldRef<"Testimonial", 'Int'>
    readonly createdAt: FieldRef<"Testimonial", 'DateTime'>
    readonly updatedAt: FieldRef<"Testimonial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial createManyAndReturn
   */
  export type TestimonialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    coverImage: string | null
    authorId: string | null
    category: string | null
    metaTitle: string | null
    metaDescription: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    coverImage: string | null
    authorId: string | null
    category: string | null
    metaTitle: string | null
    metaDescription: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    excerpt: number
    coverImage: number
    authorId: number
    category: number
    metaTitle: number
    metaDescription: number
    isPublished: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    coverImage?: true
    authorId?: true
    category?: true
    metaTitle?: true
    metaDescription?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    coverImage?: true
    authorId?: true
    category?: true
    metaTitle?: true
    metaDescription?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    coverImage?: true
    authorId?: true
    category?: true
    metaTitle?: true
    metaDescription?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    excerpt: string | null
    coverImage: string | null
    authorId: string
    category: string | null
    metaTitle: string | null
    metaDescription: string | null
    isPublished: boolean
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    coverImage?: boolean
    authorId?: boolean
    category?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    coverImage?: boolean
    authorId?: boolean
    category?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    coverImage?: boolean
    authorId?: boolean
    category?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      excerpt: string | null
      coverImage: string | null
      authorId: string
      category: string | null
      metaTitle: string | null
      metaDescription: string | null
      isPublished: boolean
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */ 
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly coverImage: FieldRef<"BlogPost", 'String'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly category: FieldRef<"BlogPost", 'String'>
    readonly metaTitle: FieldRef<"BlogPost", 'String'>
    readonly metaDescription: FieldRef<"BlogPost", 'String'>
    readonly isPublished: FieldRef<"BlogPost", 'Boolean'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model LegalPage
   */

  export type AggregateLegalPage = {
    _count: LegalPageCountAggregateOutputType | null
    _min: LegalPageMinAggregateOutputType | null
    _max: LegalPageMaxAggregateOutputType | null
  }

  export type LegalPageMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    updatedAt: Date | null
  }

  export type LegalPageMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    updatedAt: Date | null
  }

  export type LegalPageCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    sections: number
    updatedAt: number
    _all: number
  }


  export type LegalPageMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    updatedAt?: true
  }

  export type LegalPageMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    updatedAt?: true
  }

  export type LegalPageCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    sections?: true
    updatedAt?: true
    _all?: true
  }

  export type LegalPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegalPage to aggregate.
     */
    where?: LegalPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalPages to fetch.
     */
    orderBy?: LegalPageOrderByWithRelationInput | LegalPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LegalPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LegalPages
    **/
    _count?: true | LegalPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LegalPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LegalPageMaxAggregateInputType
  }

  export type GetLegalPageAggregateType<T extends LegalPageAggregateArgs> = {
        [P in keyof T & keyof AggregateLegalPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegalPage[P]>
      : GetScalarType<T[P], AggregateLegalPage[P]>
  }




  export type LegalPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LegalPageWhereInput
    orderBy?: LegalPageOrderByWithAggregationInput | LegalPageOrderByWithAggregationInput[]
    by: LegalPageScalarFieldEnum[] | LegalPageScalarFieldEnum
    having?: LegalPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LegalPageCountAggregateInputType | true
    _min?: LegalPageMinAggregateInputType
    _max?: LegalPageMaxAggregateInputType
  }

  export type LegalPageGroupByOutputType = {
    id: string
    slug: string
    title: string
    sections: JsonValue
    updatedAt: Date
    _count: LegalPageCountAggregateOutputType | null
    _min: LegalPageMinAggregateOutputType | null
    _max: LegalPageMaxAggregateOutputType | null
  }

  type GetLegalPageGroupByPayload<T extends LegalPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LegalPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LegalPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LegalPageGroupByOutputType[P]>
            : GetScalarType<T[P], LegalPageGroupByOutputType[P]>
        }
      >
    >


  export type LegalPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    sections?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["legalPage"]>

  export type LegalPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    sections?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["legalPage"]>

  export type LegalPageSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    sections?: boolean
    updatedAt?: boolean
  }


  export type $LegalPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LegalPage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      sections: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["legalPage"]>
    composites: {}
  }

  type LegalPageGetPayload<S extends boolean | null | undefined | LegalPageDefaultArgs> = $Result.GetResult<Prisma.$LegalPagePayload, S>

  type LegalPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LegalPageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LegalPageCountAggregateInputType | true
    }

  export interface LegalPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LegalPage'], meta: { name: 'LegalPage' } }
    /**
     * Find zero or one LegalPage that matches the filter.
     * @param {LegalPageFindUniqueArgs} args - Arguments to find a LegalPage
     * @example
     * // Get one LegalPage
     * const legalPage = await prisma.legalPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LegalPageFindUniqueArgs>(args: SelectSubset<T, LegalPageFindUniqueArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LegalPage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LegalPageFindUniqueOrThrowArgs} args - Arguments to find a LegalPage
     * @example
     * // Get one LegalPage
     * const legalPage = await prisma.legalPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LegalPageFindUniqueOrThrowArgs>(args: SelectSubset<T, LegalPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LegalPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalPageFindFirstArgs} args - Arguments to find a LegalPage
     * @example
     * // Get one LegalPage
     * const legalPage = await prisma.legalPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LegalPageFindFirstArgs>(args?: SelectSubset<T, LegalPageFindFirstArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LegalPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalPageFindFirstOrThrowArgs} args - Arguments to find a LegalPage
     * @example
     * // Get one LegalPage
     * const legalPage = await prisma.legalPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LegalPageFindFirstOrThrowArgs>(args?: SelectSubset<T, LegalPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LegalPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LegalPages
     * const legalPages = await prisma.legalPage.findMany()
     * 
     * // Get first 10 LegalPages
     * const legalPages = await prisma.legalPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const legalPageWithIdOnly = await prisma.legalPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LegalPageFindManyArgs>(args?: SelectSubset<T, LegalPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LegalPage.
     * @param {LegalPageCreateArgs} args - Arguments to create a LegalPage.
     * @example
     * // Create one LegalPage
     * const LegalPage = await prisma.legalPage.create({
     *   data: {
     *     // ... data to create a LegalPage
     *   }
     * })
     * 
     */
    create<T extends LegalPageCreateArgs>(args: SelectSubset<T, LegalPageCreateArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LegalPages.
     * @param {LegalPageCreateManyArgs} args - Arguments to create many LegalPages.
     * @example
     * // Create many LegalPages
     * const legalPage = await prisma.legalPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LegalPageCreateManyArgs>(args?: SelectSubset<T, LegalPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LegalPages and returns the data saved in the database.
     * @param {LegalPageCreateManyAndReturnArgs} args - Arguments to create many LegalPages.
     * @example
     * // Create many LegalPages
     * const legalPage = await prisma.legalPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LegalPages and only return the `id`
     * const legalPageWithIdOnly = await prisma.legalPage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LegalPageCreateManyAndReturnArgs>(args?: SelectSubset<T, LegalPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LegalPage.
     * @param {LegalPageDeleteArgs} args - Arguments to delete one LegalPage.
     * @example
     * // Delete one LegalPage
     * const LegalPage = await prisma.legalPage.delete({
     *   where: {
     *     // ... filter to delete one LegalPage
     *   }
     * })
     * 
     */
    delete<T extends LegalPageDeleteArgs>(args: SelectSubset<T, LegalPageDeleteArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LegalPage.
     * @param {LegalPageUpdateArgs} args - Arguments to update one LegalPage.
     * @example
     * // Update one LegalPage
     * const legalPage = await prisma.legalPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LegalPageUpdateArgs>(args: SelectSubset<T, LegalPageUpdateArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LegalPages.
     * @param {LegalPageDeleteManyArgs} args - Arguments to filter LegalPages to delete.
     * @example
     * // Delete a few LegalPages
     * const { count } = await prisma.legalPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LegalPageDeleteManyArgs>(args?: SelectSubset<T, LegalPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LegalPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LegalPages
     * const legalPage = await prisma.legalPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LegalPageUpdateManyArgs>(args: SelectSubset<T, LegalPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LegalPage.
     * @param {LegalPageUpsertArgs} args - Arguments to update or create a LegalPage.
     * @example
     * // Update or create a LegalPage
     * const legalPage = await prisma.legalPage.upsert({
     *   create: {
     *     // ... data to create a LegalPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LegalPage we want to update
     *   }
     * })
     */
    upsert<T extends LegalPageUpsertArgs>(args: SelectSubset<T, LegalPageUpsertArgs<ExtArgs>>): Prisma__LegalPageClient<$Result.GetResult<Prisma.$LegalPagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LegalPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalPageCountArgs} args - Arguments to filter LegalPages to count.
     * @example
     * // Count the number of LegalPages
     * const count = await prisma.legalPage.count({
     *   where: {
     *     // ... the filter for the LegalPages we want to count
     *   }
     * })
    **/
    count<T extends LegalPageCountArgs>(
      args?: Subset<T, LegalPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LegalPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LegalPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LegalPageAggregateArgs>(args: Subset<T, LegalPageAggregateArgs>): Prisma.PrismaPromise<GetLegalPageAggregateType<T>>

    /**
     * Group by LegalPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LegalPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LegalPageGroupByArgs['orderBy'] }
        : { orderBy?: LegalPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LegalPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegalPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LegalPage model
   */
  readonly fields: LegalPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LegalPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LegalPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LegalPage model
   */ 
  interface LegalPageFieldRefs {
    readonly id: FieldRef<"LegalPage", 'String'>
    readonly slug: FieldRef<"LegalPage", 'String'>
    readonly title: FieldRef<"LegalPage", 'String'>
    readonly sections: FieldRef<"LegalPage", 'Json'>
    readonly updatedAt: FieldRef<"LegalPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LegalPage findUnique
   */
  export type LegalPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * Filter, which LegalPage to fetch.
     */
    where: LegalPageWhereUniqueInput
  }

  /**
   * LegalPage findUniqueOrThrow
   */
  export type LegalPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * Filter, which LegalPage to fetch.
     */
    where: LegalPageWhereUniqueInput
  }

  /**
   * LegalPage findFirst
   */
  export type LegalPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * Filter, which LegalPage to fetch.
     */
    where?: LegalPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalPages to fetch.
     */
    orderBy?: LegalPageOrderByWithRelationInput | LegalPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LegalPages.
     */
    cursor?: LegalPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LegalPages.
     */
    distinct?: LegalPageScalarFieldEnum | LegalPageScalarFieldEnum[]
  }

  /**
   * LegalPage findFirstOrThrow
   */
  export type LegalPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * Filter, which LegalPage to fetch.
     */
    where?: LegalPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalPages to fetch.
     */
    orderBy?: LegalPageOrderByWithRelationInput | LegalPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LegalPages.
     */
    cursor?: LegalPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LegalPages.
     */
    distinct?: LegalPageScalarFieldEnum | LegalPageScalarFieldEnum[]
  }

  /**
   * LegalPage findMany
   */
  export type LegalPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * Filter, which LegalPages to fetch.
     */
    where?: LegalPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalPages to fetch.
     */
    orderBy?: LegalPageOrderByWithRelationInput | LegalPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LegalPages.
     */
    cursor?: LegalPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalPages.
     */
    skip?: number
    distinct?: LegalPageScalarFieldEnum | LegalPageScalarFieldEnum[]
  }

  /**
   * LegalPage create
   */
  export type LegalPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * The data needed to create a LegalPage.
     */
    data: XOR<LegalPageCreateInput, LegalPageUncheckedCreateInput>
  }

  /**
   * LegalPage createMany
   */
  export type LegalPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LegalPages.
     */
    data: LegalPageCreateManyInput | LegalPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LegalPage createManyAndReturn
   */
  export type LegalPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LegalPages.
     */
    data: LegalPageCreateManyInput | LegalPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LegalPage update
   */
  export type LegalPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * The data needed to update a LegalPage.
     */
    data: XOR<LegalPageUpdateInput, LegalPageUncheckedUpdateInput>
    /**
     * Choose, which LegalPage to update.
     */
    where: LegalPageWhereUniqueInput
  }

  /**
   * LegalPage updateMany
   */
  export type LegalPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LegalPages.
     */
    data: XOR<LegalPageUpdateManyMutationInput, LegalPageUncheckedUpdateManyInput>
    /**
     * Filter which LegalPages to update
     */
    where?: LegalPageWhereInput
  }

  /**
   * LegalPage upsert
   */
  export type LegalPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * The filter to search for the LegalPage to update in case it exists.
     */
    where: LegalPageWhereUniqueInput
    /**
     * In case the LegalPage found by the `where` argument doesn't exist, create a new LegalPage with this data.
     */
    create: XOR<LegalPageCreateInput, LegalPageUncheckedCreateInput>
    /**
     * In case the LegalPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LegalPageUpdateInput, LegalPageUncheckedUpdateInput>
  }

  /**
   * LegalPage delete
   */
  export type LegalPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
    /**
     * Filter which LegalPage to delete.
     */
    where: LegalPageWhereUniqueInput
  }

  /**
   * LegalPage deleteMany
   */
  export type LegalPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegalPages to delete
     */
    where?: LegalPageWhereInput
  }

  /**
   * LegalPage without action
   */
  export type LegalPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalPage
     */
    select?: LegalPageSelect<ExtArgs> | null
  }


  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    type: string | null
    subject: string | null
    body: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    type: string | null
    subject: string | null
    body: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    type: number
    subject: number
    body: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateMinAggregateInputType = {
    id?: true
    type?: true
    subject?: true
    body?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    type?: true
    subject?: true
    body?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    type?: true
    subject?: true
    body?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    type: string
    subject: string
    body: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      subject: string
      body: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }

  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTemplateFindUniqueArgs>(args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTemplateFindFirstArgs>(args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailTemplateFindManyArgs>(args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
     */
    create<T extends EmailTemplateCreateArgs>(args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailTemplates.
     * @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTemplateCreateManyArgs>(args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTemplates and returns the data saved in the database.
     * @param {EmailTemplateCreateManyAndReturnArgs} args - Arguments to create many EmailTemplates.
     * @example
     * // Create many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTemplates and only return the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
     */
    delete<T extends EmailTemplateDeleteArgs>(args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTemplateUpdateArgs>(args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTemplateDeleteManyArgs>(args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTemplateUpdateManyArgs>(args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
     */
    upsert<T extends EmailTemplateUpsertArgs>(args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTemplate model
   */ 
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly type: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly body: FieldRef<"EmailTemplate", 'String'>
    readonly isActive: FieldRef<"EmailTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }

  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }

  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate createManyAndReturn
   */
  export type EmailTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }

  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }

  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
  }

  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
  }


  /**
   * Model BellNotification
   */

  export type AggregateBellNotification = {
    _count: BellNotificationCountAggregateOutputType | null
    _min: BellNotificationMinAggregateOutputType | null
    _max: BellNotificationMaxAggregateOutputType | null
  }

  export type BellNotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    priority: string | null
    category: string | null
    iconBg: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BellNotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    priority: string | null
    category: string | null
    iconBg: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BellNotificationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    icon: number
    priority: number
    category: number
    iconBg: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BellNotificationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    priority?: true
    category?: true
    iconBg?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BellNotificationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    priority?: true
    category?: true
    iconBg?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BellNotificationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    priority?: true
    category?: true
    iconBg?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BellNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BellNotification to aggregate.
     */
    where?: BellNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BellNotifications to fetch.
     */
    orderBy?: BellNotificationOrderByWithRelationInput | BellNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BellNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BellNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BellNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BellNotifications
    **/
    _count?: true | BellNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BellNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BellNotificationMaxAggregateInputType
  }

  export type GetBellNotificationAggregateType<T extends BellNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateBellNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBellNotification[P]>
      : GetScalarType<T[P], AggregateBellNotification[P]>
  }




  export type BellNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BellNotificationWhereInput
    orderBy?: BellNotificationOrderByWithAggregationInput | BellNotificationOrderByWithAggregationInput[]
    by: BellNotificationScalarFieldEnum[] | BellNotificationScalarFieldEnum
    having?: BellNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BellNotificationCountAggregateInputType | true
    _min?: BellNotificationMinAggregateInputType
    _max?: BellNotificationMaxAggregateInputType
  }

  export type BellNotificationGroupByOutputType = {
    id: string
    title: string
    description: string
    icon: string
    priority: string
    category: string
    iconBg: string | null
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: BellNotificationCountAggregateOutputType | null
    _min: BellNotificationMinAggregateOutputType | null
    _max: BellNotificationMaxAggregateOutputType | null
  }

  type GetBellNotificationGroupByPayload<T extends BellNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BellNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BellNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BellNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], BellNotificationGroupByOutputType[P]>
        }
      >
    >


  export type BellNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    priority?: boolean
    category?: boolean
    iconBg?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bellNotification"]>

  export type BellNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    priority?: boolean
    category?: boolean
    iconBg?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bellNotification"]>

  export type BellNotificationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    priority?: boolean
    category?: boolean
    iconBg?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BellNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BellNotification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      icon: string
      priority: string
      category: string
      iconBg: string | null
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bellNotification"]>
    composites: {}
  }

  type BellNotificationGetPayload<S extends boolean | null | undefined | BellNotificationDefaultArgs> = $Result.GetResult<Prisma.$BellNotificationPayload, S>

  type BellNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BellNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BellNotificationCountAggregateInputType | true
    }

  export interface BellNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BellNotification'], meta: { name: 'BellNotification' } }
    /**
     * Find zero or one BellNotification that matches the filter.
     * @param {BellNotificationFindUniqueArgs} args - Arguments to find a BellNotification
     * @example
     * // Get one BellNotification
     * const bellNotification = await prisma.bellNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BellNotificationFindUniqueArgs>(args: SelectSubset<T, BellNotificationFindUniqueArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BellNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BellNotificationFindUniqueOrThrowArgs} args - Arguments to find a BellNotification
     * @example
     * // Get one BellNotification
     * const bellNotification = await prisma.bellNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BellNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, BellNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BellNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BellNotificationFindFirstArgs} args - Arguments to find a BellNotification
     * @example
     * // Get one BellNotification
     * const bellNotification = await prisma.bellNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BellNotificationFindFirstArgs>(args?: SelectSubset<T, BellNotificationFindFirstArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BellNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BellNotificationFindFirstOrThrowArgs} args - Arguments to find a BellNotification
     * @example
     * // Get one BellNotification
     * const bellNotification = await prisma.bellNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BellNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, BellNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BellNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BellNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BellNotifications
     * const bellNotifications = await prisma.bellNotification.findMany()
     * 
     * // Get first 10 BellNotifications
     * const bellNotifications = await prisma.bellNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bellNotificationWithIdOnly = await prisma.bellNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BellNotificationFindManyArgs>(args?: SelectSubset<T, BellNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BellNotification.
     * @param {BellNotificationCreateArgs} args - Arguments to create a BellNotification.
     * @example
     * // Create one BellNotification
     * const BellNotification = await prisma.bellNotification.create({
     *   data: {
     *     // ... data to create a BellNotification
     *   }
     * })
     * 
     */
    create<T extends BellNotificationCreateArgs>(args: SelectSubset<T, BellNotificationCreateArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BellNotifications.
     * @param {BellNotificationCreateManyArgs} args - Arguments to create many BellNotifications.
     * @example
     * // Create many BellNotifications
     * const bellNotification = await prisma.bellNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BellNotificationCreateManyArgs>(args?: SelectSubset<T, BellNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BellNotifications and returns the data saved in the database.
     * @param {BellNotificationCreateManyAndReturnArgs} args - Arguments to create many BellNotifications.
     * @example
     * // Create many BellNotifications
     * const bellNotification = await prisma.bellNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BellNotifications and only return the `id`
     * const bellNotificationWithIdOnly = await prisma.bellNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BellNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, BellNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BellNotification.
     * @param {BellNotificationDeleteArgs} args - Arguments to delete one BellNotification.
     * @example
     * // Delete one BellNotification
     * const BellNotification = await prisma.bellNotification.delete({
     *   where: {
     *     // ... filter to delete one BellNotification
     *   }
     * })
     * 
     */
    delete<T extends BellNotificationDeleteArgs>(args: SelectSubset<T, BellNotificationDeleteArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BellNotification.
     * @param {BellNotificationUpdateArgs} args - Arguments to update one BellNotification.
     * @example
     * // Update one BellNotification
     * const bellNotification = await prisma.bellNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BellNotificationUpdateArgs>(args: SelectSubset<T, BellNotificationUpdateArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BellNotifications.
     * @param {BellNotificationDeleteManyArgs} args - Arguments to filter BellNotifications to delete.
     * @example
     * // Delete a few BellNotifications
     * const { count } = await prisma.bellNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BellNotificationDeleteManyArgs>(args?: SelectSubset<T, BellNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BellNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BellNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BellNotifications
     * const bellNotification = await prisma.bellNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BellNotificationUpdateManyArgs>(args: SelectSubset<T, BellNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BellNotification.
     * @param {BellNotificationUpsertArgs} args - Arguments to update or create a BellNotification.
     * @example
     * // Update or create a BellNotification
     * const bellNotification = await prisma.bellNotification.upsert({
     *   create: {
     *     // ... data to create a BellNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BellNotification we want to update
     *   }
     * })
     */
    upsert<T extends BellNotificationUpsertArgs>(args: SelectSubset<T, BellNotificationUpsertArgs<ExtArgs>>): Prisma__BellNotificationClient<$Result.GetResult<Prisma.$BellNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BellNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BellNotificationCountArgs} args - Arguments to filter BellNotifications to count.
     * @example
     * // Count the number of BellNotifications
     * const count = await prisma.bellNotification.count({
     *   where: {
     *     // ... the filter for the BellNotifications we want to count
     *   }
     * })
    **/
    count<T extends BellNotificationCountArgs>(
      args?: Subset<T, BellNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BellNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BellNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BellNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BellNotificationAggregateArgs>(args: Subset<T, BellNotificationAggregateArgs>): Prisma.PrismaPromise<GetBellNotificationAggregateType<T>>

    /**
     * Group by BellNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BellNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BellNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BellNotificationGroupByArgs['orderBy'] }
        : { orderBy?: BellNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BellNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBellNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BellNotification model
   */
  readonly fields: BellNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BellNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BellNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BellNotification model
   */ 
  interface BellNotificationFieldRefs {
    readonly id: FieldRef<"BellNotification", 'String'>
    readonly title: FieldRef<"BellNotification", 'String'>
    readonly description: FieldRef<"BellNotification", 'String'>
    readonly icon: FieldRef<"BellNotification", 'String'>
    readonly priority: FieldRef<"BellNotification", 'String'>
    readonly category: FieldRef<"BellNotification", 'String'>
    readonly iconBg: FieldRef<"BellNotification", 'String'>
    readonly isRead: FieldRef<"BellNotification", 'Boolean'>
    readonly createdAt: FieldRef<"BellNotification", 'DateTime'>
    readonly updatedAt: FieldRef<"BellNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BellNotification findUnique
   */
  export type BellNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * Filter, which BellNotification to fetch.
     */
    where: BellNotificationWhereUniqueInput
  }

  /**
   * BellNotification findUniqueOrThrow
   */
  export type BellNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * Filter, which BellNotification to fetch.
     */
    where: BellNotificationWhereUniqueInput
  }

  /**
   * BellNotification findFirst
   */
  export type BellNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * Filter, which BellNotification to fetch.
     */
    where?: BellNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BellNotifications to fetch.
     */
    orderBy?: BellNotificationOrderByWithRelationInput | BellNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BellNotifications.
     */
    cursor?: BellNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BellNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BellNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BellNotifications.
     */
    distinct?: BellNotificationScalarFieldEnum | BellNotificationScalarFieldEnum[]
  }

  /**
   * BellNotification findFirstOrThrow
   */
  export type BellNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * Filter, which BellNotification to fetch.
     */
    where?: BellNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BellNotifications to fetch.
     */
    orderBy?: BellNotificationOrderByWithRelationInput | BellNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BellNotifications.
     */
    cursor?: BellNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BellNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BellNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BellNotifications.
     */
    distinct?: BellNotificationScalarFieldEnum | BellNotificationScalarFieldEnum[]
  }

  /**
   * BellNotification findMany
   */
  export type BellNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * Filter, which BellNotifications to fetch.
     */
    where?: BellNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BellNotifications to fetch.
     */
    orderBy?: BellNotificationOrderByWithRelationInput | BellNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BellNotifications.
     */
    cursor?: BellNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BellNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BellNotifications.
     */
    skip?: number
    distinct?: BellNotificationScalarFieldEnum | BellNotificationScalarFieldEnum[]
  }

  /**
   * BellNotification create
   */
  export type BellNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a BellNotification.
     */
    data: XOR<BellNotificationCreateInput, BellNotificationUncheckedCreateInput>
  }

  /**
   * BellNotification createMany
   */
  export type BellNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BellNotifications.
     */
    data: BellNotificationCreateManyInput | BellNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BellNotification createManyAndReturn
   */
  export type BellNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BellNotifications.
     */
    data: BellNotificationCreateManyInput | BellNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BellNotification update
   */
  export type BellNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a BellNotification.
     */
    data: XOR<BellNotificationUpdateInput, BellNotificationUncheckedUpdateInput>
    /**
     * Choose, which BellNotification to update.
     */
    where: BellNotificationWhereUniqueInput
  }

  /**
   * BellNotification updateMany
   */
  export type BellNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BellNotifications.
     */
    data: XOR<BellNotificationUpdateManyMutationInput, BellNotificationUncheckedUpdateManyInput>
    /**
     * Filter which BellNotifications to update
     */
    where?: BellNotificationWhereInput
  }

  /**
   * BellNotification upsert
   */
  export type BellNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the BellNotification to update in case it exists.
     */
    where: BellNotificationWhereUniqueInput
    /**
     * In case the BellNotification found by the `where` argument doesn't exist, create a new BellNotification with this data.
     */
    create: XOR<BellNotificationCreateInput, BellNotificationUncheckedCreateInput>
    /**
     * In case the BellNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BellNotificationUpdateInput, BellNotificationUncheckedUpdateInput>
  }

  /**
   * BellNotification delete
   */
  export type BellNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
    /**
     * Filter which BellNotification to delete.
     */
    where: BellNotificationWhereUniqueInput
  }

  /**
   * BellNotification deleteMany
   */
  export type BellNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BellNotifications to delete
     */
    where?: BellNotificationWhereInput
  }

  /**
   * BellNotification without action
   */
  export type BellNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BellNotification
     */
    select?: BellNotificationSelect<ExtArgs> | null
  }


  /**
   * Model BannerMessage
   */

  export type AggregateBannerMessage = {
    _count: BannerMessageCountAggregateOutputType | null
    _min: BannerMessageMinAggregateOutputType | null
    _max: BannerMessageMaxAggregateOutputType | null
  }

  export type BannerMessageMinAggregateOutputType = {
    id: string | null
    text: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    icon: string | null
  }

  export type BannerMessageMaxAggregateOutputType = {
    id: string | null
    text: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    icon: string | null
  }

  export type BannerMessageCountAggregateOutputType = {
    id: number
    text: number
    isActive: number
    createdAt: number
    updatedAt: number
    icon: number
    _all: number
  }


  export type BannerMessageMinAggregateInputType = {
    id?: true
    text?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    icon?: true
  }

  export type BannerMessageMaxAggregateInputType = {
    id?: true
    text?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    icon?: true
  }

  export type BannerMessageCountAggregateInputType = {
    id?: true
    text?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    icon?: true
    _all?: true
  }

  export type BannerMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerMessage to aggregate.
     */
    where?: BannerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerMessages to fetch.
     */
    orderBy?: BannerMessageOrderByWithRelationInput | BannerMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerMessages
    **/
    _count?: true | BannerMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMessageMaxAggregateInputType
  }

  export type GetBannerMessageAggregateType<T extends BannerMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerMessage[P]>
      : GetScalarType<T[P], AggregateBannerMessage[P]>
  }




  export type BannerMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerMessageWhereInput
    orderBy?: BannerMessageOrderByWithAggregationInput | BannerMessageOrderByWithAggregationInput[]
    by: BannerMessageScalarFieldEnum[] | BannerMessageScalarFieldEnum
    having?: BannerMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerMessageCountAggregateInputType | true
    _min?: BannerMessageMinAggregateInputType
    _max?: BannerMessageMaxAggregateInputType
  }

  export type BannerMessageGroupByOutputType = {
    id: string
    text: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    icon: string
    _count: BannerMessageCountAggregateOutputType | null
    _min: BannerMessageMinAggregateOutputType | null
    _max: BannerMessageMaxAggregateOutputType | null
  }

  type GetBannerMessageGroupByPayload<T extends BannerMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerMessageGroupByOutputType[P]>
            : GetScalarType<T[P], BannerMessageGroupByOutputType[P]>
        }
      >
    >


  export type BannerMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    icon?: boolean
  }, ExtArgs["result"]["bannerMessage"]>

  export type BannerMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    icon?: boolean
  }, ExtArgs["result"]["bannerMessage"]>

  export type BannerMessageSelectScalar = {
    id?: boolean
    text?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    icon?: boolean
  }


  export type $BannerMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerMessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      icon: string
    }, ExtArgs["result"]["bannerMessage"]>
    composites: {}
  }

  type BannerMessageGetPayload<S extends boolean | null | undefined | BannerMessageDefaultArgs> = $Result.GetResult<Prisma.$BannerMessagePayload, S>

  type BannerMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BannerMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BannerMessageCountAggregateInputType | true
    }

  export interface BannerMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerMessage'], meta: { name: 'BannerMessage' } }
    /**
     * Find zero or one BannerMessage that matches the filter.
     * @param {BannerMessageFindUniqueArgs} args - Arguments to find a BannerMessage
     * @example
     * // Get one BannerMessage
     * const bannerMessage = await prisma.bannerMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerMessageFindUniqueArgs>(args: SelectSubset<T, BannerMessageFindUniqueArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BannerMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BannerMessageFindUniqueOrThrowArgs} args - Arguments to find a BannerMessage
     * @example
     * // Get one BannerMessage
     * const bannerMessage = await prisma.bannerMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BannerMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerMessageFindFirstArgs} args - Arguments to find a BannerMessage
     * @example
     * // Get one BannerMessage
     * const bannerMessage = await prisma.bannerMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerMessageFindFirstArgs>(args?: SelectSubset<T, BannerMessageFindFirstArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BannerMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerMessageFindFirstOrThrowArgs} args - Arguments to find a BannerMessage
     * @example
     * // Get one BannerMessage
     * const bannerMessage = await prisma.bannerMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BannerMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerMessages
     * const bannerMessages = await prisma.bannerMessage.findMany()
     * 
     * // Get first 10 BannerMessages
     * const bannerMessages = await prisma.bannerMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerMessageWithIdOnly = await prisma.bannerMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerMessageFindManyArgs>(args?: SelectSubset<T, BannerMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BannerMessage.
     * @param {BannerMessageCreateArgs} args - Arguments to create a BannerMessage.
     * @example
     * // Create one BannerMessage
     * const BannerMessage = await prisma.bannerMessage.create({
     *   data: {
     *     // ... data to create a BannerMessage
     *   }
     * })
     * 
     */
    create<T extends BannerMessageCreateArgs>(args: SelectSubset<T, BannerMessageCreateArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BannerMessages.
     * @param {BannerMessageCreateManyArgs} args - Arguments to create many BannerMessages.
     * @example
     * // Create many BannerMessages
     * const bannerMessage = await prisma.bannerMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerMessageCreateManyArgs>(args?: SelectSubset<T, BannerMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BannerMessages and returns the data saved in the database.
     * @param {BannerMessageCreateManyAndReturnArgs} args - Arguments to create many BannerMessages.
     * @example
     * // Create many BannerMessages
     * const bannerMessage = await prisma.bannerMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BannerMessages and only return the `id`
     * const bannerMessageWithIdOnly = await prisma.bannerMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BannerMessage.
     * @param {BannerMessageDeleteArgs} args - Arguments to delete one BannerMessage.
     * @example
     * // Delete one BannerMessage
     * const BannerMessage = await prisma.bannerMessage.delete({
     *   where: {
     *     // ... filter to delete one BannerMessage
     *   }
     * })
     * 
     */
    delete<T extends BannerMessageDeleteArgs>(args: SelectSubset<T, BannerMessageDeleteArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BannerMessage.
     * @param {BannerMessageUpdateArgs} args - Arguments to update one BannerMessage.
     * @example
     * // Update one BannerMessage
     * const bannerMessage = await prisma.bannerMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerMessageUpdateArgs>(args: SelectSubset<T, BannerMessageUpdateArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BannerMessages.
     * @param {BannerMessageDeleteManyArgs} args - Arguments to filter BannerMessages to delete.
     * @example
     * // Delete a few BannerMessages
     * const { count } = await prisma.bannerMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerMessageDeleteManyArgs>(args?: SelectSubset<T, BannerMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerMessages
     * const bannerMessage = await prisma.bannerMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerMessageUpdateManyArgs>(args: SelectSubset<T, BannerMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BannerMessage.
     * @param {BannerMessageUpsertArgs} args - Arguments to update or create a BannerMessage.
     * @example
     * // Update or create a BannerMessage
     * const bannerMessage = await prisma.bannerMessage.upsert({
     *   create: {
     *     // ... data to create a BannerMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerMessage we want to update
     *   }
     * })
     */
    upsert<T extends BannerMessageUpsertArgs>(args: SelectSubset<T, BannerMessageUpsertArgs<ExtArgs>>): Prisma__BannerMessageClient<$Result.GetResult<Prisma.$BannerMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BannerMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerMessageCountArgs} args - Arguments to filter BannerMessages to count.
     * @example
     * // Count the number of BannerMessages
     * const count = await prisma.bannerMessage.count({
     *   where: {
     *     // ... the filter for the BannerMessages we want to count
     *   }
     * })
    **/
    count<T extends BannerMessageCountArgs>(
      args?: Subset<T, BannerMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerMessageAggregateArgs>(args: Subset<T, BannerMessageAggregateArgs>): Prisma.PrismaPromise<GetBannerMessageAggregateType<T>>

    /**
     * Group by BannerMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerMessageGroupByArgs['orderBy'] }
        : { orderBy?: BannerMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerMessage model
   */
  readonly fields: BannerMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerMessage model
   */ 
  interface BannerMessageFieldRefs {
    readonly id: FieldRef<"BannerMessage", 'String'>
    readonly text: FieldRef<"BannerMessage", 'String'>
    readonly isActive: FieldRef<"BannerMessage", 'Boolean'>
    readonly createdAt: FieldRef<"BannerMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"BannerMessage", 'DateTime'>
    readonly icon: FieldRef<"BannerMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BannerMessage findUnique
   */
  export type BannerMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * Filter, which BannerMessage to fetch.
     */
    where: BannerMessageWhereUniqueInput
  }

  /**
   * BannerMessage findUniqueOrThrow
   */
  export type BannerMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * Filter, which BannerMessage to fetch.
     */
    where: BannerMessageWhereUniqueInput
  }

  /**
   * BannerMessage findFirst
   */
  export type BannerMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * Filter, which BannerMessage to fetch.
     */
    where?: BannerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerMessages to fetch.
     */
    orderBy?: BannerMessageOrderByWithRelationInput | BannerMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerMessages.
     */
    cursor?: BannerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerMessages.
     */
    distinct?: BannerMessageScalarFieldEnum | BannerMessageScalarFieldEnum[]
  }

  /**
   * BannerMessage findFirstOrThrow
   */
  export type BannerMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * Filter, which BannerMessage to fetch.
     */
    where?: BannerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerMessages to fetch.
     */
    orderBy?: BannerMessageOrderByWithRelationInput | BannerMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerMessages.
     */
    cursor?: BannerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerMessages.
     */
    distinct?: BannerMessageScalarFieldEnum | BannerMessageScalarFieldEnum[]
  }

  /**
   * BannerMessage findMany
   */
  export type BannerMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * Filter, which BannerMessages to fetch.
     */
    where?: BannerMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerMessages to fetch.
     */
    orderBy?: BannerMessageOrderByWithRelationInput | BannerMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerMessages.
     */
    cursor?: BannerMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerMessages.
     */
    skip?: number
    distinct?: BannerMessageScalarFieldEnum | BannerMessageScalarFieldEnum[]
  }

  /**
   * BannerMessage create
   */
  export type BannerMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * The data needed to create a BannerMessage.
     */
    data: XOR<BannerMessageCreateInput, BannerMessageUncheckedCreateInput>
  }

  /**
   * BannerMessage createMany
   */
  export type BannerMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerMessages.
     */
    data: BannerMessageCreateManyInput | BannerMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerMessage createManyAndReturn
   */
  export type BannerMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BannerMessages.
     */
    data: BannerMessageCreateManyInput | BannerMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerMessage update
   */
  export type BannerMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * The data needed to update a BannerMessage.
     */
    data: XOR<BannerMessageUpdateInput, BannerMessageUncheckedUpdateInput>
    /**
     * Choose, which BannerMessage to update.
     */
    where: BannerMessageWhereUniqueInput
  }

  /**
   * BannerMessage updateMany
   */
  export type BannerMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerMessages.
     */
    data: XOR<BannerMessageUpdateManyMutationInput, BannerMessageUncheckedUpdateManyInput>
    /**
     * Filter which BannerMessages to update
     */
    where?: BannerMessageWhereInput
  }

  /**
   * BannerMessage upsert
   */
  export type BannerMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * The filter to search for the BannerMessage to update in case it exists.
     */
    where: BannerMessageWhereUniqueInput
    /**
     * In case the BannerMessage found by the `where` argument doesn't exist, create a new BannerMessage with this data.
     */
    create: XOR<BannerMessageCreateInput, BannerMessageUncheckedCreateInput>
    /**
     * In case the BannerMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerMessageUpdateInput, BannerMessageUncheckedUpdateInput>
  }

  /**
   * BannerMessage delete
   */
  export type BannerMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
    /**
     * Filter which BannerMessage to delete.
     */
    where: BannerMessageWhereUniqueInput
  }

  /**
   * BannerMessage deleteMany
   */
  export type BannerMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerMessages to delete
     */
    where?: BannerMessageWhereInput
  }

  /**
   * BannerMessage without action
   */
  export type BannerMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerMessage
     */
    select?: BannerMessageSelect<ExtArgs> | null
  }


  /**
   * Model IconAsset
   */

  export type AggregateIconAsset = {
    _count: IconAssetCountAggregateOutputType | null
    _avg: IconAssetAvgAggregateOutputType | null
    _sum: IconAssetSumAggregateOutputType | null
    _min: IconAssetMinAggregateOutputType | null
    _max: IconAssetMaxAggregateOutputType | null
  }

  export type IconAssetAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type IconAssetSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type IconAssetMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    url: string | null
    alt: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IconAssetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    url: string | null
    alt: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IconAssetCountAggregateOutputType = {
    id: number
    name: number
    category: number
    url: number
    alt: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IconAssetAvgAggregateInputType = {
    displayOrder?: true
  }

  export type IconAssetSumAggregateInputType = {
    displayOrder?: true
  }

  export type IconAssetMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    url?: true
    alt?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IconAssetMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    url?: true
    alt?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IconAssetCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    url?: true
    alt?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IconAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IconAsset to aggregate.
     */
    where?: IconAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IconAssets to fetch.
     */
    orderBy?: IconAssetOrderByWithRelationInput | IconAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IconAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IconAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IconAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IconAssets
    **/
    _count?: true | IconAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IconAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IconAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IconAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IconAssetMaxAggregateInputType
  }

  export type GetIconAssetAggregateType<T extends IconAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateIconAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIconAsset[P]>
      : GetScalarType<T[P], AggregateIconAsset[P]>
  }




  export type IconAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IconAssetWhereInput
    orderBy?: IconAssetOrderByWithAggregationInput | IconAssetOrderByWithAggregationInput[]
    by: IconAssetScalarFieldEnum[] | IconAssetScalarFieldEnum
    having?: IconAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IconAssetCountAggregateInputType | true
    _avg?: IconAssetAvgAggregateInputType
    _sum?: IconAssetSumAggregateInputType
    _min?: IconAssetMinAggregateInputType
    _max?: IconAssetMaxAggregateInputType
  }

  export type IconAssetGroupByOutputType = {
    id: string
    name: string
    category: string | null
    url: string | null
    alt: string | null
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: IconAssetCountAggregateOutputType | null
    _avg: IconAssetAvgAggregateOutputType | null
    _sum: IconAssetSumAggregateOutputType | null
    _min: IconAssetMinAggregateOutputType | null
    _max: IconAssetMaxAggregateOutputType | null
  }

  type GetIconAssetGroupByPayload<T extends IconAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IconAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IconAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IconAssetGroupByOutputType[P]>
            : GetScalarType<T[P], IconAssetGroupByOutputType[P]>
        }
      >
    >


  export type IconAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    url?: boolean
    alt?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["iconAsset"]>

  export type IconAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    url?: boolean
    alt?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["iconAsset"]>

  export type IconAssetSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    url?: boolean
    alt?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $IconAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IconAsset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      url: string | null
      alt: string | null
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["iconAsset"]>
    composites: {}
  }

  type IconAssetGetPayload<S extends boolean | null | undefined | IconAssetDefaultArgs> = $Result.GetResult<Prisma.$IconAssetPayload, S>

  type IconAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IconAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IconAssetCountAggregateInputType | true
    }

  export interface IconAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IconAsset'], meta: { name: 'IconAsset' } }
    /**
     * Find zero or one IconAsset that matches the filter.
     * @param {IconAssetFindUniqueArgs} args - Arguments to find a IconAsset
     * @example
     * // Get one IconAsset
     * const iconAsset = await prisma.iconAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IconAssetFindUniqueArgs>(args: SelectSubset<T, IconAssetFindUniqueArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IconAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IconAssetFindUniqueOrThrowArgs} args - Arguments to find a IconAsset
     * @example
     * // Get one IconAsset
     * const iconAsset = await prisma.iconAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IconAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, IconAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IconAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAssetFindFirstArgs} args - Arguments to find a IconAsset
     * @example
     * // Get one IconAsset
     * const iconAsset = await prisma.iconAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IconAssetFindFirstArgs>(args?: SelectSubset<T, IconAssetFindFirstArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IconAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAssetFindFirstOrThrowArgs} args - Arguments to find a IconAsset
     * @example
     * // Get one IconAsset
     * const iconAsset = await prisma.iconAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IconAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, IconAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IconAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IconAssets
     * const iconAssets = await prisma.iconAsset.findMany()
     * 
     * // Get first 10 IconAssets
     * const iconAssets = await prisma.iconAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iconAssetWithIdOnly = await prisma.iconAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IconAssetFindManyArgs>(args?: SelectSubset<T, IconAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IconAsset.
     * @param {IconAssetCreateArgs} args - Arguments to create a IconAsset.
     * @example
     * // Create one IconAsset
     * const IconAsset = await prisma.iconAsset.create({
     *   data: {
     *     // ... data to create a IconAsset
     *   }
     * })
     * 
     */
    create<T extends IconAssetCreateArgs>(args: SelectSubset<T, IconAssetCreateArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IconAssets.
     * @param {IconAssetCreateManyArgs} args - Arguments to create many IconAssets.
     * @example
     * // Create many IconAssets
     * const iconAsset = await prisma.iconAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IconAssetCreateManyArgs>(args?: SelectSubset<T, IconAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IconAssets and returns the data saved in the database.
     * @param {IconAssetCreateManyAndReturnArgs} args - Arguments to create many IconAssets.
     * @example
     * // Create many IconAssets
     * const iconAsset = await prisma.iconAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IconAssets and only return the `id`
     * const iconAssetWithIdOnly = await prisma.iconAsset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IconAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, IconAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IconAsset.
     * @param {IconAssetDeleteArgs} args - Arguments to delete one IconAsset.
     * @example
     * // Delete one IconAsset
     * const IconAsset = await prisma.iconAsset.delete({
     *   where: {
     *     // ... filter to delete one IconAsset
     *   }
     * })
     * 
     */
    delete<T extends IconAssetDeleteArgs>(args: SelectSubset<T, IconAssetDeleteArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IconAsset.
     * @param {IconAssetUpdateArgs} args - Arguments to update one IconAsset.
     * @example
     * // Update one IconAsset
     * const iconAsset = await prisma.iconAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IconAssetUpdateArgs>(args: SelectSubset<T, IconAssetUpdateArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IconAssets.
     * @param {IconAssetDeleteManyArgs} args - Arguments to filter IconAssets to delete.
     * @example
     * // Delete a few IconAssets
     * const { count } = await prisma.iconAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IconAssetDeleteManyArgs>(args?: SelectSubset<T, IconAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IconAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IconAssets
     * const iconAsset = await prisma.iconAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IconAssetUpdateManyArgs>(args: SelectSubset<T, IconAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IconAsset.
     * @param {IconAssetUpsertArgs} args - Arguments to update or create a IconAsset.
     * @example
     * // Update or create a IconAsset
     * const iconAsset = await prisma.iconAsset.upsert({
     *   create: {
     *     // ... data to create a IconAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IconAsset we want to update
     *   }
     * })
     */
    upsert<T extends IconAssetUpsertArgs>(args: SelectSubset<T, IconAssetUpsertArgs<ExtArgs>>): Prisma__IconAssetClient<$Result.GetResult<Prisma.$IconAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IconAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAssetCountArgs} args - Arguments to filter IconAssets to count.
     * @example
     * // Count the number of IconAssets
     * const count = await prisma.iconAsset.count({
     *   where: {
     *     // ... the filter for the IconAssets we want to count
     *   }
     * })
    **/
    count<T extends IconAssetCountArgs>(
      args?: Subset<T, IconAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IconAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IconAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IconAssetAggregateArgs>(args: Subset<T, IconAssetAggregateArgs>): Prisma.PrismaPromise<GetIconAssetAggregateType<T>>

    /**
     * Group by IconAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IconAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IconAssetGroupByArgs['orderBy'] }
        : { orderBy?: IconAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IconAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIconAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IconAsset model
   */
  readonly fields: IconAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IconAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IconAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IconAsset model
   */ 
  interface IconAssetFieldRefs {
    readonly id: FieldRef<"IconAsset", 'String'>
    readonly name: FieldRef<"IconAsset", 'String'>
    readonly category: FieldRef<"IconAsset", 'String'>
    readonly url: FieldRef<"IconAsset", 'String'>
    readonly alt: FieldRef<"IconAsset", 'String'>
    readonly displayOrder: FieldRef<"IconAsset", 'Int'>
    readonly createdAt: FieldRef<"IconAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"IconAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IconAsset findUnique
   */
  export type IconAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * Filter, which IconAsset to fetch.
     */
    where: IconAssetWhereUniqueInput
  }

  /**
   * IconAsset findUniqueOrThrow
   */
  export type IconAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * Filter, which IconAsset to fetch.
     */
    where: IconAssetWhereUniqueInput
  }

  /**
   * IconAsset findFirst
   */
  export type IconAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * Filter, which IconAsset to fetch.
     */
    where?: IconAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IconAssets to fetch.
     */
    orderBy?: IconAssetOrderByWithRelationInput | IconAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IconAssets.
     */
    cursor?: IconAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IconAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IconAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IconAssets.
     */
    distinct?: IconAssetScalarFieldEnum | IconAssetScalarFieldEnum[]
  }

  /**
   * IconAsset findFirstOrThrow
   */
  export type IconAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * Filter, which IconAsset to fetch.
     */
    where?: IconAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IconAssets to fetch.
     */
    orderBy?: IconAssetOrderByWithRelationInput | IconAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IconAssets.
     */
    cursor?: IconAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IconAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IconAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IconAssets.
     */
    distinct?: IconAssetScalarFieldEnum | IconAssetScalarFieldEnum[]
  }

  /**
   * IconAsset findMany
   */
  export type IconAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * Filter, which IconAssets to fetch.
     */
    where?: IconAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IconAssets to fetch.
     */
    orderBy?: IconAssetOrderByWithRelationInput | IconAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IconAssets.
     */
    cursor?: IconAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IconAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IconAssets.
     */
    skip?: number
    distinct?: IconAssetScalarFieldEnum | IconAssetScalarFieldEnum[]
  }

  /**
   * IconAsset create
   */
  export type IconAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * The data needed to create a IconAsset.
     */
    data: XOR<IconAssetCreateInput, IconAssetUncheckedCreateInput>
  }

  /**
   * IconAsset createMany
   */
  export type IconAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IconAssets.
     */
    data: IconAssetCreateManyInput | IconAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IconAsset createManyAndReturn
   */
  export type IconAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IconAssets.
     */
    data: IconAssetCreateManyInput | IconAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IconAsset update
   */
  export type IconAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * The data needed to update a IconAsset.
     */
    data: XOR<IconAssetUpdateInput, IconAssetUncheckedUpdateInput>
    /**
     * Choose, which IconAsset to update.
     */
    where: IconAssetWhereUniqueInput
  }

  /**
   * IconAsset updateMany
   */
  export type IconAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IconAssets.
     */
    data: XOR<IconAssetUpdateManyMutationInput, IconAssetUncheckedUpdateManyInput>
    /**
     * Filter which IconAssets to update
     */
    where?: IconAssetWhereInput
  }

  /**
   * IconAsset upsert
   */
  export type IconAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * The filter to search for the IconAsset to update in case it exists.
     */
    where: IconAssetWhereUniqueInput
    /**
     * In case the IconAsset found by the `where` argument doesn't exist, create a new IconAsset with this data.
     */
    create: XOR<IconAssetCreateInput, IconAssetUncheckedCreateInput>
    /**
     * In case the IconAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IconAssetUpdateInput, IconAssetUncheckedUpdateInput>
  }

  /**
   * IconAsset delete
   */
  export type IconAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
    /**
     * Filter which IconAsset to delete.
     */
    where: IconAssetWhereUniqueInput
  }

  /**
   * IconAsset deleteMany
   */
  export type IconAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IconAssets to delete
     */
    where?: IconAssetWhereInput
  }

  /**
   * IconAsset without action
   */
  export type IconAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconAsset
     */
    select?: IconAssetSelect<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    value: number | null
    maxRedemptions: number | null
    maxRedemptionsPerUser: number | null
    minOrderAmount: number | null
  }

  export type CouponSumAggregateOutputType = {
    value: number | null
    maxRedemptions: number | null
    maxRedemptionsPerUser: number | null
    minOrderAmount: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.CouponType | null
    value: number | null
    currency: string | null
    status: $Enums.CouponStatus | null
    startsAt: Date | null
    expiresAt: Date | null
    maxRedemptions: number | null
    maxRedemptionsPerUser: number | null
    minOrderAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.CouponType | null
    value: number | null
    currency: string | null
    status: $Enums.CouponStatus | null
    startsAt: Date | null
    expiresAt: Date | null
    maxRedemptions: number | null
    maxRedemptionsPerUser: number | null
    minOrderAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    type: number
    value: number
    currency: number
    status: number
    startsAt: number
    expiresAt: number
    maxRedemptions: number
    maxRedemptionsPerUser: number
    minOrderAmount: number
    applicableServices: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    value?: true
    maxRedemptions?: true
    maxRedemptionsPerUser?: true
    minOrderAmount?: true
  }

  export type CouponSumAggregateInputType = {
    value?: true
    maxRedemptions?: true
    maxRedemptionsPerUser?: true
    minOrderAmount?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    type?: true
    value?: true
    currency?: true
    status?: true
    startsAt?: true
    expiresAt?: true
    maxRedemptions?: true
    maxRedemptionsPerUser?: true
    minOrderAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    type?: true
    value?: true
    currency?: true
    status?: true
    startsAt?: true
    expiresAt?: true
    maxRedemptions?: true
    maxRedemptionsPerUser?: true
    minOrderAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    type?: true
    value?: true
    currency?: true
    status?: true
    startsAt?: true
    expiresAt?: true
    maxRedemptions?: true
    maxRedemptionsPerUser?: true
    minOrderAmount?: true
    applicableServices?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    type: $Enums.CouponType
    value: number
    currency: string | null
    status: $Enums.CouponStatus
    startsAt: Date | null
    expiresAt: Date | null
    maxRedemptions: number | null
    maxRedemptionsPerUser: number | null
    minOrderAmount: number | null
    applicableServices: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    value?: boolean
    currency?: boolean
    status?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    maxRedemptions?: boolean
    maxRedemptionsPerUser?: boolean
    minOrderAmount?: boolean
    applicableServices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    redemptions?: boolean | Coupon$redemptionsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    value?: boolean
    currency?: boolean
    status?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    maxRedemptions?: boolean
    maxRedemptionsPerUser?: boolean
    minOrderAmount?: boolean
    applicableServices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    code?: boolean
    type?: boolean
    value?: boolean
    currency?: boolean
    status?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    maxRedemptions?: boolean
    maxRedemptionsPerUser?: boolean
    minOrderAmount?: boolean
    applicableServices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | Coupon$redemptionsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      redemptions: Prisma.$CouponRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      type: $Enums.CouponType
      value: number
      currency: string | null
      status: $Enums.CouponStatus
      startsAt: Date | null
      expiresAt: Date | null
      maxRedemptions: number | null
      maxRedemptionsPerUser: number | null
      minOrderAmount: number | null
      applicableServices: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redemptions<T extends Coupon$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */ 
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly type: FieldRef<"Coupon", 'CouponType'>
    readonly value: FieldRef<"Coupon", 'Float'>
    readonly currency: FieldRef<"Coupon", 'String'>
    readonly status: FieldRef<"Coupon", 'CouponStatus'>
    readonly startsAt: FieldRef<"Coupon", 'DateTime'>
    readonly expiresAt: FieldRef<"Coupon", 'DateTime'>
    readonly maxRedemptions: FieldRef<"Coupon", 'Int'>
    readonly maxRedemptionsPerUser: FieldRef<"Coupon", 'Int'>
    readonly minOrderAmount: FieldRef<"Coupon", 'Float'>
    readonly applicableServices: FieldRef<"Coupon", 'Json'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon.redemptions
   */
  export type Coupon$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    cursor?: CouponRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model CouponRedemption
   */

  export type AggregateCouponRedemption = {
    _count: CouponRedemptionCountAggregateOutputType | null
    _min: CouponRedemptionMinAggregateOutputType | null
    _max: CouponRedemptionMaxAggregateOutputType | null
  }

  export type CouponRedemptionMinAggregateOutputType = {
    id: string | null
    couponId: string | null
    userId: string | null
    orderId: string | null
    redeemedAt: Date | null
  }

  export type CouponRedemptionMaxAggregateOutputType = {
    id: string | null
    couponId: string | null
    userId: string | null
    orderId: string | null
    redeemedAt: Date | null
  }

  export type CouponRedemptionCountAggregateOutputType = {
    id: number
    couponId: number
    userId: number
    orderId: number
    redeemedAt: number
    _all: number
  }


  export type CouponRedemptionMinAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    orderId?: true
    redeemedAt?: true
  }

  export type CouponRedemptionMaxAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    orderId?: true
    redeemedAt?: true
  }

  export type CouponRedemptionCountAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    orderId?: true
    redeemedAt?: true
    _all?: true
  }

  export type CouponRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouponRedemption to aggregate.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CouponRedemptions
    **/
    _count?: true | CouponRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponRedemptionMaxAggregateInputType
  }

  export type GetCouponRedemptionAggregateType<T extends CouponRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCouponRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouponRedemption[P]>
      : GetScalarType<T[P], AggregateCouponRedemption[P]>
  }




  export type CouponRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithAggregationInput | CouponRedemptionOrderByWithAggregationInput[]
    by: CouponRedemptionScalarFieldEnum[] | CouponRedemptionScalarFieldEnum
    having?: CouponRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponRedemptionCountAggregateInputType | true
    _min?: CouponRedemptionMinAggregateInputType
    _max?: CouponRedemptionMaxAggregateInputType
  }

  export type CouponRedemptionGroupByOutputType = {
    id: string
    couponId: string
    userId: string | null
    orderId: string | null
    redeemedAt: Date
    _count: CouponRedemptionCountAggregateOutputType | null
    _min: CouponRedemptionMinAggregateOutputType | null
    _max: CouponRedemptionMaxAggregateOutputType | null
  }

  type GetCouponRedemptionGroupByPayload<T extends CouponRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], CouponRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type CouponRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponId?: boolean
    userId?: boolean
    orderId?: boolean
    redeemedAt?: boolean
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couponRedemption"]>

  export type CouponRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponId?: boolean
    userId?: boolean
    orderId?: boolean
    redeemedAt?: boolean
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couponRedemption"]>

  export type CouponRedemptionSelectScalar = {
    id?: boolean
    couponId?: boolean
    userId?: boolean
    orderId?: boolean
    redeemedAt?: boolean
  }

  export type CouponRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }
  export type CouponRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
  }

  export type $CouponRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CouponRedemption"
    objects: {
      coupon: Prisma.$CouponPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      couponId: string
      userId: string | null
      orderId: string | null
      redeemedAt: Date
    }, ExtArgs["result"]["couponRedemption"]>
    composites: {}
  }

  type CouponRedemptionGetPayload<S extends boolean | null | undefined | CouponRedemptionDefaultArgs> = $Result.GetResult<Prisma.$CouponRedemptionPayload, S>

  type CouponRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CouponRedemptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CouponRedemptionCountAggregateInputType | true
    }

  export interface CouponRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CouponRedemption'], meta: { name: 'CouponRedemption' } }
    /**
     * Find zero or one CouponRedemption that matches the filter.
     * @param {CouponRedemptionFindUniqueArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponRedemptionFindUniqueArgs>(args: SelectSubset<T, CouponRedemptionFindUniqueArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CouponRedemption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CouponRedemptionFindUniqueOrThrowArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CouponRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindFirstArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponRedemptionFindFirstArgs>(args?: SelectSubset<T, CouponRedemptionFindFirstArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CouponRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindFirstOrThrowArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CouponRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CouponRedemptions
     * const couponRedemptions = await prisma.couponRedemption.findMany()
     * 
     * // Get first 10 CouponRedemptions
     * const couponRedemptions = await prisma.couponRedemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponRedemptionWithIdOnly = await prisma.couponRedemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponRedemptionFindManyArgs>(args?: SelectSubset<T, CouponRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CouponRedemption.
     * @param {CouponRedemptionCreateArgs} args - Arguments to create a CouponRedemption.
     * @example
     * // Create one CouponRedemption
     * const CouponRedemption = await prisma.couponRedemption.create({
     *   data: {
     *     // ... data to create a CouponRedemption
     *   }
     * })
     * 
     */
    create<T extends CouponRedemptionCreateArgs>(args: SelectSubset<T, CouponRedemptionCreateArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CouponRedemptions.
     * @param {CouponRedemptionCreateManyArgs} args - Arguments to create many CouponRedemptions.
     * @example
     * // Create many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponRedemptionCreateManyArgs>(args?: SelectSubset<T, CouponRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CouponRedemptions and returns the data saved in the database.
     * @param {CouponRedemptionCreateManyAndReturnArgs} args - Arguments to create many CouponRedemptions.
     * @example
     * // Create many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CouponRedemptions and only return the `id`
     * const couponRedemptionWithIdOnly = await prisma.couponRedemption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CouponRedemption.
     * @param {CouponRedemptionDeleteArgs} args - Arguments to delete one CouponRedemption.
     * @example
     * // Delete one CouponRedemption
     * const CouponRedemption = await prisma.couponRedemption.delete({
     *   where: {
     *     // ... filter to delete one CouponRedemption
     *   }
     * })
     * 
     */
    delete<T extends CouponRedemptionDeleteArgs>(args: SelectSubset<T, CouponRedemptionDeleteArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CouponRedemption.
     * @param {CouponRedemptionUpdateArgs} args - Arguments to update one CouponRedemption.
     * @example
     * // Update one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponRedemptionUpdateArgs>(args: SelectSubset<T, CouponRedemptionUpdateArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CouponRedemptions.
     * @param {CouponRedemptionDeleteManyArgs} args - Arguments to filter CouponRedemptions to delete.
     * @example
     * // Delete a few CouponRedemptions
     * const { count } = await prisma.couponRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponRedemptionDeleteManyArgs>(args?: SelectSubset<T, CouponRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CouponRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponRedemptionUpdateManyArgs>(args: SelectSubset<T, CouponRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CouponRedemption.
     * @param {CouponRedemptionUpsertArgs} args - Arguments to update or create a CouponRedemption.
     * @example
     * // Update or create a CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.upsert({
     *   create: {
     *     // ... data to create a CouponRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CouponRedemption we want to update
     *   }
     * })
     */
    upsert<T extends CouponRedemptionUpsertArgs>(args: SelectSubset<T, CouponRedemptionUpsertArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CouponRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionCountArgs} args - Arguments to filter CouponRedemptions to count.
     * @example
     * // Count the number of CouponRedemptions
     * const count = await prisma.couponRedemption.count({
     *   where: {
     *     // ... the filter for the CouponRedemptions we want to count
     *   }
     * })
    **/
    count<T extends CouponRedemptionCountArgs>(
      args?: Subset<T, CouponRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CouponRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponRedemptionAggregateArgs>(args: Subset<T, CouponRedemptionAggregateArgs>): Prisma.PrismaPromise<GetCouponRedemptionAggregateType<T>>

    /**
     * Group by CouponRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: CouponRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CouponRedemption model
   */
  readonly fields: CouponRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CouponRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coupon<T extends CouponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CouponDefaultArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CouponRedemption model
   */ 
  interface CouponRedemptionFieldRefs {
    readonly id: FieldRef<"CouponRedemption", 'String'>
    readonly couponId: FieldRef<"CouponRedemption", 'String'>
    readonly userId: FieldRef<"CouponRedemption", 'String'>
    readonly orderId: FieldRef<"CouponRedemption", 'String'>
    readonly redeemedAt: FieldRef<"CouponRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CouponRedemption findUnique
   */
  export type CouponRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption findUniqueOrThrow
   */
  export type CouponRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption findFirst
   */
  export type CouponRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouponRedemptions.
     */
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption findFirstOrThrow
   */
  export type CouponRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouponRedemptions.
     */
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption findMany
   */
  export type CouponRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemptions to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption create
   */
  export type CouponRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a CouponRedemption.
     */
    data: XOR<CouponRedemptionCreateInput, CouponRedemptionUncheckedCreateInput>
  }

  /**
   * CouponRedemption createMany
   */
  export type CouponRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CouponRedemptions.
     */
    data: CouponRedemptionCreateManyInput | CouponRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CouponRedemption createManyAndReturn
   */
  export type CouponRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CouponRedemptions.
     */
    data: CouponRedemptionCreateManyInput | CouponRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CouponRedemption update
   */
  export type CouponRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a CouponRedemption.
     */
    data: XOR<CouponRedemptionUpdateInput, CouponRedemptionUncheckedUpdateInput>
    /**
     * Choose, which CouponRedemption to update.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption updateMany
   */
  export type CouponRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CouponRedemptions.
     */
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which CouponRedemptions to update
     */
    where?: CouponRedemptionWhereInput
  }

  /**
   * CouponRedemption upsert
   */
  export type CouponRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the CouponRedemption to update in case it exists.
     */
    where: CouponRedemptionWhereUniqueInput
    /**
     * In case the CouponRedemption found by the `where` argument doesn't exist, create a new CouponRedemption with this data.
     */
    create: XOR<CouponRedemptionCreateInput, CouponRedemptionUncheckedCreateInput>
    /**
     * In case the CouponRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponRedemptionUpdateInput, CouponRedemptionUncheckedUpdateInput>
  }

  /**
   * CouponRedemption delete
   */
  export type CouponRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter which CouponRedemption to delete.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption deleteMany
   */
  export type CouponRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouponRedemptions to delete
     */
    where?: CouponRedemptionWhereInput
  }

  /**
   * CouponRedemption without action
   */
  export type CouponRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    isBlocked: 'isBlocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    avatarUrl: 'avatarUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    platform: 'platform',
    serviceType: 'serviceType',
    quantity: 'quantity',
    price: 'price',
    currency: 'currency',
    status: 'status',
    link: 'link',
    japOrderId: 'japOrderId',
    japStatus: 'japStatus',
    upsellData: 'upsellData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    platform: 'platform',
    serviceType: 'serviceType',
    japServiceId: 'japServiceId',
    basePrice: 'basePrice',
    markup: 'markup',
    finalPrice: 'finalPrice',
    minQuantity: 'minQuantity',
    maxQuantity: 'maxQuantity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    gateway: 'gateway',
    transactionId: 'transactionId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    webhookData: 'webhookData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const UpsellScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    serviceId: 'serviceId',
    packageId: 'packageId',
    basePrice: 'basePrice',
    discountType: 'discountType',
    discountValue: 'discountValue',
    badgeText: 'badgeText',
    badgeColor: 'badgeColor',
    badgeIcon: 'badgeIcon',
    platform: 'platform',
    serviceType: 'serviceType',
    minSubtotal: 'minSubtotal',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UpsellScalarFieldEnum = (typeof UpsellScalarFieldEnum)[keyof typeof UpsellScalarFieldEnum]


  export const SocialProfileScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    username: 'username',
    profileData: 'profileData',
    posts: 'posts',
    cachedAt: 'cachedAt',
    expiresAt: 'expiresAt'
  };

  export type SocialProfileScalarFieldEnum = (typeof SocialProfileScalarFieldEnum)[keyof typeof SocialProfileScalarFieldEnum]


  export const SocialProofScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    username: 'username',
    service: 'service',
    timeText: 'timeText',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialProofScalarFieldEnum = (typeof SocialProofScalarFieldEnum)[keyof typeof SocialProofScalarFieldEnum]


  export const AdminSettingsScalarFieldEnum: {
    id: 'id',
    japApiUrl: 'japApiUrl',
    japApiKey: 'japApiKey',
    checkoutApiKey: 'checkoutApiKey',
    checkoutWebhookSecret: 'checkoutWebhookSecret',
    bigPayMeApiKey: 'bigPayMeApiKey',
    bigPayMeWebhookSecret: 'bigPayMeWebhookSecret',
    rapidApiKey: 'rapidApiKey',
    rapidApiInstagramHost: 'rapidApiInstagramHost',
    rapidApiTikTokHost: 'rapidApiTikTokHost',
    rapidApiYouTubeHost: 'rapidApiYouTubeHost',
    smtpHost: 'smtpHost',
    smtpPort: 'smtpPort',
    smtpSecure: 'smtpSecure',
    smtpUser: 'smtpUser',
    smtpPass: 'smtpPass',
    smtpFrom: 'smtpFrom',
    defaultCurrency: 'defaultCurrency',
    cryptomusMerchantId: 'cryptomusMerchantId',
    cryptomusApiKey: 'cryptomusApiKey',
    cryptomusDisplayName: 'cryptomusDisplayName',
    cryptomusTestMode: 'cryptomusTestMode',
    bigPayMerchantId: 'bigPayMerchantId',
    bigPayDisplayName: 'bigPayDisplayName',
    bigPayApiSecret: 'bigPayApiSecret',
    bigPayTestMode: 'bigPayTestMode',
    exitIntentEnabled: 'exitIntentEnabled',
    exitIntentTitle: 'exitIntentTitle',
    exitIntentSubtitle: 'exitIntentSubtitle',
    exitIntentDiscountCode: 'exitIntentDiscountCode',
    newServiceIndicator: 'newServiceIndicator',
    supportEmail: 'supportEmail',
    updatedAt: 'updatedAt',
    bannerDurationHours: 'bannerDurationHours',
    bannerEnabled: 'bannerEnabled',
    inboxCount: 'inboxCount',
    teamCount: 'teamCount',
    faviconUrl: 'faviconUrl',
    footerLogoUrl: 'footerLogoUrl',
    headerLogoUrl: 'headerLogoUrl',
    homeMetaDescription: 'homeMetaDescription',
    homeMetaTitle: 'homeMetaTitle',
    robotsTxtContent: 'robotsTxtContent',
    recaptchaSecretKey: 'recaptchaSecretKey',
    recaptchaSiteKey: 'recaptchaSiteKey',
    googleClientId: 'googleClientId',
    googleClientSecret: 'googleClientSecret',
    facebookClientId: 'facebookClientId',
    facebookClientSecret: 'facebookClientSecret',
    myFatoorahToken: 'myFatoorahToken',
    myFatoorahBaseURL: 'myFatoorahBaseURL',
    myFatoorahTestMode: 'myFatoorahTestMode',
    myFatoorahWebhookSecret: 'myFatoorahWebhookSecret'
  };

  export type AdminSettingsScalarFieldEnum = (typeof AdminSettingsScalarFieldEnum)[keyof typeof AdminSettingsScalarFieldEnum]


  export const HomepageContentScalarFieldEnum: {
    id: 'id',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    heroRating: 'heroRating',
    heroReviewCount: 'heroReviewCount',
    heroCtaButtons: 'heroCtaButtons',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    benefits: 'benefits',
    heroProfileEngagement: 'heroProfileEngagement',
    heroProfileFollowers: 'heroProfileFollowers',
    heroProfileHandle: 'heroProfileHandle',
    heroProfileLikes: 'heroProfileLikes',
    heroProfileRole: 'heroProfileRole',
    influenceSubtitle: 'influenceSubtitle',
    influenceTitle: 'influenceTitle',
    platformSubtitle: 'platformSubtitle',
    platformTitle: 'platformTitle',
    quickStartDescription1: 'quickStartDescription1',
    quickStartDescription2: 'quickStartDescription2',
    quickStartTitle: 'quickStartTitle',
    whyChooseSubtitle: 'whyChooseSubtitle',
    whyChooseTitle: 'whyChooseTitle',
    platformCards: 'platformCards',
    heroProfileImage: 'heroProfileImage',
    influenceImage: 'influenceImage',
    influenceSteps: 'influenceSteps',
    quickStartButtons: 'quickStartButtons'
  };

  export type HomepageContentScalarFieldEnum = (typeof HomepageContentScalarFieldEnum)[keyof typeof HomepageContentScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    description: 'description',
    twitterUrl: 'twitterUrl',
    linkedinUrl: 'linkedinUrl',
    avatarUrl: 'avatarUrl',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const HeroSocialUpdateScalarFieldEnum: {
    id: 'id',
    handle: 'handle',
    item: 'item',
    time: 'time',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type HeroSocialUpdateScalarFieldEnum = (typeof HeroSocialUpdateScalarFieldEnum)[keyof typeof HeroSocialUpdateScalarFieldEnum]


  export const PromoBarScalarFieldEnum: {
    id: 'id',
    messages: 'messages',
    countdownSeconds: 'countdownSeconds',
    isVisible: 'isVisible',
    displayOrder: 'displayOrder',
    updatedAt: 'updatedAt'
  };

  export type PromoBarScalarFieldEnum = (typeof PromoBarScalarFieldEnum)[keyof typeof PromoBarScalarFieldEnum]


  export const FeaturedOnScalarFieldEnum: {
    id: 'id',
    brandName: 'brandName',
    logoUrl: 'logoUrl',
    displayOrder: 'displayOrder',
    isActive: 'isActive'
  };

  export type FeaturedOnScalarFieldEnum = (typeof FeaturedOnScalarFieldEnum)[keyof typeof FeaturedOnScalarFieldEnum]


  export const FeaturedOnPageLinkScalarFieldEnum: {
    id: 'id',
    featuredOnId: 'featuredOnId',
    pagePath: 'pagePath',
    link: 'link',
    nofollow: 'nofollow'
  };

  export type FeaturedOnPageLinkScalarFieldEnum = (typeof FeaturedOnPageLinkScalarFieldEnum)[keyof typeof FeaturedOnPageLinkScalarFieldEnum]


  export const PlatformSectionScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    title: 'title',
    description: 'description',
    tags: 'tags',
    ctaText: 'ctaText',
    isActive: 'isActive'
  };

  export type PlatformSectionScalarFieldEnum = (typeof PlatformSectionScalarFieldEnum)[keyof typeof PlatformSectionScalarFieldEnum]


  export const GetStartedContentScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    packType: 'packType',
    quality: 'quality',
    features: 'features',
    explanation: 'explanation',
    pricing: 'pricing',
    isActive: 'isActive'
  };

  export type GetStartedContentScalarFieldEnum = (typeof GetStartedContentScalarFieldEnum)[keyof typeof GetStartedContentScalarFieldEnum]


  export const InfluenceSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    steps: 'steps',
    isActive: 'isActive'
  };

  export type InfluenceSectionScalarFieldEnum = (typeof InfluenceSectionScalarFieldEnum)[keyof typeof InfluenceSectionScalarFieldEnum]


  export const AdvantageSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    items: 'items',
    isActive: 'isActive'
  };

  export type AdvantageSectionScalarFieldEnum = (typeof AdvantageSectionScalarFieldEnum)[keyof typeof AdvantageSectionScalarFieldEnum]


  export const QuickStartSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    buttons: 'buttons',
    isActive: 'isActive'
  };

  export type QuickStartSectionScalarFieldEnum = (typeof QuickStartSectionScalarFieldEnum)[keyof typeof QuickStartSectionScalarFieldEnum]


  export const ServicePageContentScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    serviceType: 'serviceType',
    slug: 'slug',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    heroRating: 'heroRating',
    heroReviewCount: 'heroReviewCount',
    assuranceCardText: 'assuranceCardText',
    learnMoreText: 'learnMoreText',
    learnMoreModalContent: 'learnMoreModalContent',
    packages: 'packages',
    qualityCompare: 'qualityCompare',
    howItWorks: 'howItWorks',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    benefits: 'benefits',
    moreServicesTitle: 'moreServicesTitle',
    moreServicesHighlight: 'moreServicesHighlight',
    moreServicesBody: 'moreServicesBody',
    moreServicesButtons: 'moreServicesButtons'
  };

  export type ServicePageContentScalarFieldEnum = (typeof ServicePageContentScalarFieldEnum)[keyof typeof ServicePageContentScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    platform: 'platform',
    serviceType: 'serviceType',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orderId: 'orderId',
    rating: 'rating',
    comment: 'comment',
    authorName: 'authorName',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    handle: 'handle',
    text: 'text',
    rating: 'rating',
    role: 'role',
    platform: 'platform',
    serviceType: 'serviceType',
    isApproved: 'isApproved',
    isFeatured: 'isFeatured',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    coverImage: 'coverImage',
    authorId: 'authorId',
    category: 'category',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const LegalPageScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    sections: 'sections',
    updatedAt: 'updatedAt'
  };

  export type LegalPageScalarFieldEnum = (typeof LegalPageScalarFieldEnum)[keyof typeof LegalPageScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    type: 'type',
    subject: 'subject',
    body: 'body',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const BellNotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    icon: 'icon',
    priority: 'priority',
    category: 'category',
    iconBg: 'iconBg',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BellNotificationScalarFieldEnum = (typeof BellNotificationScalarFieldEnum)[keyof typeof BellNotificationScalarFieldEnum]


  export const BannerMessageScalarFieldEnum: {
    id: 'id',
    text: 'text',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    icon: 'icon'
  };

  export type BannerMessageScalarFieldEnum = (typeof BannerMessageScalarFieldEnum)[keyof typeof BannerMessageScalarFieldEnum]


  export const IconAssetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    url: 'url',
    alt: 'alt',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IconAssetScalarFieldEnum = (typeof IconAssetScalarFieldEnum)[keyof typeof IconAssetScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    type: 'type',
    value: 'value',
    currency: 'currency',
    status: 'status',
    startsAt: 'startsAt',
    expiresAt: 'expiresAt',
    maxRedemptions: 'maxRedemptions',
    maxRedemptionsPerUser: 'maxRedemptionsPerUser',
    minOrderAmount: 'minOrderAmount',
    applicableServices: 'applicableServices',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const CouponRedemptionScalarFieldEnum: {
    id: 'id',
    couponId: 'couponId',
    userId: 'userId',
    orderId: 'orderId',
    redeemedAt: 'redeemedAt'
  };

  export type CouponRedemptionScalarFieldEnum = (typeof CouponRedemptionScalarFieldEnum)[keyof typeof CouponRedemptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Platform'
   */
  export type EnumPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Platform'>
    


  /**
   * Reference to a field of type 'Platform[]'
   */
  export type ListEnumPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Platform[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PaymentGateway'
   */
  export type EnumPaymentGatewayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentGateway'>
    


  /**
   * Reference to a field of type 'PaymentGateway[]'
   */
  export type ListEnumPaymentGatewayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentGateway[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'CouponType'
   */
  export type EnumCouponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponType'>
    


  /**
   * Reference to a field of type 'CouponType[]'
   */
  export type ListEnumCouponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponType[]'>
    


  /**
   * Reference to a field of type 'CouponStatus'
   */
  export type EnumCouponStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponStatus'>
    


  /**
   * Reference to a field of type 'CouponStatus[]'
   */
  export type ListEnumCouponStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    blogPosts?: BlogPostListRelationFilter
    orders?: OrderListRelationFilter
    reviews?: ReviewListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    blogPosts?: BlogPostOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isBlocked?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    blogPosts?: BlogPostListRelationFilter
    orders?: OrderListRelationFilter
    reviews?: ReviewListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isBlocked?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    serviceId?: StringFilter<"Order"> | string
    platform?: EnumPlatformFilter<"Order"> | $Enums.Platform
    serviceType?: EnumServiceTypeFilter<"Order"> | $Enums.ServiceType
    quantity?: IntFilter<"Order"> | number
    price?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    link?: StringNullableFilter<"Order"> | string | null
    japOrderId?: StringNullableFilter<"Order"> | string | null
    japStatus?: StringNullableFilter<"Order"> | string | null
    upsellData?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    reviews?: ReviewListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    link?: SortOrderInput | SortOrder
    japOrderId?: SortOrderInput | SortOrder
    japStatus?: SortOrderInput | SortOrder
    upsellData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    serviceId?: StringFilter<"Order"> | string
    platform?: EnumPlatformFilter<"Order"> | $Enums.Platform
    serviceType?: EnumServiceTypeFilter<"Order"> | $Enums.ServiceType
    quantity?: IntFilter<"Order"> | number
    price?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    link?: StringNullableFilter<"Order"> | string | null
    japOrderId?: StringNullableFilter<"Order"> | string | null
    japStatus?: StringNullableFilter<"Order"> | string | null
    upsellData?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    reviews?: ReviewListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    link?: SortOrderInput | SortOrder
    japOrderId?: SortOrderInput | SortOrder
    japStatus?: SortOrderInput | SortOrder
    upsellData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    serviceId?: StringWithAggregatesFilter<"Order"> | string
    platform?: EnumPlatformWithAggregatesFilter<"Order"> | $Enums.Platform
    serviceType?: EnumServiceTypeWithAggregatesFilter<"Order"> | $Enums.ServiceType
    quantity?: IntWithAggregatesFilter<"Order"> | number
    price?: FloatWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    link?: StringNullableWithAggregatesFilter<"Order"> | string | null
    japOrderId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    japStatus?: StringNullableWithAggregatesFilter<"Order"> | string | null
    upsellData?: JsonNullableWithAggregatesFilter<"Order">
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    platform?: EnumPlatformFilter<"Service"> | $Enums.Platform
    serviceType?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    japServiceId?: StringNullableFilter<"Service"> | string | null
    basePrice?: FloatFilter<"Service"> | number
    markup?: FloatFilter<"Service"> | number
    finalPrice?: FloatFilter<"Service"> | number
    minQuantity?: IntNullableFilter<"Service"> | number | null
    maxQuantity?: IntNullableFilter<"Service"> | number | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    japServiceId?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    markup?: SortOrder
    finalPrice?: SortOrder
    minQuantity?: SortOrderInput | SortOrder
    maxQuantity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    platform_serviceType_japServiceId?: ServicePlatformServiceTypeJapServiceIdCompoundUniqueInput
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    platform?: EnumPlatformFilter<"Service"> | $Enums.Platform
    serviceType?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    japServiceId?: StringNullableFilter<"Service"> | string | null
    basePrice?: FloatFilter<"Service"> | number
    markup?: FloatFilter<"Service"> | number
    finalPrice?: FloatFilter<"Service"> | number
    minQuantity?: IntNullableFilter<"Service"> | number | null
    maxQuantity?: IntNullableFilter<"Service"> | number | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    orders?: OrderListRelationFilter
  }, "id" | "platform_serviceType_japServiceId">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    japServiceId?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    markup?: SortOrder
    finalPrice?: SortOrder
    minQuantity?: SortOrderInput | SortOrder
    maxQuantity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    platform?: EnumPlatformWithAggregatesFilter<"Service"> | $Enums.Platform
    serviceType?: EnumServiceTypeWithAggregatesFilter<"Service"> | $Enums.ServiceType
    japServiceId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    basePrice?: FloatWithAggregatesFilter<"Service"> | number
    markup?: FloatWithAggregatesFilter<"Service"> | number
    finalPrice?: FloatWithAggregatesFilter<"Service"> | number
    minQuantity?: IntNullableWithAggregatesFilter<"Service"> | number | null
    maxQuantity?: IntNullableWithAggregatesFilter<"Service"> | number | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    gateway?: EnumPaymentGatewayFilter<"Payment"> | $Enums.PaymentGateway
    transactionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    webhookData?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    webhookData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    gateway?: EnumPaymentGatewayFilter<"Payment"> | $Enums.PaymentGateway
    transactionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    webhookData?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    webhookData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    gateway?: EnumPaymentGatewayWithAggregatesFilter<"Payment"> | $Enums.PaymentGateway
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    webhookData?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UpsellWhereInput = {
    AND?: UpsellWhereInput | UpsellWhereInput[]
    OR?: UpsellWhereInput[]
    NOT?: UpsellWhereInput | UpsellWhereInput[]
    id?: StringFilter<"Upsell"> | string
    title?: StringFilter<"Upsell"> | string
    description?: StringNullableFilter<"Upsell"> | string | null
    serviceId?: StringNullableFilter<"Upsell"> | string | null
    packageId?: StringNullableFilter<"Upsell"> | string | null
    basePrice?: FloatFilter<"Upsell"> | number
    discountType?: EnumDiscountTypeFilter<"Upsell"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Upsell"> | number
    badgeText?: StringNullableFilter<"Upsell"> | string | null
    badgeColor?: StringNullableFilter<"Upsell"> | string | null
    badgeIcon?: StringNullableFilter<"Upsell"> | string | null
    platform?: EnumPlatformNullableFilter<"Upsell"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableFilter<"Upsell"> | $Enums.ServiceType | null
    minSubtotal?: FloatNullableFilter<"Upsell"> | number | null
    isActive?: BoolFilter<"Upsell"> | boolean
    sortOrder?: IntFilter<"Upsell"> | number
    createdAt?: DateTimeFilter<"Upsell"> | Date | string
    updatedAt?: DateTimeFilter<"Upsell"> | Date | string
  }

  export type UpsellOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    badgeText?: SortOrderInput | SortOrder
    badgeColor?: SortOrderInput | SortOrder
    badgeIcon?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    minSubtotal?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UpsellWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UpsellWhereInput | UpsellWhereInput[]
    OR?: UpsellWhereInput[]
    NOT?: UpsellWhereInput | UpsellWhereInput[]
    title?: StringFilter<"Upsell"> | string
    description?: StringNullableFilter<"Upsell"> | string | null
    serviceId?: StringNullableFilter<"Upsell"> | string | null
    packageId?: StringNullableFilter<"Upsell"> | string | null
    basePrice?: FloatFilter<"Upsell"> | number
    discountType?: EnumDiscountTypeFilter<"Upsell"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Upsell"> | number
    badgeText?: StringNullableFilter<"Upsell"> | string | null
    badgeColor?: StringNullableFilter<"Upsell"> | string | null
    badgeIcon?: StringNullableFilter<"Upsell"> | string | null
    platform?: EnumPlatformNullableFilter<"Upsell"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableFilter<"Upsell"> | $Enums.ServiceType | null
    minSubtotal?: FloatNullableFilter<"Upsell"> | number | null
    isActive?: BoolFilter<"Upsell"> | boolean
    sortOrder?: IntFilter<"Upsell"> | number
    createdAt?: DateTimeFilter<"Upsell"> | Date | string
    updatedAt?: DateTimeFilter<"Upsell"> | Date | string
  }, "id">

  export type UpsellOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    badgeText?: SortOrderInput | SortOrder
    badgeColor?: SortOrderInput | SortOrder
    badgeIcon?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    minSubtotal?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UpsellCountOrderByAggregateInput
    _avg?: UpsellAvgOrderByAggregateInput
    _max?: UpsellMaxOrderByAggregateInput
    _min?: UpsellMinOrderByAggregateInput
    _sum?: UpsellSumOrderByAggregateInput
  }

  export type UpsellScalarWhereWithAggregatesInput = {
    AND?: UpsellScalarWhereWithAggregatesInput | UpsellScalarWhereWithAggregatesInput[]
    OR?: UpsellScalarWhereWithAggregatesInput[]
    NOT?: UpsellScalarWhereWithAggregatesInput | UpsellScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Upsell"> | string
    title?: StringWithAggregatesFilter<"Upsell"> | string
    description?: StringNullableWithAggregatesFilter<"Upsell"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"Upsell"> | string | null
    packageId?: StringNullableWithAggregatesFilter<"Upsell"> | string | null
    basePrice?: FloatWithAggregatesFilter<"Upsell"> | number
    discountType?: EnumDiscountTypeWithAggregatesFilter<"Upsell"> | $Enums.DiscountType
    discountValue?: FloatWithAggregatesFilter<"Upsell"> | number
    badgeText?: StringNullableWithAggregatesFilter<"Upsell"> | string | null
    badgeColor?: StringNullableWithAggregatesFilter<"Upsell"> | string | null
    badgeIcon?: StringNullableWithAggregatesFilter<"Upsell"> | string | null
    platform?: EnumPlatformNullableWithAggregatesFilter<"Upsell"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableWithAggregatesFilter<"Upsell"> | $Enums.ServiceType | null
    minSubtotal?: FloatNullableWithAggregatesFilter<"Upsell"> | number | null
    isActive?: BoolWithAggregatesFilter<"Upsell"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Upsell"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Upsell"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Upsell"> | Date | string
  }

  export type SocialProfileWhereInput = {
    AND?: SocialProfileWhereInput | SocialProfileWhereInput[]
    OR?: SocialProfileWhereInput[]
    NOT?: SocialProfileWhereInput | SocialProfileWhereInput[]
    id?: StringFilter<"SocialProfile"> | string
    platform?: EnumPlatformFilter<"SocialProfile"> | $Enums.Platform
    username?: StringFilter<"SocialProfile"> | string
    profileData?: JsonFilter<"SocialProfile">
    posts?: JsonNullableFilter<"SocialProfile">
    cachedAt?: DateTimeFilter<"SocialProfile"> | Date | string
    expiresAt?: DateTimeFilter<"SocialProfile"> | Date | string
  }

  export type SocialProfileOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    profileData?: SortOrder
    posts?: SortOrderInput | SortOrder
    cachedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SocialProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    platform_username?: SocialProfilePlatformUsernameCompoundUniqueInput
    AND?: SocialProfileWhereInput | SocialProfileWhereInput[]
    OR?: SocialProfileWhereInput[]
    NOT?: SocialProfileWhereInput | SocialProfileWhereInput[]
    platform?: EnumPlatformFilter<"SocialProfile"> | $Enums.Platform
    username?: StringFilter<"SocialProfile"> | string
    profileData?: JsonFilter<"SocialProfile">
    posts?: JsonNullableFilter<"SocialProfile">
    cachedAt?: DateTimeFilter<"SocialProfile"> | Date | string
    expiresAt?: DateTimeFilter<"SocialProfile"> | Date | string
  }, "id" | "platform_username">

  export type SocialProfileOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    profileData?: SortOrder
    posts?: SortOrderInput | SortOrder
    cachedAt?: SortOrder
    expiresAt?: SortOrder
    _count?: SocialProfileCountOrderByAggregateInput
    _max?: SocialProfileMaxOrderByAggregateInput
    _min?: SocialProfileMinOrderByAggregateInput
  }

  export type SocialProfileScalarWhereWithAggregatesInput = {
    AND?: SocialProfileScalarWhereWithAggregatesInput | SocialProfileScalarWhereWithAggregatesInput[]
    OR?: SocialProfileScalarWhereWithAggregatesInput[]
    NOT?: SocialProfileScalarWhereWithAggregatesInput | SocialProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialProfile"> | string
    platform?: EnumPlatformWithAggregatesFilter<"SocialProfile"> | $Enums.Platform
    username?: StringWithAggregatesFilter<"SocialProfile"> | string
    profileData?: JsonWithAggregatesFilter<"SocialProfile">
    posts?: JsonNullableWithAggregatesFilter<"SocialProfile">
    cachedAt?: DateTimeWithAggregatesFilter<"SocialProfile"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"SocialProfile"> | Date | string
  }

  export type SocialProofWhereInput = {
    AND?: SocialProofWhereInput | SocialProofWhereInput[]
    OR?: SocialProofWhereInput[]
    NOT?: SocialProofWhereInput | SocialProofWhereInput[]
    id?: StringFilter<"SocialProof"> | string
    platform?: StringFilter<"SocialProof"> | string
    username?: StringFilter<"SocialProof"> | string
    service?: StringFilter<"SocialProof"> | string
    timeText?: StringFilter<"SocialProof"> | string
    displayOrder?: IntFilter<"SocialProof"> | number
    createdAt?: DateTimeFilter<"SocialProof"> | Date | string
    updatedAt?: DateTimeFilter<"SocialProof"> | Date | string
  }

  export type SocialProofOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    service?: SortOrder
    timeText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialProofWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialProofWhereInput | SocialProofWhereInput[]
    OR?: SocialProofWhereInput[]
    NOT?: SocialProofWhereInput | SocialProofWhereInput[]
    platform?: StringFilter<"SocialProof"> | string
    username?: StringFilter<"SocialProof"> | string
    service?: StringFilter<"SocialProof"> | string
    timeText?: StringFilter<"SocialProof"> | string
    displayOrder?: IntFilter<"SocialProof"> | number
    createdAt?: DateTimeFilter<"SocialProof"> | Date | string
    updatedAt?: DateTimeFilter<"SocialProof"> | Date | string
  }, "id">

  export type SocialProofOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    service?: SortOrder
    timeText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialProofCountOrderByAggregateInput
    _avg?: SocialProofAvgOrderByAggregateInput
    _max?: SocialProofMaxOrderByAggregateInput
    _min?: SocialProofMinOrderByAggregateInput
    _sum?: SocialProofSumOrderByAggregateInput
  }

  export type SocialProofScalarWhereWithAggregatesInput = {
    AND?: SocialProofScalarWhereWithAggregatesInput | SocialProofScalarWhereWithAggregatesInput[]
    OR?: SocialProofScalarWhereWithAggregatesInput[]
    NOT?: SocialProofScalarWhereWithAggregatesInput | SocialProofScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialProof"> | string
    platform?: StringWithAggregatesFilter<"SocialProof"> | string
    username?: StringWithAggregatesFilter<"SocialProof"> | string
    service?: StringWithAggregatesFilter<"SocialProof"> | string
    timeText?: StringWithAggregatesFilter<"SocialProof"> | string
    displayOrder?: IntWithAggregatesFilter<"SocialProof"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SocialProof"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialProof"> | Date | string
  }

  export type AdminSettingsWhereInput = {
    AND?: AdminSettingsWhereInput | AdminSettingsWhereInput[]
    OR?: AdminSettingsWhereInput[]
    NOT?: AdminSettingsWhereInput | AdminSettingsWhereInput[]
    id?: StringFilter<"AdminSettings"> | string
    japApiUrl?: StringNullableFilter<"AdminSettings"> | string | null
    japApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    checkoutApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    checkoutWebhookSecret?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayMeApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayMeWebhookSecret?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiInstagramHost?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiTikTokHost?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiYouTubeHost?: StringNullableFilter<"AdminSettings"> | string | null
    smtpHost?: StringNullableFilter<"AdminSettings"> | string | null
    smtpPort?: IntNullableFilter<"AdminSettings"> | number | null
    smtpSecure?: BoolFilter<"AdminSettings"> | boolean
    smtpUser?: StringNullableFilter<"AdminSettings"> | string | null
    smtpPass?: StringNullableFilter<"AdminSettings"> | string | null
    smtpFrom?: StringNullableFilter<"AdminSettings"> | string | null
    defaultCurrency?: StringFilter<"AdminSettings"> | string
    cryptomusMerchantId?: StringNullableFilter<"AdminSettings"> | string | null
    cryptomusApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    cryptomusDisplayName?: StringNullableFilter<"AdminSettings"> | string | null
    cryptomusTestMode?: BoolFilter<"AdminSettings"> | boolean
    bigPayMerchantId?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayDisplayName?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayApiSecret?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayTestMode?: BoolFilter<"AdminSettings"> | boolean
    exitIntentEnabled?: BoolFilter<"AdminSettings"> | boolean
    exitIntentTitle?: StringNullableFilter<"AdminSettings"> | string | null
    exitIntentSubtitle?: StringNullableFilter<"AdminSettings"> | string | null
    exitIntentDiscountCode?: StringNullableFilter<"AdminSettings"> | string | null
    newServiceIndicator?: BoolFilter<"AdminSettings"> | boolean
    supportEmail?: StringNullableFilter<"AdminSettings"> | string | null
    updatedAt?: DateTimeFilter<"AdminSettings"> | Date | string
    bannerDurationHours?: IntFilter<"AdminSettings"> | number
    bannerEnabled?: BoolFilter<"AdminSettings"> | boolean
    inboxCount?: IntFilter<"AdminSettings"> | number
    teamCount?: IntFilter<"AdminSettings"> | number
    faviconUrl?: StringNullableFilter<"AdminSettings"> | string | null
    footerLogoUrl?: StringNullableFilter<"AdminSettings"> | string | null
    headerLogoUrl?: StringNullableFilter<"AdminSettings"> | string | null
    homeMetaDescription?: StringNullableFilter<"AdminSettings"> | string | null
    homeMetaTitle?: StringNullableFilter<"AdminSettings"> | string | null
    robotsTxtContent?: StringNullableFilter<"AdminSettings"> | string | null
    recaptchaSecretKey?: StringNullableFilter<"AdminSettings"> | string | null
    recaptchaSiteKey?: StringNullableFilter<"AdminSettings"> | string | null
    googleClientId?: StringNullableFilter<"AdminSettings"> | string | null
    googleClientSecret?: StringNullableFilter<"AdminSettings"> | string | null
    facebookClientId?: StringNullableFilter<"AdminSettings"> | string | null
    facebookClientSecret?: StringNullableFilter<"AdminSettings"> | string | null
    myFatoorahToken?: StringNullableFilter<"AdminSettings"> | string | null
    myFatoorahBaseURL?: StringNullableFilter<"AdminSettings"> | string | null
    myFatoorahTestMode?: BoolFilter<"AdminSettings"> | boolean
    myFatoorahWebhookSecret?: StringNullableFilter<"AdminSettings"> | string | null
  }

  export type AdminSettingsOrderByWithRelationInput = {
    id?: SortOrder
    japApiUrl?: SortOrderInput | SortOrder
    japApiKey?: SortOrderInput | SortOrder
    checkoutApiKey?: SortOrderInput | SortOrder
    checkoutWebhookSecret?: SortOrderInput | SortOrder
    bigPayMeApiKey?: SortOrderInput | SortOrder
    bigPayMeWebhookSecret?: SortOrderInput | SortOrder
    rapidApiKey?: SortOrderInput | SortOrder
    rapidApiInstagramHost?: SortOrderInput | SortOrder
    rapidApiTikTokHost?: SortOrderInput | SortOrder
    rapidApiYouTubeHost?: SortOrderInput | SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPass?: SortOrderInput | SortOrder
    smtpFrom?: SortOrderInput | SortOrder
    defaultCurrency?: SortOrder
    cryptomusMerchantId?: SortOrderInput | SortOrder
    cryptomusApiKey?: SortOrderInput | SortOrder
    cryptomusDisplayName?: SortOrderInput | SortOrder
    cryptomusTestMode?: SortOrder
    bigPayMerchantId?: SortOrderInput | SortOrder
    bigPayDisplayName?: SortOrderInput | SortOrder
    bigPayApiSecret?: SortOrderInput | SortOrder
    bigPayTestMode?: SortOrder
    exitIntentEnabled?: SortOrder
    exitIntentTitle?: SortOrderInput | SortOrder
    exitIntentSubtitle?: SortOrderInput | SortOrder
    exitIntentDiscountCode?: SortOrderInput | SortOrder
    newServiceIndicator?: SortOrder
    supportEmail?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    bannerDurationHours?: SortOrder
    bannerEnabled?: SortOrder
    inboxCount?: SortOrder
    teamCount?: SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    footerLogoUrl?: SortOrderInput | SortOrder
    headerLogoUrl?: SortOrderInput | SortOrder
    homeMetaDescription?: SortOrderInput | SortOrder
    homeMetaTitle?: SortOrderInput | SortOrder
    robotsTxtContent?: SortOrderInput | SortOrder
    recaptchaSecretKey?: SortOrderInput | SortOrder
    recaptchaSiteKey?: SortOrderInput | SortOrder
    googleClientId?: SortOrderInput | SortOrder
    googleClientSecret?: SortOrderInput | SortOrder
    facebookClientId?: SortOrderInput | SortOrder
    facebookClientSecret?: SortOrderInput | SortOrder
    myFatoorahToken?: SortOrderInput | SortOrder
    myFatoorahBaseURL?: SortOrderInput | SortOrder
    myFatoorahTestMode?: SortOrder
    myFatoorahWebhookSecret?: SortOrderInput | SortOrder
  }

  export type AdminSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminSettingsWhereInput | AdminSettingsWhereInput[]
    OR?: AdminSettingsWhereInput[]
    NOT?: AdminSettingsWhereInput | AdminSettingsWhereInput[]
    japApiUrl?: StringNullableFilter<"AdminSettings"> | string | null
    japApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    checkoutApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    checkoutWebhookSecret?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayMeApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayMeWebhookSecret?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiInstagramHost?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiTikTokHost?: StringNullableFilter<"AdminSettings"> | string | null
    rapidApiYouTubeHost?: StringNullableFilter<"AdminSettings"> | string | null
    smtpHost?: StringNullableFilter<"AdminSettings"> | string | null
    smtpPort?: IntNullableFilter<"AdminSettings"> | number | null
    smtpSecure?: BoolFilter<"AdminSettings"> | boolean
    smtpUser?: StringNullableFilter<"AdminSettings"> | string | null
    smtpPass?: StringNullableFilter<"AdminSettings"> | string | null
    smtpFrom?: StringNullableFilter<"AdminSettings"> | string | null
    defaultCurrency?: StringFilter<"AdminSettings"> | string
    cryptomusMerchantId?: StringNullableFilter<"AdminSettings"> | string | null
    cryptomusApiKey?: StringNullableFilter<"AdminSettings"> | string | null
    cryptomusDisplayName?: StringNullableFilter<"AdminSettings"> | string | null
    cryptomusTestMode?: BoolFilter<"AdminSettings"> | boolean
    bigPayMerchantId?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayDisplayName?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayApiSecret?: StringNullableFilter<"AdminSettings"> | string | null
    bigPayTestMode?: BoolFilter<"AdminSettings"> | boolean
    exitIntentEnabled?: BoolFilter<"AdminSettings"> | boolean
    exitIntentTitle?: StringNullableFilter<"AdminSettings"> | string | null
    exitIntentSubtitle?: StringNullableFilter<"AdminSettings"> | string | null
    exitIntentDiscountCode?: StringNullableFilter<"AdminSettings"> | string | null
    newServiceIndicator?: BoolFilter<"AdminSettings"> | boolean
    supportEmail?: StringNullableFilter<"AdminSettings"> | string | null
    updatedAt?: DateTimeFilter<"AdminSettings"> | Date | string
    bannerDurationHours?: IntFilter<"AdminSettings"> | number
    bannerEnabled?: BoolFilter<"AdminSettings"> | boolean
    inboxCount?: IntFilter<"AdminSettings"> | number
    teamCount?: IntFilter<"AdminSettings"> | number
    faviconUrl?: StringNullableFilter<"AdminSettings"> | string | null
    footerLogoUrl?: StringNullableFilter<"AdminSettings"> | string | null
    headerLogoUrl?: StringNullableFilter<"AdminSettings"> | string | null
    homeMetaDescription?: StringNullableFilter<"AdminSettings"> | string | null
    homeMetaTitle?: StringNullableFilter<"AdminSettings"> | string | null
    robotsTxtContent?: StringNullableFilter<"AdminSettings"> | string | null
    recaptchaSecretKey?: StringNullableFilter<"AdminSettings"> | string | null
    recaptchaSiteKey?: StringNullableFilter<"AdminSettings"> | string | null
    googleClientId?: StringNullableFilter<"AdminSettings"> | string | null
    googleClientSecret?: StringNullableFilter<"AdminSettings"> | string | null
    facebookClientId?: StringNullableFilter<"AdminSettings"> | string | null
    facebookClientSecret?: StringNullableFilter<"AdminSettings"> | string | null
    myFatoorahToken?: StringNullableFilter<"AdminSettings"> | string | null
    myFatoorahBaseURL?: StringNullableFilter<"AdminSettings"> | string | null
    myFatoorahTestMode?: BoolFilter<"AdminSettings"> | boolean
    myFatoorahWebhookSecret?: StringNullableFilter<"AdminSettings"> | string | null
  }, "id">

  export type AdminSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    japApiUrl?: SortOrderInput | SortOrder
    japApiKey?: SortOrderInput | SortOrder
    checkoutApiKey?: SortOrderInput | SortOrder
    checkoutWebhookSecret?: SortOrderInput | SortOrder
    bigPayMeApiKey?: SortOrderInput | SortOrder
    bigPayMeWebhookSecret?: SortOrderInput | SortOrder
    rapidApiKey?: SortOrderInput | SortOrder
    rapidApiInstagramHost?: SortOrderInput | SortOrder
    rapidApiTikTokHost?: SortOrderInput | SortOrder
    rapidApiYouTubeHost?: SortOrderInput | SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPass?: SortOrderInput | SortOrder
    smtpFrom?: SortOrderInput | SortOrder
    defaultCurrency?: SortOrder
    cryptomusMerchantId?: SortOrderInput | SortOrder
    cryptomusApiKey?: SortOrderInput | SortOrder
    cryptomusDisplayName?: SortOrderInput | SortOrder
    cryptomusTestMode?: SortOrder
    bigPayMerchantId?: SortOrderInput | SortOrder
    bigPayDisplayName?: SortOrderInput | SortOrder
    bigPayApiSecret?: SortOrderInput | SortOrder
    bigPayTestMode?: SortOrder
    exitIntentEnabled?: SortOrder
    exitIntentTitle?: SortOrderInput | SortOrder
    exitIntentSubtitle?: SortOrderInput | SortOrder
    exitIntentDiscountCode?: SortOrderInput | SortOrder
    newServiceIndicator?: SortOrder
    supportEmail?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    bannerDurationHours?: SortOrder
    bannerEnabled?: SortOrder
    inboxCount?: SortOrder
    teamCount?: SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    footerLogoUrl?: SortOrderInput | SortOrder
    headerLogoUrl?: SortOrderInput | SortOrder
    homeMetaDescription?: SortOrderInput | SortOrder
    homeMetaTitle?: SortOrderInput | SortOrder
    robotsTxtContent?: SortOrderInput | SortOrder
    recaptchaSecretKey?: SortOrderInput | SortOrder
    recaptchaSiteKey?: SortOrderInput | SortOrder
    googleClientId?: SortOrderInput | SortOrder
    googleClientSecret?: SortOrderInput | SortOrder
    facebookClientId?: SortOrderInput | SortOrder
    facebookClientSecret?: SortOrderInput | SortOrder
    myFatoorahToken?: SortOrderInput | SortOrder
    myFatoorahBaseURL?: SortOrderInput | SortOrder
    myFatoorahTestMode?: SortOrder
    myFatoorahWebhookSecret?: SortOrderInput | SortOrder
    _count?: AdminSettingsCountOrderByAggregateInput
    _avg?: AdminSettingsAvgOrderByAggregateInput
    _max?: AdminSettingsMaxOrderByAggregateInput
    _min?: AdminSettingsMinOrderByAggregateInput
    _sum?: AdminSettingsSumOrderByAggregateInput
  }

  export type AdminSettingsScalarWhereWithAggregatesInput = {
    AND?: AdminSettingsScalarWhereWithAggregatesInput | AdminSettingsScalarWhereWithAggregatesInput[]
    OR?: AdminSettingsScalarWhereWithAggregatesInput[]
    NOT?: AdminSettingsScalarWhereWithAggregatesInput | AdminSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSettings"> | string
    japApiUrl?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    japApiKey?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    checkoutApiKey?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    checkoutWebhookSecret?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    bigPayMeApiKey?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    bigPayMeWebhookSecret?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    rapidApiKey?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    rapidApiInstagramHost?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    rapidApiTikTokHost?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    rapidApiYouTubeHost?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    smtpHost?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    smtpPort?: IntNullableWithAggregatesFilter<"AdminSettings"> | number | null
    smtpSecure?: BoolWithAggregatesFilter<"AdminSettings"> | boolean
    smtpUser?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    smtpPass?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    smtpFrom?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    defaultCurrency?: StringWithAggregatesFilter<"AdminSettings"> | string
    cryptomusMerchantId?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    cryptomusApiKey?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    cryptomusDisplayName?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    cryptomusTestMode?: BoolWithAggregatesFilter<"AdminSettings"> | boolean
    bigPayMerchantId?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    bigPayDisplayName?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    bigPayApiSecret?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    bigPayTestMode?: BoolWithAggregatesFilter<"AdminSettings"> | boolean
    exitIntentEnabled?: BoolWithAggregatesFilter<"AdminSettings"> | boolean
    exitIntentTitle?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    exitIntentSubtitle?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    exitIntentDiscountCode?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    newServiceIndicator?: BoolWithAggregatesFilter<"AdminSettings"> | boolean
    supportEmail?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"AdminSettings"> | Date | string
    bannerDurationHours?: IntWithAggregatesFilter<"AdminSettings"> | number
    bannerEnabled?: BoolWithAggregatesFilter<"AdminSettings"> | boolean
    inboxCount?: IntWithAggregatesFilter<"AdminSettings"> | number
    teamCount?: IntWithAggregatesFilter<"AdminSettings"> | number
    faviconUrl?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    footerLogoUrl?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    headerLogoUrl?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    homeMetaDescription?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    homeMetaTitle?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    robotsTxtContent?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    recaptchaSecretKey?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    recaptchaSiteKey?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    googleClientId?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    googleClientSecret?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    facebookClientId?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    facebookClientSecret?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    myFatoorahToken?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    myFatoorahBaseURL?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
    myFatoorahTestMode?: BoolWithAggregatesFilter<"AdminSettings"> | boolean
    myFatoorahWebhookSecret?: StringNullableWithAggregatesFilter<"AdminSettings"> | string | null
  }

  export type HomepageContentWhereInput = {
    AND?: HomepageContentWhereInput | HomepageContentWhereInput[]
    OR?: HomepageContentWhereInput[]
    NOT?: HomepageContentWhereInput | HomepageContentWhereInput[]
    id?: StringFilter<"HomepageContent"> | string
    heroTitle?: StringFilter<"HomepageContent"> | string
    heroSubtitle?: StringFilter<"HomepageContent"> | string
    heroRating?: StringNullableFilter<"HomepageContent"> | string | null
    heroReviewCount?: StringNullableFilter<"HomepageContent"> | string | null
    heroCtaButtons?: JsonNullableFilter<"HomepageContent">
    isActive?: BoolFilter<"HomepageContent"> | boolean
    updatedAt?: DateTimeFilter<"HomepageContent"> | Date | string
    benefits?: JsonNullableFilter<"HomepageContent">
    heroProfileEngagement?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileFollowers?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileHandle?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileLikes?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileRole?: StringNullableFilter<"HomepageContent"> | string | null
    influenceSubtitle?: StringNullableFilter<"HomepageContent"> | string | null
    influenceTitle?: StringNullableFilter<"HomepageContent"> | string | null
    platformSubtitle?: StringNullableFilter<"HomepageContent"> | string | null
    platformTitle?: StringNullableFilter<"HomepageContent"> | string | null
    quickStartDescription1?: StringNullableFilter<"HomepageContent"> | string | null
    quickStartDescription2?: StringNullableFilter<"HomepageContent"> | string | null
    quickStartTitle?: StringNullableFilter<"HomepageContent"> | string | null
    whyChooseSubtitle?: StringNullableFilter<"HomepageContent"> | string | null
    whyChooseTitle?: StringNullableFilter<"HomepageContent"> | string | null
    platformCards?: JsonNullableFilter<"HomepageContent">
    heroProfileImage?: StringNullableFilter<"HomepageContent"> | string | null
    influenceImage?: StringNullableFilter<"HomepageContent"> | string | null
    influenceSteps?: JsonNullableFilter<"HomepageContent">
    quickStartButtons?: JsonNullableFilter<"HomepageContent">
  }

  export type HomepageContentOrderByWithRelationInput = {
    id?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrderInput | SortOrder
    heroReviewCount?: SortOrderInput | SortOrder
    heroCtaButtons?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    benefits?: SortOrderInput | SortOrder
    heroProfileEngagement?: SortOrderInput | SortOrder
    heroProfileFollowers?: SortOrderInput | SortOrder
    heroProfileHandle?: SortOrderInput | SortOrder
    heroProfileLikes?: SortOrderInput | SortOrder
    heroProfileRole?: SortOrderInput | SortOrder
    influenceSubtitle?: SortOrderInput | SortOrder
    influenceTitle?: SortOrderInput | SortOrder
    platformSubtitle?: SortOrderInput | SortOrder
    platformTitle?: SortOrderInput | SortOrder
    quickStartDescription1?: SortOrderInput | SortOrder
    quickStartDescription2?: SortOrderInput | SortOrder
    quickStartTitle?: SortOrderInput | SortOrder
    whyChooseSubtitle?: SortOrderInput | SortOrder
    whyChooseTitle?: SortOrderInput | SortOrder
    platformCards?: SortOrderInput | SortOrder
    heroProfileImage?: SortOrderInput | SortOrder
    influenceImage?: SortOrderInput | SortOrder
    influenceSteps?: SortOrderInput | SortOrder
    quickStartButtons?: SortOrderInput | SortOrder
  }

  export type HomepageContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomepageContentWhereInput | HomepageContentWhereInput[]
    OR?: HomepageContentWhereInput[]
    NOT?: HomepageContentWhereInput | HomepageContentWhereInput[]
    heroTitle?: StringFilter<"HomepageContent"> | string
    heroSubtitle?: StringFilter<"HomepageContent"> | string
    heroRating?: StringNullableFilter<"HomepageContent"> | string | null
    heroReviewCount?: StringNullableFilter<"HomepageContent"> | string | null
    heroCtaButtons?: JsonNullableFilter<"HomepageContent">
    isActive?: BoolFilter<"HomepageContent"> | boolean
    updatedAt?: DateTimeFilter<"HomepageContent"> | Date | string
    benefits?: JsonNullableFilter<"HomepageContent">
    heroProfileEngagement?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileFollowers?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileHandle?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileLikes?: StringNullableFilter<"HomepageContent"> | string | null
    heroProfileRole?: StringNullableFilter<"HomepageContent"> | string | null
    influenceSubtitle?: StringNullableFilter<"HomepageContent"> | string | null
    influenceTitle?: StringNullableFilter<"HomepageContent"> | string | null
    platformSubtitle?: StringNullableFilter<"HomepageContent"> | string | null
    platformTitle?: StringNullableFilter<"HomepageContent"> | string | null
    quickStartDescription1?: StringNullableFilter<"HomepageContent"> | string | null
    quickStartDescription2?: StringNullableFilter<"HomepageContent"> | string | null
    quickStartTitle?: StringNullableFilter<"HomepageContent"> | string | null
    whyChooseSubtitle?: StringNullableFilter<"HomepageContent"> | string | null
    whyChooseTitle?: StringNullableFilter<"HomepageContent"> | string | null
    platformCards?: JsonNullableFilter<"HomepageContent">
    heroProfileImage?: StringNullableFilter<"HomepageContent"> | string | null
    influenceImage?: StringNullableFilter<"HomepageContent"> | string | null
    influenceSteps?: JsonNullableFilter<"HomepageContent">
    quickStartButtons?: JsonNullableFilter<"HomepageContent">
  }, "id">

  export type HomepageContentOrderByWithAggregationInput = {
    id?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrderInput | SortOrder
    heroReviewCount?: SortOrderInput | SortOrder
    heroCtaButtons?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    benefits?: SortOrderInput | SortOrder
    heroProfileEngagement?: SortOrderInput | SortOrder
    heroProfileFollowers?: SortOrderInput | SortOrder
    heroProfileHandle?: SortOrderInput | SortOrder
    heroProfileLikes?: SortOrderInput | SortOrder
    heroProfileRole?: SortOrderInput | SortOrder
    influenceSubtitle?: SortOrderInput | SortOrder
    influenceTitle?: SortOrderInput | SortOrder
    platformSubtitle?: SortOrderInput | SortOrder
    platformTitle?: SortOrderInput | SortOrder
    quickStartDescription1?: SortOrderInput | SortOrder
    quickStartDescription2?: SortOrderInput | SortOrder
    quickStartTitle?: SortOrderInput | SortOrder
    whyChooseSubtitle?: SortOrderInput | SortOrder
    whyChooseTitle?: SortOrderInput | SortOrder
    platformCards?: SortOrderInput | SortOrder
    heroProfileImage?: SortOrderInput | SortOrder
    influenceImage?: SortOrderInput | SortOrder
    influenceSteps?: SortOrderInput | SortOrder
    quickStartButtons?: SortOrderInput | SortOrder
    _count?: HomepageContentCountOrderByAggregateInput
    _max?: HomepageContentMaxOrderByAggregateInput
    _min?: HomepageContentMinOrderByAggregateInput
  }

  export type HomepageContentScalarWhereWithAggregatesInput = {
    AND?: HomepageContentScalarWhereWithAggregatesInput | HomepageContentScalarWhereWithAggregatesInput[]
    OR?: HomepageContentScalarWhereWithAggregatesInput[]
    NOT?: HomepageContentScalarWhereWithAggregatesInput | HomepageContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomepageContent"> | string
    heroTitle?: StringWithAggregatesFilter<"HomepageContent"> | string
    heroSubtitle?: StringWithAggregatesFilter<"HomepageContent"> | string
    heroRating?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    heroReviewCount?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    heroCtaButtons?: JsonNullableWithAggregatesFilter<"HomepageContent">
    isActive?: BoolWithAggregatesFilter<"HomepageContent"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"HomepageContent"> | Date | string
    benefits?: JsonNullableWithAggregatesFilter<"HomepageContent">
    heroProfileEngagement?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    heroProfileFollowers?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    heroProfileHandle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    heroProfileLikes?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    heroProfileRole?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    influenceSubtitle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    influenceTitle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    platformSubtitle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    platformTitle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    quickStartDescription1?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    quickStartDescription2?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    quickStartTitle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    whyChooseSubtitle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    whyChooseTitle?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    platformCards?: JsonNullableWithAggregatesFilter<"HomepageContent">
    heroProfileImage?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    influenceImage?: StringNullableWithAggregatesFilter<"HomepageContent"> | string | null
    influenceSteps?: JsonNullableWithAggregatesFilter<"HomepageContent">
    quickStartButtons?: JsonNullableWithAggregatesFilter<"HomepageContent">
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    name?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    description?: StringFilter<"TeamMember"> | string
    twitterUrl?: StringNullableFilter<"TeamMember"> | string | null
    linkedinUrl?: StringNullableFilter<"TeamMember"> | string | null
    avatarUrl?: StringNullableFilter<"TeamMember"> | string | null
    displayOrder?: IntFilter<"TeamMember"> | number
    isActive?: BoolFilter<"TeamMember"> | boolean
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    description?: SortOrder
    twitterUrl?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    name?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    description?: StringFilter<"TeamMember"> | string
    twitterUrl?: StringNullableFilter<"TeamMember"> | string | null
    linkedinUrl?: StringNullableFilter<"TeamMember"> | string | null
    avatarUrl?: StringNullableFilter<"TeamMember"> | string | null
    displayOrder?: IntFilter<"TeamMember"> | number
    isActive?: BoolFilter<"TeamMember"> | boolean
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }, "id">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    description?: SortOrder
    twitterUrl?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    name?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: StringWithAggregatesFilter<"TeamMember"> | string
    description?: StringWithAggregatesFilter<"TeamMember"> | string
    twitterUrl?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    displayOrder?: IntWithAggregatesFilter<"TeamMember"> | number
    isActive?: BoolWithAggregatesFilter<"TeamMember"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type HeroSocialUpdateWhereInput = {
    AND?: HeroSocialUpdateWhereInput | HeroSocialUpdateWhereInput[]
    OR?: HeroSocialUpdateWhereInput[]
    NOT?: HeroSocialUpdateWhereInput | HeroSocialUpdateWhereInput[]
    id?: IntFilter<"HeroSocialUpdate"> | number
    handle?: StringFilter<"HeroSocialUpdate"> | string
    item?: StringFilter<"HeroSocialUpdate"> | string
    time?: StringFilter<"HeroSocialUpdate"> | string
    displayOrder?: IntFilter<"HeroSocialUpdate"> | number
    isActive?: BoolFilter<"HeroSocialUpdate"> | boolean
  }

  export type HeroSocialUpdateOrderByWithRelationInput = {
    id?: SortOrder
    handle?: SortOrder
    item?: SortOrder
    time?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type HeroSocialUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HeroSocialUpdateWhereInput | HeroSocialUpdateWhereInput[]
    OR?: HeroSocialUpdateWhereInput[]
    NOT?: HeroSocialUpdateWhereInput | HeroSocialUpdateWhereInput[]
    handle?: StringFilter<"HeroSocialUpdate"> | string
    item?: StringFilter<"HeroSocialUpdate"> | string
    time?: StringFilter<"HeroSocialUpdate"> | string
    displayOrder?: IntFilter<"HeroSocialUpdate"> | number
    isActive?: BoolFilter<"HeroSocialUpdate"> | boolean
  }, "id">

  export type HeroSocialUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    handle?: SortOrder
    item?: SortOrder
    time?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: HeroSocialUpdateCountOrderByAggregateInput
    _avg?: HeroSocialUpdateAvgOrderByAggregateInput
    _max?: HeroSocialUpdateMaxOrderByAggregateInput
    _min?: HeroSocialUpdateMinOrderByAggregateInput
    _sum?: HeroSocialUpdateSumOrderByAggregateInput
  }

  export type HeroSocialUpdateScalarWhereWithAggregatesInput = {
    AND?: HeroSocialUpdateScalarWhereWithAggregatesInput | HeroSocialUpdateScalarWhereWithAggregatesInput[]
    OR?: HeroSocialUpdateScalarWhereWithAggregatesInput[]
    NOT?: HeroSocialUpdateScalarWhereWithAggregatesInput | HeroSocialUpdateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HeroSocialUpdate"> | number
    handle?: StringWithAggregatesFilter<"HeroSocialUpdate"> | string
    item?: StringWithAggregatesFilter<"HeroSocialUpdate"> | string
    time?: StringWithAggregatesFilter<"HeroSocialUpdate"> | string
    displayOrder?: IntWithAggregatesFilter<"HeroSocialUpdate"> | number
    isActive?: BoolWithAggregatesFilter<"HeroSocialUpdate"> | boolean
  }

  export type PromoBarWhereInput = {
    AND?: PromoBarWhereInput | PromoBarWhereInput[]
    OR?: PromoBarWhereInput[]
    NOT?: PromoBarWhereInput | PromoBarWhereInput[]
    id?: StringFilter<"PromoBar"> | string
    messages?: JsonFilter<"PromoBar">
    countdownSeconds?: IntNullableFilter<"PromoBar"> | number | null
    isVisible?: BoolFilter<"PromoBar"> | boolean
    displayOrder?: IntFilter<"PromoBar"> | number
    updatedAt?: DateTimeFilter<"PromoBar"> | Date | string
  }

  export type PromoBarOrderByWithRelationInput = {
    id?: SortOrder
    messages?: SortOrder
    countdownSeconds?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    displayOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoBarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromoBarWhereInput | PromoBarWhereInput[]
    OR?: PromoBarWhereInput[]
    NOT?: PromoBarWhereInput | PromoBarWhereInput[]
    messages?: JsonFilter<"PromoBar">
    countdownSeconds?: IntNullableFilter<"PromoBar"> | number | null
    isVisible?: BoolFilter<"PromoBar"> | boolean
    displayOrder?: IntFilter<"PromoBar"> | number
    updatedAt?: DateTimeFilter<"PromoBar"> | Date | string
  }, "id">

  export type PromoBarOrderByWithAggregationInput = {
    id?: SortOrder
    messages?: SortOrder
    countdownSeconds?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    displayOrder?: SortOrder
    updatedAt?: SortOrder
    _count?: PromoBarCountOrderByAggregateInput
    _avg?: PromoBarAvgOrderByAggregateInput
    _max?: PromoBarMaxOrderByAggregateInput
    _min?: PromoBarMinOrderByAggregateInput
    _sum?: PromoBarSumOrderByAggregateInput
  }

  export type PromoBarScalarWhereWithAggregatesInput = {
    AND?: PromoBarScalarWhereWithAggregatesInput | PromoBarScalarWhereWithAggregatesInput[]
    OR?: PromoBarScalarWhereWithAggregatesInput[]
    NOT?: PromoBarScalarWhereWithAggregatesInput | PromoBarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoBar"> | string
    messages?: JsonWithAggregatesFilter<"PromoBar">
    countdownSeconds?: IntNullableWithAggregatesFilter<"PromoBar"> | number | null
    isVisible?: BoolWithAggregatesFilter<"PromoBar"> | boolean
    displayOrder?: IntWithAggregatesFilter<"PromoBar"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"PromoBar"> | Date | string
  }

  export type FeaturedOnWhereInput = {
    AND?: FeaturedOnWhereInput | FeaturedOnWhereInput[]
    OR?: FeaturedOnWhereInput[]
    NOT?: FeaturedOnWhereInput | FeaturedOnWhereInput[]
    id?: IntFilter<"FeaturedOn"> | number
    brandName?: StringFilter<"FeaturedOn"> | string
    logoUrl?: StringNullableFilter<"FeaturedOn"> | string | null
    displayOrder?: IntFilter<"FeaturedOn"> | number
    isActive?: BoolFilter<"FeaturedOn"> | boolean
    pageLinks?: FeaturedOnPageLinkListRelationFilter
  }

  export type FeaturedOnOrderByWithRelationInput = {
    id?: SortOrder
    brandName?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    pageLinks?: FeaturedOnPageLinkOrderByRelationAggregateInput
  }

  export type FeaturedOnWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeaturedOnWhereInput | FeaturedOnWhereInput[]
    OR?: FeaturedOnWhereInput[]
    NOT?: FeaturedOnWhereInput | FeaturedOnWhereInput[]
    brandName?: StringFilter<"FeaturedOn"> | string
    logoUrl?: StringNullableFilter<"FeaturedOn"> | string | null
    displayOrder?: IntFilter<"FeaturedOn"> | number
    isActive?: BoolFilter<"FeaturedOn"> | boolean
    pageLinks?: FeaturedOnPageLinkListRelationFilter
  }, "id">

  export type FeaturedOnOrderByWithAggregationInput = {
    id?: SortOrder
    brandName?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    _count?: FeaturedOnCountOrderByAggregateInput
    _avg?: FeaturedOnAvgOrderByAggregateInput
    _max?: FeaturedOnMaxOrderByAggregateInput
    _min?: FeaturedOnMinOrderByAggregateInput
    _sum?: FeaturedOnSumOrderByAggregateInput
  }

  export type FeaturedOnScalarWhereWithAggregatesInput = {
    AND?: FeaturedOnScalarWhereWithAggregatesInput | FeaturedOnScalarWhereWithAggregatesInput[]
    OR?: FeaturedOnScalarWhereWithAggregatesInput[]
    NOT?: FeaturedOnScalarWhereWithAggregatesInput | FeaturedOnScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeaturedOn"> | number
    brandName?: StringWithAggregatesFilter<"FeaturedOn"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"FeaturedOn"> | string | null
    displayOrder?: IntWithAggregatesFilter<"FeaturedOn"> | number
    isActive?: BoolWithAggregatesFilter<"FeaturedOn"> | boolean
  }

  export type FeaturedOnPageLinkWhereInput = {
    AND?: FeaturedOnPageLinkWhereInput | FeaturedOnPageLinkWhereInput[]
    OR?: FeaturedOnPageLinkWhereInput[]
    NOT?: FeaturedOnPageLinkWhereInput | FeaturedOnPageLinkWhereInput[]
    id?: IntFilter<"FeaturedOnPageLink"> | number
    featuredOnId?: IntFilter<"FeaturedOnPageLink"> | number
    pagePath?: StringFilter<"FeaturedOnPageLink"> | string
    link?: StringNullableFilter<"FeaturedOnPageLink"> | string | null
    nofollow?: BoolFilter<"FeaturedOnPageLink"> | boolean
    featuredOn?: XOR<FeaturedOnRelationFilter, FeaturedOnWhereInput>
  }

  export type FeaturedOnPageLinkOrderByWithRelationInput = {
    id?: SortOrder
    featuredOnId?: SortOrder
    pagePath?: SortOrder
    link?: SortOrderInput | SortOrder
    nofollow?: SortOrder
    featuredOn?: FeaturedOnOrderByWithRelationInput
  }

  export type FeaturedOnPageLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeaturedOnPageLinkWhereInput | FeaturedOnPageLinkWhereInput[]
    OR?: FeaturedOnPageLinkWhereInput[]
    NOT?: FeaturedOnPageLinkWhereInput | FeaturedOnPageLinkWhereInput[]
    featuredOnId?: IntFilter<"FeaturedOnPageLink"> | number
    pagePath?: StringFilter<"FeaturedOnPageLink"> | string
    link?: StringNullableFilter<"FeaturedOnPageLink"> | string | null
    nofollow?: BoolFilter<"FeaturedOnPageLink"> | boolean
    featuredOn?: XOR<FeaturedOnRelationFilter, FeaturedOnWhereInput>
  }, "id">

  export type FeaturedOnPageLinkOrderByWithAggregationInput = {
    id?: SortOrder
    featuredOnId?: SortOrder
    pagePath?: SortOrder
    link?: SortOrderInput | SortOrder
    nofollow?: SortOrder
    _count?: FeaturedOnPageLinkCountOrderByAggregateInput
    _avg?: FeaturedOnPageLinkAvgOrderByAggregateInput
    _max?: FeaturedOnPageLinkMaxOrderByAggregateInput
    _min?: FeaturedOnPageLinkMinOrderByAggregateInput
    _sum?: FeaturedOnPageLinkSumOrderByAggregateInput
  }

  export type FeaturedOnPageLinkScalarWhereWithAggregatesInput = {
    AND?: FeaturedOnPageLinkScalarWhereWithAggregatesInput | FeaturedOnPageLinkScalarWhereWithAggregatesInput[]
    OR?: FeaturedOnPageLinkScalarWhereWithAggregatesInput[]
    NOT?: FeaturedOnPageLinkScalarWhereWithAggregatesInput | FeaturedOnPageLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeaturedOnPageLink"> | number
    featuredOnId?: IntWithAggregatesFilter<"FeaturedOnPageLink"> | number
    pagePath?: StringWithAggregatesFilter<"FeaturedOnPageLink"> | string
    link?: StringNullableWithAggregatesFilter<"FeaturedOnPageLink"> | string | null
    nofollow?: BoolWithAggregatesFilter<"FeaturedOnPageLink"> | boolean
  }

  export type PlatformSectionWhereInput = {
    AND?: PlatformSectionWhereInput | PlatformSectionWhereInput[]
    OR?: PlatformSectionWhereInput[]
    NOT?: PlatformSectionWhereInput | PlatformSectionWhereInput[]
    id?: IntFilter<"PlatformSection"> | number
    platform?: EnumPlatformFilter<"PlatformSection"> | $Enums.Platform
    title?: StringFilter<"PlatformSection"> | string
    description?: StringFilter<"PlatformSection"> | string
    tags?: JsonFilter<"PlatformSection">
    ctaText?: StringFilter<"PlatformSection"> | string
    isActive?: BoolFilter<"PlatformSection"> | boolean
  }

  export type PlatformSectionOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    ctaText?: SortOrder
    isActive?: SortOrder
  }

  export type PlatformSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    platform?: $Enums.Platform
    AND?: PlatformSectionWhereInput | PlatformSectionWhereInput[]
    OR?: PlatformSectionWhereInput[]
    NOT?: PlatformSectionWhereInput | PlatformSectionWhereInput[]
    title?: StringFilter<"PlatformSection"> | string
    description?: StringFilter<"PlatformSection"> | string
    tags?: JsonFilter<"PlatformSection">
    ctaText?: StringFilter<"PlatformSection"> | string
    isActive?: BoolFilter<"PlatformSection"> | boolean
  }, "id" | "platform">

  export type PlatformSectionOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    ctaText?: SortOrder
    isActive?: SortOrder
    _count?: PlatformSectionCountOrderByAggregateInput
    _avg?: PlatformSectionAvgOrderByAggregateInput
    _max?: PlatformSectionMaxOrderByAggregateInput
    _min?: PlatformSectionMinOrderByAggregateInput
    _sum?: PlatformSectionSumOrderByAggregateInput
  }

  export type PlatformSectionScalarWhereWithAggregatesInput = {
    AND?: PlatformSectionScalarWhereWithAggregatesInput | PlatformSectionScalarWhereWithAggregatesInput[]
    OR?: PlatformSectionScalarWhereWithAggregatesInput[]
    NOT?: PlatformSectionScalarWhereWithAggregatesInput | PlatformSectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlatformSection"> | number
    platform?: EnumPlatformWithAggregatesFilter<"PlatformSection"> | $Enums.Platform
    title?: StringWithAggregatesFilter<"PlatformSection"> | string
    description?: StringWithAggregatesFilter<"PlatformSection"> | string
    tags?: JsonWithAggregatesFilter<"PlatformSection">
    ctaText?: StringWithAggregatesFilter<"PlatformSection"> | string
    isActive?: BoolWithAggregatesFilter<"PlatformSection"> | boolean
  }

  export type GetStartedContentWhereInput = {
    AND?: GetStartedContentWhereInput | GetStartedContentWhereInput[]
    OR?: GetStartedContentWhereInput[]
    NOT?: GetStartedContentWhereInput | GetStartedContentWhereInput[]
    id?: IntFilter<"GetStartedContent"> | number
    platform?: EnumPlatformFilter<"GetStartedContent"> | $Enums.Platform
    packType?: EnumServiceTypeFilter<"GetStartedContent"> | $Enums.ServiceType
    quality?: StringFilter<"GetStartedContent"> | string
    features?: JsonFilter<"GetStartedContent">
    explanation?: StringNullableFilter<"GetStartedContent"> | string | null
    pricing?: JsonNullableFilter<"GetStartedContent">
    isActive?: BoolFilter<"GetStartedContent"> | boolean
  }

  export type GetStartedContentOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    packType?: SortOrder
    quality?: SortOrder
    features?: SortOrder
    explanation?: SortOrderInput | SortOrder
    pricing?: SortOrderInput | SortOrder
    isActive?: SortOrder
  }

  export type GetStartedContentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    platform_packType_quality?: GetStartedContentPlatformPackTypeQualityCompoundUniqueInput
    AND?: GetStartedContentWhereInput | GetStartedContentWhereInput[]
    OR?: GetStartedContentWhereInput[]
    NOT?: GetStartedContentWhereInput | GetStartedContentWhereInput[]
    platform?: EnumPlatformFilter<"GetStartedContent"> | $Enums.Platform
    packType?: EnumServiceTypeFilter<"GetStartedContent"> | $Enums.ServiceType
    quality?: StringFilter<"GetStartedContent"> | string
    features?: JsonFilter<"GetStartedContent">
    explanation?: StringNullableFilter<"GetStartedContent"> | string | null
    pricing?: JsonNullableFilter<"GetStartedContent">
    isActive?: BoolFilter<"GetStartedContent"> | boolean
  }, "id" | "platform_packType_quality">

  export type GetStartedContentOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    packType?: SortOrder
    quality?: SortOrder
    features?: SortOrder
    explanation?: SortOrderInput | SortOrder
    pricing?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: GetStartedContentCountOrderByAggregateInput
    _avg?: GetStartedContentAvgOrderByAggregateInput
    _max?: GetStartedContentMaxOrderByAggregateInput
    _min?: GetStartedContentMinOrderByAggregateInput
    _sum?: GetStartedContentSumOrderByAggregateInput
  }

  export type GetStartedContentScalarWhereWithAggregatesInput = {
    AND?: GetStartedContentScalarWhereWithAggregatesInput | GetStartedContentScalarWhereWithAggregatesInput[]
    OR?: GetStartedContentScalarWhereWithAggregatesInput[]
    NOT?: GetStartedContentScalarWhereWithAggregatesInput | GetStartedContentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GetStartedContent"> | number
    platform?: EnumPlatformWithAggregatesFilter<"GetStartedContent"> | $Enums.Platform
    packType?: EnumServiceTypeWithAggregatesFilter<"GetStartedContent"> | $Enums.ServiceType
    quality?: StringWithAggregatesFilter<"GetStartedContent"> | string
    features?: JsonWithAggregatesFilter<"GetStartedContent">
    explanation?: StringNullableWithAggregatesFilter<"GetStartedContent"> | string | null
    pricing?: JsonNullableWithAggregatesFilter<"GetStartedContent">
    isActive?: BoolWithAggregatesFilter<"GetStartedContent"> | boolean
  }

  export type InfluenceSectionWhereInput = {
    AND?: InfluenceSectionWhereInput | InfluenceSectionWhereInput[]
    OR?: InfluenceSectionWhereInput[]
    NOT?: InfluenceSectionWhereInput | InfluenceSectionWhereInput[]
    id?: IntFilter<"InfluenceSection"> | number
    title?: StringFilter<"InfluenceSection"> | string
    description?: StringFilter<"InfluenceSection"> | string
    steps?: JsonFilter<"InfluenceSection">
    isActive?: BoolFilter<"InfluenceSection"> | boolean
  }

  export type InfluenceSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
  }

  export type InfluenceSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InfluenceSectionWhereInput | InfluenceSectionWhereInput[]
    OR?: InfluenceSectionWhereInput[]
    NOT?: InfluenceSectionWhereInput | InfluenceSectionWhereInput[]
    title?: StringFilter<"InfluenceSection"> | string
    description?: StringFilter<"InfluenceSection"> | string
    steps?: JsonFilter<"InfluenceSection">
    isActive?: BoolFilter<"InfluenceSection"> | boolean
  }, "id">

  export type InfluenceSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
    _count?: InfluenceSectionCountOrderByAggregateInput
    _avg?: InfluenceSectionAvgOrderByAggregateInput
    _max?: InfluenceSectionMaxOrderByAggregateInput
    _min?: InfluenceSectionMinOrderByAggregateInput
    _sum?: InfluenceSectionSumOrderByAggregateInput
  }

  export type InfluenceSectionScalarWhereWithAggregatesInput = {
    AND?: InfluenceSectionScalarWhereWithAggregatesInput | InfluenceSectionScalarWhereWithAggregatesInput[]
    OR?: InfluenceSectionScalarWhereWithAggregatesInput[]
    NOT?: InfluenceSectionScalarWhereWithAggregatesInput | InfluenceSectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InfluenceSection"> | number
    title?: StringWithAggregatesFilter<"InfluenceSection"> | string
    description?: StringWithAggregatesFilter<"InfluenceSection"> | string
    steps?: JsonWithAggregatesFilter<"InfluenceSection">
    isActive?: BoolWithAggregatesFilter<"InfluenceSection"> | boolean
  }

  export type AdvantageSectionWhereInput = {
    AND?: AdvantageSectionWhereInput | AdvantageSectionWhereInput[]
    OR?: AdvantageSectionWhereInput[]
    NOT?: AdvantageSectionWhereInput | AdvantageSectionWhereInput[]
    id?: IntFilter<"AdvantageSection"> | number
    title?: StringFilter<"AdvantageSection"> | string
    subtitle?: StringFilter<"AdvantageSection"> | string
    items?: JsonFilter<"AdvantageSection">
    isActive?: BoolFilter<"AdvantageSection"> | boolean
  }

  export type AdvantageSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    items?: SortOrder
    isActive?: SortOrder
  }

  export type AdvantageSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdvantageSectionWhereInput | AdvantageSectionWhereInput[]
    OR?: AdvantageSectionWhereInput[]
    NOT?: AdvantageSectionWhereInput | AdvantageSectionWhereInput[]
    title?: StringFilter<"AdvantageSection"> | string
    subtitle?: StringFilter<"AdvantageSection"> | string
    items?: JsonFilter<"AdvantageSection">
    isActive?: BoolFilter<"AdvantageSection"> | boolean
  }, "id">

  export type AdvantageSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    items?: SortOrder
    isActive?: SortOrder
    _count?: AdvantageSectionCountOrderByAggregateInput
    _avg?: AdvantageSectionAvgOrderByAggregateInput
    _max?: AdvantageSectionMaxOrderByAggregateInput
    _min?: AdvantageSectionMinOrderByAggregateInput
    _sum?: AdvantageSectionSumOrderByAggregateInput
  }

  export type AdvantageSectionScalarWhereWithAggregatesInput = {
    AND?: AdvantageSectionScalarWhereWithAggregatesInput | AdvantageSectionScalarWhereWithAggregatesInput[]
    OR?: AdvantageSectionScalarWhereWithAggregatesInput[]
    NOT?: AdvantageSectionScalarWhereWithAggregatesInput | AdvantageSectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdvantageSection"> | number
    title?: StringWithAggregatesFilter<"AdvantageSection"> | string
    subtitle?: StringWithAggregatesFilter<"AdvantageSection"> | string
    items?: JsonWithAggregatesFilter<"AdvantageSection">
    isActive?: BoolWithAggregatesFilter<"AdvantageSection"> | boolean
  }

  export type QuickStartSectionWhereInput = {
    AND?: QuickStartSectionWhereInput | QuickStartSectionWhereInput[]
    OR?: QuickStartSectionWhereInput[]
    NOT?: QuickStartSectionWhereInput | QuickStartSectionWhereInput[]
    id?: IntFilter<"QuickStartSection"> | number
    title?: StringFilter<"QuickStartSection"> | string
    description?: StringFilter<"QuickStartSection"> | string
    buttons?: JsonFilter<"QuickStartSection">
    isActive?: BoolFilter<"QuickStartSection"> | boolean
  }

  export type QuickStartSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttons?: SortOrder
    isActive?: SortOrder
  }

  export type QuickStartSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuickStartSectionWhereInput | QuickStartSectionWhereInput[]
    OR?: QuickStartSectionWhereInput[]
    NOT?: QuickStartSectionWhereInput | QuickStartSectionWhereInput[]
    title?: StringFilter<"QuickStartSection"> | string
    description?: StringFilter<"QuickStartSection"> | string
    buttons?: JsonFilter<"QuickStartSection">
    isActive?: BoolFilter<"QuickStartSection"> | boolean
  }, "id">

  export type QuickStartSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttons?: SortOrder
    isActive?: SortOrder
    _count?: QuickStartSectionCountOrderByAggregateInput
    _avg?: QuickStartSectionAvgOrderByAggregateInput
    _max?: QuickStartSectionMaxOrderByAggregateInput
    _min?: QuickStartSectionMinOrderByAggregateInput
    _sum?: QuickStartSectionSumOrderByAggregateInput
  }

  export type QuickStartSectionScalarWhereWithAggregatesInput = {
    AND?: QuickStartSectionScalarWhereWithAggregatesInput | QuickStartSectionScalarWhereWithAggregatesInput[]
    OR?: QuickStartSectionScalarWhereWithAggregatesInput[]
    NOT?: QuickStartSectionScalarWhereWithAggregatesInput | QuickStartSectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuickStartSection"> | number
    title?: StringWithAggregatesFilter<"QuickStartSection"> | string
    description?: StringWithAggregatesFilter<"QuickStartSection"> | string
    buttons?: JsonWithAggregatesFilter<"QuickStartSection">
    isActive?: BoolWithAggregatesFilter<"QuickStartSection"> | boolean
  }

  export type ServicePageContentWhereInput = {
    AND?: ServicePageContentWhereInput | ServicePageContentWhereInput[]
    OR?: ServicePageContentWhereInput[]
    NOT?: ServicePageContentWhereInput | ServicePageContentWhereInput[]
    id?: IntFilter<"ServicePageContent"> | number
    platform?: EnumPlatformFilter<"ServicePageContent"> | $Enums.Platform
    serviceType?: EnumServiceTypeFilter<"ServicePageContent"> | $Enums.ServiceType
    slug?: StringNullableFilter<"ServicePageContent"> | string | null
    metaTitle?: StringNullableFilter<"ServicePageContent"> | string | null
    metaDescription?: StringNullableFilter<"ServicePageContent"> | string | null
    heroTitle?: StringFilter<"ServicePageContent"> | string
    heroSubtitle?: StringFilter<"ServicePageContent"> | string
    heroRating?: StringNullableFilter<"ServicePageContent"> | string | null
    heroReviewCount?: StringNullableFilter<"ServicePageContent"> | string | null
    assuranceCardText?: StringNullableFilter<"ServicePageContent"> | string | null
    learnMoreText?: StringNullableFilter<"ServicePageContent"> | string | null
    learnMoreModalContent?: StringNullableFilter<"ServicePageContent"> | string | null
    packages?: JsonFilter<"ServicePageContent">
    qualityCompare?: JsonNullableFilter<"ServicePageContent">
    howItWorks?: JsonNullableFilter<"ServicePageContent">
    isActive?: BoolFilter<"ServicePageContent"> | boolean
    updatedAt?: DateTimeFilter<"ServicePageContent"> | Date | string
    benefits?: JsonNullableFilter<"ServicePageContent">
    moreServicesTitle?: StringNullableFilter<"ServicePageContent"> | string | null
    moreServicesHighlight?: StringNullableFilter<"ServicePageContent"> | string | null
    moreServicesBody?: StringNullableFilter<"ServicePageContent"> | string | null
    moreServicesButtons?: JsonNullableFilter<"ServicePageContent">
  }

  export type ServicePageContentOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    slug?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrderInput | SortOrder
    heroReviewCount?: SortOrderInput | SortOrder
    assuranceCardText?: SortOrderInput | SortOrder
    learnMoreText?: SortOrderInput | SortOrder
    learnMoreModalContent?: SortOrderInput | SortOrder
    packages?: SortOrder
    qualityCompare?: SortOrderInput | SortOrder
    howItWorks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    benefits?: SortOrderInput | SortOrder
    moreServicesTitle?: SortOrderInput | SortOrder
    moreServicesHighlight?: SortOrderInput | SortOrder
    moreServicesBody?: SortOrderInput | SortOrder
    moreServicesButtons?: SortOrderInput | SortOrder
  }

  export type ServicePageContentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    platform_serviceType?: ServicePageContentPlatformServiceTypeCompoundUniqueInput
    AND?: ServicePageContentWhereInput | ServicePageContentWhereInput[]
    OR?: ServicePageContentWhereInput[]
    NOT?: ServicePageContentWhereInput | ServicePageContentWhereInput[]
    platform?: EnumPlatformFilter<"ServicePageContent"> | $Enums.Platform
    serviceType?: EnumServiceTypeFilter<"ServicePageContent"> | $Enums.ServiceType
    metaTitle?: StringNullableFilter<"ServicePageContent"> | string | null
    metaDescription?: StringNullableFilter<"ServicePageContent"> | string | null
    heroTitle?: StringFilter<"ServicePageContent"> | string
    heroSubtitle?: StringFilter<"ServicePageContent"> | string
    heroRating?: StringNullableFilter<"ServicePageContent"> | string | null
    heroReviewCount?: StringNullableFilter<"ServicePageContent"> | string | null
    assuranceCardText?: StringNullableFilter<"ServicePageContent"> | string | null
    learnMoreText?: StringNullableFilter<"ServicePageContent"> | string | null
    learnMoreModalContent?: StringNullableFilter<"ServicePageContent"> | string | null
    packages?: JsonFilter<"ServicePageContent">
    qualityCompare?: JsonNullableFilter<"ServicePageContent">
    howItWorks?: JsonNullableFilter<"ServicePageContent">
    isActive?: BoolFilter<"ServicePageContent"> | boolean
    updatedAt?: DateTimeFilter<"ServicePageContent"> | Date | string
    benefits?: JsonNullableFilter<"ServicePageContent">
    moreServicesTitle?: StringNullableFilter<"ServicePageContent"> | string | null
    moreServicesHighlight?: StringNullableFilter<"ServicePageContent"> | string | null
    moreServicesBody?: StringNullableFilter<"ServicePageContent"> | string | null
    moreServicesButtons?: JsonNullableFilter<"ServicePageContent">
  }, "id" | "slug" | "platform_serviceType">

  export type ServicePageContentOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    slug?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrderInput | SortOrder
    heroReviewCount?: SortOrderInput | SortOrder
    assuranceCardText?: SortOrderInput | SortOrder
    learnMoreText?: SortOrderInput | SortOrder
    learnMoreModalContent?: SortOrderInput | SortOrder
    packages?: SortOrder
    qualityCompare?: SortOrderInput | SortOrder
    howItWorks?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    benefits?: SortOrderInput | SortOrder
    moreServicesTitle?: SortOrderInput | SortOrder
    moreServicesHighlight?: SortOrderInput | SortOrder
    moreServicesBody?: SortOrderInput | SortOrder
    moreServicesButtons?: SortOrderInput | SortOrder
    _count?: ServicePageContentCountOrderByAggregateInput
    _avg?: ServicePageContentAvgOrderByAggregateInput
    _max?: ServicePageContentMaxOrderByAggregateInput
    _min?: ServicePageContentMinOrderByAggregateInput
    _sum?: ServicePageContentSumOrderByAggregateInput
  }

  export type ServicePageContentScalarWhereWithAggregatesInput = {
    AND?: ServicePageContentScalarWhereWithAggregatesInput | ServicePageContentScalarWhereWithAggregatesInput[]
    OR?: ServicePageContentScalarWhereWithAggregatesInput[]
    NOT?: ServicePageContentScalarWhereWithAggregatesInput | ServicePageContentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServicePageContent"> | number
    platform?: EnumPlatformWithAggregatesFilter<"ServicePageContent"> | $Enums.Platform
    serviceType?: EnumServiceTypeWithAggregatesFilter<"ServicePageContent"> | $Enums.ServiceType
    slug?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    heroTitle?: StringWithAggregatesFilter<"ServicePageContent"> | string
    heroSubtitle?: StringWithAggregatesFilter<"ServicePageContent"> | string
    heroRating?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    heroReviewCount?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    assuranceCardText?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    learnMoreText?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    learnMoreModalContent?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    packages?: JsonWithAggregatesFilter<"ServicePageContent">
    qualityCompare?: JsonNullableWithAggregatesFilter<"ServicePageContent">
    howItWorks?: JsonNullableWithAggregatesFilter<"ServicePageContent">
    isActive?: BoolWithAggregatesFilter<"ServicePageContent"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"ServicePageContent"> | Date | string
    benefits?: JsonNullableWithAggregatesFilter<"ServicePageContent">
    moreServicesTitle?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    moreServicesHighlight?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    moreServicesBody?: StringNullableWithAggregatesFilter<"ServicePageContent"> | string | null
    moreServicesButtons?: JsonNullableWithAggregatesFilter<"ServicePageContent">
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    id?: StringFilter<"FAQ"> | string
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    category?: StringNullableFilter<"FAQ"> | string | null
    platform?: EnumPlatformNullableFilter<"FAQ"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableFilter<"FAQ"> | $Enums.ServiceType | null
    displayOrder?: IntFilter<"FAQ"> | number
    isActive?: BoolFilter<"FAQ"> | boolean
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FAQ"> | Date | string | null
  }

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    category?: StringNullableFilter<"FAQ"> | string | null
    platform?: EnumPlatformNullableFilter<"FAQ"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableFilter<"FAQ"> | $Enums.ServiceType | null
    displayOrder?: IntFilter<"FAQ"> | number
    isActive?: BoolFilter<"FAQ"> | boolean
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeNullableFilter<"FAQ"> | Date | string | null
  }, "id">

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: FAQCountOrderByAggregateInput
    _avg?: FAQAvgOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
    _sum?: FAQSumOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQ"> | string
    question?: StringWithAggregatesFilter<"FAQ"> | string
    answer?: StringWithAggregatesFilter<"FAQ"> | string
    category?: StringNullableWithAggregatesFilter<"FAQ"> | string | null
    platform?: EnumPlatformNullableWithAggregatesFilter<"FAQ"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableWithAggregatesFilter<"FAQ"> | $Enums.ServiceType | null
    displayOrder?: IntWithAggregatesFilter<"FAQ"> | number
    isActive?: BoolWithAggregatesFilter<"FAQ"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"FAQ"> | Date | string | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringNullableFilter<"Review"> | string | null
    orderId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    authorName?: StringNullableFilter<"Review"> | string | null
    isPublished?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrder
    authorName?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringNullableFilter<"Review"> | string | null
    orderId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    authorName?: StringNullableFilter<"Review"> | string | null
    isPublished?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrder
    authorName?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringWithAggregatesFilter<"Review"> | string
    authorName?: StringNullableWithAggregatesFilter<"Review"> | string | null
    isPublished?: BoolWithAggregatesFilter<"Review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    tokenHash?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    tokenHash?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    tokenHash?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    handle?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    role?: StringNullableFilter<"Testimonial"> | string | null
    platform?: EnumPlatformNullableFilter<"Testimonial"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableFilter<"Testimonial"> | $Enums.ServiceType | null
    isApproved?: BoolFilter<"Testimonial"> | boolean
    isFeatured?: BoolFilter<"Testimonial"> | boolean
    displayOrder?: IntFilter<"Testimonial"> | number
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    handle?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    role?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    handle?: StringFilter<"Testimonial"> | string
    text?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    role?: StringNullableFilter<"Testimonial"> | string | null
    platform?: EnumPlatformNullableFilter<"Testimonial"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableFilter<"Testimonial"> | $Enums.ServiceType | null
    isApproved?: BoolFilter<"Testimonial"> | boolean
    isFeatured?: BoolFilter<"Testimonial"> | boolean
    displayOrder?: IntFilter<"Testimonial"> | number
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    handle?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    role?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    handle?: StringWithAggregatesFilter<"Testimonial"> | string
    text?: StringWithAggregatesFilter<"Testimonial"> | string
    rating?: IntWithAggregatesFilter<"Testimonial"> | number
    role?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    platform?: EnumPlatformNullableWithAggregatesFilter<"Testimonial"> | $Enums.Platform | null
    serviceType?: EnumServiceTypeNullableWithAggregatesFilter<"Testimonial"> | $Enums.ServiceType | null
    isApproved?: BoolWithAggregatesFilter<"Testimonial"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Testimonial"> | boolean
    displayOrder?: IntWithAggregatesFilter<"Testimonial"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    coverImage?: StringNullableFilter<"BlogPost"> | string | null
    authorId?: StringFilter<"BlogPost"> | string
    category?: StringNullableFilter<"BlogPost"> | string | null
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    isPublished?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    authorId?: SortOrder
    category?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    coverImage?: StringNullableFilter<"BlogPost"> | string | null
    authorId?: StringFilter<"BlogPost"> | string
    category?: StringNullableFilter<"BlogPost"> | string | null
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    isPublished?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    authorId?: SortOrder
    category?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    category?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    isPublished?: BoolWithAggregatesFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type LegalPageWhereInput = {
    AND?: LegalPageWhereInput | LegalPageWhereInput[]
    OR?: LegalPageWhereInput[]
    NOT?: LegalPageWhereInput | LegalPageWhereInput[]
    id?: StringFilter<"LegalPage"> | string
    slug?: StringFilter<"LegalPage"> | string
    title?: StringFilter<"LegalPage"> | string
    sections?: JsonFilter<"LegalPage">
    updatedAt?: DateTimeFilter<"LegalPage"> | Date | string
  }

  export type LegalPageOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    sections?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: LegalPageWhereInput | LegalPageWhereInput[]
    OR?: LegalPageWhereInput[]
    NOT?: LegalPageWhereInput | LegalPageWhereInput[]
    title?: StringFilter<"LegalPage"> | string
    sections?: JsonFilter<"LegalPage">
    updatedAt?: DateTimeFilter<"LegalPage"> | Date | string
  }, "id" | "slug">

  export type LegalPageOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    sections?: SortOrder
    updatedAt?: SortOrder
    _count?: LegalPageCountOrderByAggregateInput
    _max?: LegalPageMaxOrderByAggregateInput
    _min?: LegalPageMinOrderByAggregateInput
  }

  export type LegalPageScalarWhereWithAggregatesInput = {
    AND?: LegalPageScalarWhereWithAggregatesInput | LegalPageScalarWhereWithAggregatesInput[]
    OR?: LegalPageScalarWhereWithAggregatesInput[]
    NOT?: LegalPageScalarWhereWithAggregatesInput | LegalPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LegalPage"> | string
    slug?: StringWithAggregatesFilter<"LegalPage"> | string
    title?: StringWithAggregatesFilter<"LegalPage"> | string
    sections?: JsonWithAggregatesFilter<"LegalPage">
    updatedAt?: DateTimeWithAggregatesFilter<"LegalPage"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    type?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    type?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    body?: StringFilter<"EmailTemplate"> | string
    isActive?: BoolFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    type?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    body?: StringWithAggregatesFilter<"EmailTemplate"> | string
    isActive?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type BellNotificationWhereInput = {
    AND?: BellNotificationWhereInput | BellNotificationWhereInput[]
    OR?: BellNotificationWhereInput[]
    NOT?: BellNotificationWhereInput | BellNotificationWhereInput[]
    id?: StringFilter<"BellNotification"> | string
    title?: StringFilter<"BellNotification"> | string
    description?: StringFilter<"BellNotification"> | string
    icon?: StringFilter<"BellNotification"> | string
    priority?: StringFilter<"BellNotification"> | string
    category?: StringFilter<"BellNotification"> | string
    iconBg?: StringNullableFilter<"BellNotification"> | string | null
    isRead?: BoolFilter<"BellNotification"> | boolean
    createdAt?: DateTimeFilter<"BellNotification"> | Date | string
    updatedAt?: DateTimeFilter<"BellNotification"> | Date | string
  }

  export type BellNotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    iconBg?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BellNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BellNotificationWhereInput | BellNotificationWhereInput[]
    OR?: BellNotificationWhereInput[]
    NOT?: BellNotificationWhereInput | BellNotificationWhereInput[]
    title?: StringFilter<"BellNotification"> | string
    description?: StringFilter<"BellNotification"> | string
    icon?: StringFilter<"BellNotification"> | string
    priority?: StringFilter<"BellNotification"> | string
    category?: StringFilter<"BellNotification"> | string
    iconBg?: StringNullableFilter<"BellNotification"> | string | null
    isRead?: BoolFilter<"BellNotification"> | boolean
    createdAt?: DateTimeFilter<"BellNotification"> | Date | string
    updatedAt?: DateTimeFilter<"BellNotification"> | Date | string
  }, "id">

  export type BellNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    iconBg?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BellNotificationCountOrderByAggregateInput
    _max?: BellNotificationMaxOrderByAggregateInput
    _min?: BellNotificationMinOrderByAggregateInput
  }

  export type BellNotificationScalarWhereWithAggregatesInput = {
    AND?: BellNotificationScalarWhereWithAggregatesInput | BellNotificationScalarWhereWithAggregatesInput[]
    OR?: BellNotificationScalarWhereWithAggregatesInput[]
    NOT?: BellNotificationScalarWhereWithAggregatesInput | BellNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BellNotification"> | string
    title?: StringWithAggregatesFilter<"BellNotification"> | string
    description?: StringWithAggregatesFilter<"BellNotification"> | string
    icon?: StringWithAggregatesFilter<"BellNotification"> | string
    priority?: StringWithAggregatesFilter<"BellNotification"> | string
    category?: StringWithAggregatesFilter<"BellNotification"> | string
    iconBg?: StringNullableWithAggregatesFilter<"BellNotification"> | string | null
    isRead?: BoolWithAggregatesFilter<"BellNotification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BellNotification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BellNotification"> | Date | string
  }

  export type BannerMessageWhereInput = {
    AND?: BannerMessageWhereInput | BannerMessageWhereInput[]
    OR?: BannerMessageWhereInput[]
    NOT?: BannerMessageWhereInput | BannerMessageWhereInput[]
    id?: StringFilter<"BannerMessage"> | string
    text?: StringFilter<"BannerMessage"> | string
    isActive?: BoolFilter<"BannerMessage"> | boolean
    createdAt?: DateTimeFilter<"BannerMessage"> | Date | string
    updatedAt?: DateTimeFilter<"BannerMessage"> | Date | string
    icon?: StringFilter<"BannerMessage"> | string
  }

  export type BannerMessageOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icon?: SortOrder
  }

  export type BannerMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerMessageWhereInput | BannerMessageWhereInput[]
    OR?: BannerMessageWhereInput[]
    NOT?: BannerMessageWhereInput | BannerMessageWhereInput[]
    text?: StringFilter<"BannerMessage"> | string
    isActive?: BoolFilter<"BannerMessage"> | boolean
    createdAt?: DateTimeFilter<"BannerMessage"> | Date | string
    updatedAt?: DateTimeFilter<"BannerMessage"> | Date | string
    icon?: StringFilter<"BannerMessage"> | string
  }, "id">

  export type BannerMessageOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icon?: SortOrder
    _count?: BannerMessageCountOrderByAggregateInput
    _max?: BannerMessageMaxOrderByAggregateInput
    _min?: BannerMessageMinOrderByAggregateInput
  }

  export type BannerMessageScalarWhereWithAggregatesInput = {
    AND?: BannerMessageScalarWhereWithAggregatesInput | BannerMessageScalarWhereWithAggregatesInput[]
    OR?: BannerMessageScalarWhereWithAggregatesInput[]
    NOT?: BannerMessageScalarWhereWithAggregatesInput | BannerMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerMessage"> | string
    text?: StringWithAggregatesFilter<"BannerMessage"> | string
    isActive?: BoolWithAggregatesFilter<"BannerMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BannerMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BannerMessage"> | Date | string
    icon?: StringWithAggregatesFilter<"BannerMessage"> | string
  }

  export type IconAssetWhereInput = {
    AND?: IconAssetWhereInput | IconAssetWhereInput[]
    OR?: IconAssetWhereInput[]
    NOT?: IconAssetWhereInput | IconAssetWhereInput[]
    id?: StringFilter<"IconAsset"> | string
    name?: StringFilter<"IconAsset"> | string
    category?: StringNullableFilter<"IconAsset"> | string | null
    url?: StringNullableFilter<"IconAsset"> | string | null
    alt?: StringNullableFilter<"IconAsset"> | string | null
    displayOrder?: IntFilter<"IconAsset"> | number
    createdAt?: DateTimeFilter<"IconAsset"> | Date | string
    updatedAt?: DateTimeFilter<"IconAsset"> | Date | string
  }

  export type IconAssetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    alt?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IconAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: IconAssetWhereInput | IconAssetWhereInput[]
    OR?: IconAssetWhereInput[]
    NOT?: IconAssetWhereInput | IconAssetWhereInput[]
    category?: StringNullableFilter<"IconAsset"> | string | null
    url?: StringNullableFilter<"IconAsset"> | string | null
    alt?: StringNullableFilter<"IconAsset"> | string | null
    displayOrder?: IntFilter<"IconAsset"> | number
    createdAt?: DateTimeFilter<"IconAsset"> | Date | string
    updatedAt?: DateTimeFilter<"IconAsset"> | Date | string
  }, "id" | "name">

  export type IconAssetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    alt?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IconAssetCountOrderByAggregateInput
    _avg?: IconAssetAvgOrderByAggregateInput
    _max?: IconAssetMaxOrderByAggregateInput
    _min?: IconAssetMinOrderByAggregateInput
    _sum?: IconAssetSumOrderByAggregateInput
  }

  export type IconAssetScalarWhereWithAggregatesInput = {
    AND?: IconAssetScalarWhereWithAggregatesInput | IconAssetScalarWhereWithAggregatesInput[]
    OR?: IconAssetScalarWhereWithAggregatesInput[]
    NOT?: IconAssetScalarWhereWithAggregatesInput | IconAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IconAsset"> | string
    name?: StringWithAggregatesFilter<"IconAsset"> | string
    category?: StringNullableWithAggregatesFilter<"IconAsset"> | string | null
    url?: StringNullableWithAggregatesFilter<"IconAsset"> | string | null
    alt?: StringNullableWithAggregatesFilter<"IconAsset"> | string | null
    displayOrder?: IntWithAggregatesFilter<"IconAsset"> | number
    createdAt?: DateTimeWithAggregatesFilter<"IconAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IconAsset"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    type?: EnumCouponTypeFilter<"Coupon"> | $Enums.CouponType
    value?: FloatFilter<"Coupon"> | number
    currency?: StringNullableFilter<"Coupon"> | string | null
    status?: EnumCouponStatusFilter<"Coupon"> | $Enums.CouponStatus
    startsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    maxRedemptions?: IntNullableFilter<"Coupon"> | number | null
    maxRedemptionsPerUser?: IntNullableFilter<"Coupon"> | number | null
    minOrderAmount?: FloatNullableFilter<"Coupon"> | number | null
    applicableServices?: JsonNullableFilter<"Coupon">
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    redemptions?: CouponRedemptionListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    maxRedemptionsPerUser?: SortOrderInput | SortOrder
    minOrderAmount?: SortOrderInput | SortOrder
    applicableServices?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    redemptions?: CouponRedemptionOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    type?: EnumCouponTypeFilter<"Coupon"> | $Enums.CouponType
    value?: FloatFilter<"Coupon"> | number
    currency?: StringNullableFilter<"Coupon"> | string | null
    status?: EnumCouponStatusFilter<"Coupon"> | $Enums.CouponStatus
    startsAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    maxRedemptions?: IntNullableFilter<"Coupon"> | number | null
    maxRedemptionsPerUser?: IntNullableFilter<"Coupon"> | number | null
    minOrderAmount?: FloatNullableFilter<"Coupon"> | number | null
    applicableServices?: JsonNullableFilter<"Coupon">
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    redemptions?: CouponRedemptionListRelationFilter
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxRedemptions?: SortOrderInput | SortOrder
    maxRedemptionsPerUser?: SortOrderInput | SortOrder
    minOrderAmount?: SortOrderInput | SortOrder
    applicableServices?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    type?: EnumCouponTypeWithAggregatesFilter<"Coupon"> | $Enums.CouponType
    value?: FloatWithAggregatesFilter<"Coupon"> | number
    currency?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    status?: EnumCouponStatusWithAggregatesFilter<"Coupon"> | $Enums.CouponStatus
    startsAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    maxRedemptions?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    maxRedemptionsPerUser?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    minOrderAmount?: FloatNullableWithAggregatesFilter<"Coupon"> | number | null
    applicableServices?: JsonNullableWithAggregatesFilter<"Coupon">
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type CouponRedemptionWhereInput = {
    AND?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    OR?: CouponRedemptionWhereInput[]
    NOT?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    id?: StringFilter<"CouponRedemption"> | string
    couponId?: StringFilter<"CouponRedemption"> | string
    userId?: StringNullableFilter<"CouponRedemption"> | string | null
    orderId?: StringNullableFilter<"CouponRedemption"> | string | null
    redeemedAt?: DateTimeFilter<"CouponRedemption"> | Date | string
    coupon?: XOR<CouponRelationFilter, CouponWhereInput>
  }

  export type CouponRedemptionOrderByWithRelationInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    redeemedAt?: SortOrder
    coupon?: CouponOrderByWithRelationInput
  }

  export type CouponRedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    OR?: CouponRedemptionWhereInput[]
    NOT?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    couponId?: StringFilter<"CouponRedemption"> | string
    userId?: StringNullableFilter<"CouponRedemption"> | string | null
    orderId?: StringNullableFilter<"CouponRedemption"> | string | null
    redeemedAt?: DateTimeFilter<"CouponRedemption"> | Date | string
    coupon?: XOR<CouponRelationFilter, CouponWhereInput>
  }, "id">

  export type CouponRedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    redeemedAt?: SortOrder
    _count?: CouponRedemptionCountOrderByAggregateInput
    _max?: CouponRedemptionMaxOrderByAggregateInput
    _min?: CouponRedemptionMinOrderByAggregateInput
  }

  export type CouponRedemptionScalarWhereWithAggregatesInput = {
    AND?: CouponRedemptionScalarWhereWithAggregatesInput | CouponRedemptionScalarWhereWithAggregatesInput[]
    OR?: CouponRedemptionScalarWhereWithAggregatesInput[]
    NOT?: CouponRedemptionScalarWhereWithAggregatesInput | CouponRedemptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CouponRedemption"> | string
    couponId?: StringWithAggregatesFilter<"CouponRedemption"> | string
    userId?: StringNullableWithAggregatesFilter<"CouponRedemption"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"CouponRedemption"> | string | null
    redeemedAt?: DateTimeWithAggregatesFilter<"CouponRedemption"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    japServiceId?: string | null
    basePrice: number
    markup?: number
    finalPrice: number
    minQuantity?: number | null
    maxQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    japServiceId?: string | null
    basePrice: number
    markup?: number
    finalPrice: number
    minQuantity?: number | null
    maxQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    japServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    markup?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    japServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    markup?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    japServiceId?: string | null
    basePrice: number
    markup?: number
    finalPrice: number
    minQuantity?: number | null
    maxQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    japServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    markup?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    japServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    markup?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    gateway: $Enums.PaymentGateway
    transactionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderId: string
    gateway: $Enums.PaymentGateway
    transactionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderId: string
    gateway: $Enums.PaymentGateway
    transactionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpsellCreateInput = {
    id?: string
    title: string
    description?: string | null
    serviceId?: string | null
    packageId?: string | null
    basePrice: number
    discountType?: $Enums.DiscountType
    discountValue: number
    badgeText?: string | null
    badgeColor?: string | null
    badgeIcon?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    minSubtotal?: number | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UpsellUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    serviceId?: string | null
    packageId?: string | null
    basePrice: number
    discountType?: $Enums.DiscountType
    discountValue: number
    badgeText?: string | null
    badgeColor?: string | null
    badgeIcon?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    minSubtotal?: number | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UpsellUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    minSubtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpsellUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    minSubtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpsellCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    serviceId?: string | null
    packageId?: string | null
    basePrice: number
    discountType?: $Enums.DiscountType
    discountValue: number
    badgeText?: string | null
    badgeColor?: string | null
    badgeIcon?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    minSubtotal?: number | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UpsellUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    minSubtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpsellUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    badgeText?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    minSubtotal?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileCreateInput = {
    id?: string
    platform: $Enums.Platform
    username: string
    profileData: JsonNullValueInput | InputJsonValue
    posts?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    expiresAt: Date | string
  }

  export type SocialProfileUncheckedCreateInput = {
    id?: string
    platform: $Enums.Platform
    username: string
    profileData: JsonNullValueInput | InputJsonValue
    posts?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    expiresAt: Date | string
  }

  export type SocialProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    username?: StringFieldUpdateOperationsInput | string
    profileData?: JsonNullValueInput | InputJsonValue
    posts?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    username?: StringFieldUpdateOperationsInput | string
    profileData?: JsonNullValueInput | InputJsonValue
    posts?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileCreateManyInput = {
    id?: string
    platform: $Enums.Platform
    username: string
    profileData: JsonNullValueInput | InputJsonValue
    posts?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: Date | string
    expiresAt: Date | string
  }

  export type SocialProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    username?: StringFieldUpdateOperationsInput | string
    profileData?: JsonNullValueInput | InputJsonValue
    posts?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    username?: StringFieldUpdateOperationsInput | string
    profileData?: JsonNullValueInput | InputJsonValue
    posts?: NullableJsonNullValueInput | InputJsonValue
    cachedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProofCreateInput = {
    id?: string
    platform: string
    username: string
    service: string
    timeText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialProofUncheckedCreateInput = {
    id?: string
    platform: string
    username: string
    service: string
    timeText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialProofUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    timeText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProofUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    timeText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProofCreateManyInput = {
    id?: string
    platform: string
    username: string
    service: string
    timeText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialProofUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    timeText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialProofUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    timeText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSettingsCreateInput = {
    id?: string
    japApiUrl?: string | null
    japApiKey?: string | null
    checkoutApiKey?: string | null
    checkoutWebhookSecret?: string | null
    bigPayMeApiKey?: string | null
    bigPayMeWebhookSecret?: string | null
    rapidApiKey?: string | null
    rapidApiInstagramHost?: string | null
    rapidApiTikTokHost?: string | null
    rapidApiYouTubeHost?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpSecure?: boolean
    smtpUser?: string | null
    smtpPass?: string | null
    smtpFrom?: string | null
    defaultCurrency?: string
    cryptomusMerchantId?: string | null
    cryptomusApiKey?: string | null
    cryptomusDisplayName?: string | null
    cryptomusTestMode?: boolean
    bigPayMerchantId?: string | null
    bigPayDisplayName?: string | null
    bigPayApiSecret?: string | null
    bigPayTestMode?: boolean
    exitIntentEnabled?: boolean
    exitIntentTitle?: string | null
    exitIntentSubtitle?: string | null
    exitIntentDiscountCode?: string | null
    newServiceIndicator?: boolean
    supportEmail?: string | null
    updatedAt?: Date | string
    bannerDurationHours?: number
    bannerEnabled?: boolean
    inboxCount?: number
    teamCount?: number
    faviconUrl?: string | null
    footerLogoUrl?: string | null
    headerLogoUrl?: string | null
    homeMetaDescription?: string | null
    homeMetaTitle?: string | null
    robotsTxtContent?: string | null
    recaptchaSecretKey?: string | null
    recaptchaSiteKey?: string | null
    googleClientId?: string | null
    googleClientSecret?: string | null
    facebookClientId?: string | null
    facebookClientSecret?: string | null
    myFatoorahToken?: string | null
    myFatoorahBaseURL?: string | null
    myFatoorahTestMode?: boolean
    myFatoorahWebhookSecret?: string | null
  }

  export type AdminSettingsUncheckedCreateInput = {
    id?: string
    japApiUrl?: string | null
    japApiKey?: string | null
    checkoutApiKey?: string | null
    checkoutWebhookSecret?: string | null
    bigPayMeApiKey?: string | null
    bigPayMeWebhookSecret?: string | null
    rapidApiKey?: string | null
    rapidApiInstagramHost?: string | null
    rapidApiTikTokHost?: string | null
    rapidApiYouTubeHost?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpSecure?: boolean
    smtpUser?: string | null
    smtpPass?: string | null
    smtpFrom?: string | null
    defaultCurrency?: string
    cryptomusMerchantId?: string | null
    cryptomusApiKey?: string | null
    cryptomusDisplayName?: string | null
    cryptomusTestMode?: boolean
    bigPayMerchantId?: string | null
    bigPayDisplayName?: string | null
    bigPayApiSecret?: string | null
    bigPayTestMode?: boolean
    exitIntentEnabled?: boolean
    exitIntentTitle?: string | null
    exitIntentSubtitle?: string | null
    exitIntentDiscountCode?: string | null
    newServiceIndicator?: boolean
    supportEmail?: string | null
    updatedAt?: Date | string
    bannerDurationHours?: number
    bannerEnabled?: boolean
    inboxCount?: number
    teamCount?: number
    faviconUrl?: string | null
    footerLogoUrl?: string | null
    headerLogoUrl?: string | null
    homeMetaDescription?: string | null
    homeMetaTitle?: string | null
    robotsTxtContent?: string | null
    recaptchaSecretKey?: string | null
    recaptchaSiteKey?: string | null
    googleClientId?: string | null
    googleClientSecret?: string | null
    facebookClientId?: string | null
    facebookClientSecret?: string | null
    myFatoorahToken?: string | null
    myFatoorahBaseURL?: string | null
    myFatoorahTestMode?: boolean
    myFatoorahWebhookSecret?: string | null
  }

  export type AdminSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    japApiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    japApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiInstagramHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiTikTokHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiYouTubeHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPass?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFrom?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    cryptomusMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusTestMode?: BoolFieldUpdateOperationsInput | boolean
    bigPayMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayTestMode?: BoolFieldUpdateOperationsInput | boolean
    exitIntentEnabled?: BoolFieldUpdateOperationsInput | boolean
    exitIntentTitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentDiscountCode?: NullableStringFieldUpdateOperationsInput | string | null
    newServiceIndicator?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bannerDurationHours?: IntFieldUpdateOperationsInput | number
    bannerEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxCount?: IntFieldUpdateOperationsInput | number
    teamCount?: IntFieldUpdateOperationsInput | number
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    footerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    robotsTxtContent?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSiteKey?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientId?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahToken?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahBaseURL?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahTestMode?: BoolFieldUpdateOperationsInput | boolean
    myFatoorahWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    japApiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    japApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiInstagramHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiTikTokHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiYouTubeHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPass?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFrom?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    cryptomusMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusTestMode?: BoolFieldUpdateOperationsInput | boolean
    bigPayMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayTestMode?: BoolFieldUpdateOperationsInput | boolean
    exitIntentEnabled?: BoolFieldUpdateOperationsInput | boolean
    exitIntentTitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentDiscountCode?: NullableStringFieldUpdateOperationsInput | string | null
    newServiceIndicator?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bannerDurationHours?: IntFieldUpdateOperationsInput | number
    bannerEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxCount?: IntFieldUpdateOperationsInput | number
    teamCount?: IntFieldUpdateOperationsInput | number
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    footerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    robotsTxtContent?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSiteKey?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientId?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahToken?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahBaseURL?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahTestMode?: BoolFieldUpdateOperationsInput | boolean
    myFatoorahWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSettingsCreateManyInput = {
    id?: string
    japApiUrl?: string | null
    japApiKey?: string | null
    checkoutApiKey?: string | null
    checkoutWebhookSecret?: string | null
    bigPayMeApiKey?: string | null
    bigPayMeWebhookSecret?: string | null
    rapidApiKey?: string | null
    rapidApiInstagramHost?: string | null
    rapidApiTikTokHost?: string | null
    rapidApiYouTubeHost?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpSecure?: boolean
    smtpUser?: string | null
    smtpPass?: string | null
    smtpFrom?: string | null
    defaultCurrency?: string
    cryptomusMerchantId?: string | null
    cryptomusApiKey?: string | null
    cryptomusDisplayName?: string | null
    cryptomusTestMode?: boolean
    bigPayMerchantId?: string | null
    bigPayDisplayName?: string | null
    bigPayApiSecret?: string | null
    bigPayTestMode?: boolean
    exitIntentEnabled?: boolean
    exitIntentTitle?: string | null
    exitIntentSubtitle?: string | null
    exitIntentDiscountCode?: string | null
    newServiceIndicator?: boolean
    supportEmail?: string | null
    updatedAt?: Date | string
    bannerDurationHours?: number
    bannerEnabled?: boolean
    inboxCount?: number
    teamCount?: number
    faviconUrl?: string | null
    footerLogoUrl?: string | null
    headerLogoUrl?: string | null
    homeMetaDescription?: string | null
    homeMetaTitle?: string | null
    robotsTxtContent?: string | null
    recaptchaSecretKey?: string | null
    recaptchaSiteKey?: string | null
    googleClientId?: string | null
    googleClientSecret?: string | null
    facebookClientId?: string | null
    facebookClientSecret?: string | null
    myFatoorahToken?: string | null
    myFatoorahBaseURL?: string | null
    myFatoorahTestMode?: boolean
    myFatoorahWebhookSecret?: string | null
  }

  export type AdminSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    japApiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    japApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiInstagramHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiTikTokHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiYouTubeHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPass?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFrom?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    cryptomusMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusTestMode?: BoolFieldUpdateOperationsInput | boolean
    bigPayMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayTestMode?: BoolFieldUpdateOperationsInput | boolean
    exitIntentEnabled?: BoolFieldUpdateOperationsInput | boolean
    exitIntentTitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentDiscountCode?: NullableStringFieldUpdateOperationsInput | string | null
    newServiceIndicator?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bannerDurationHours?: IntFieldUpdateOperationsInput | number
    bannerEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxCount?: IntFieldUpdateOperationsInput | number
    teamCount?: IntFieldUpdateOperationsInput | number
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    footerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    robotsTxtContent?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSiteKey?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientId?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahToken?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahBaseURL?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahTestMode?: BoolFieldUpdateOperationsInput | boolean
    myFatoorahWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    japApiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    japApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayMeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiInstagramHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiTikTokHost?: NullableStringFieldUpdateOperationsInput | string | null
    rapidApiYouTubeHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPass?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFrom?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    cryptomusMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    cryptomusTestMode?: BoolFieldUpdateOperationsInput | boolean
    bigPayMerchantId?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayApiSecret?: NullableStringFieldUpdateOperationsInput | string | null
    bigPayTestMode?: BoolFieldUpdateOperationsInput | boolean
    exitIntentEnabled?: BoolFieldUpdateOperationsInput | boolean
    exitIntentTitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    exitIntentDiscountCode?: NullableStringFieldUpdateOperationsInput | string | null
    newServiceIndicator?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bannerDurationHours?: IntFieldUpdateOperationsInput | number
    bannerEnabled?: BoolFieldUpdateOperationsInput | boolean
    inboxCount?: IntFieldUpdateOperationsInput | number
    teamCount?: IntFieldUpdateOperationsInput | number
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    footerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    headerLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    homeMetaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    robotsTxtContent?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    recaptchaSiteKey?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientId?: NullableStringFieldUpdateOperationsInput | string | null
    googleClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahToken?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahBaseURL?: NullableStringFieldUpdateOperationsInput | string | null
    myFatoorahTestMode?: BoolFieldUpdateOperationsInput | boolean
    myFatoorahWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HomepageContentCreateInput = {
    id?: string
    heroTitle: string
    heroSubtitle: string
    heroRating?: string | null
    heroReviewCount?: string | null
    heroCtaButtons?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    heroProfileEngagement?: string | null
    heroProfileFollowers?: string | null
    heroProfileHandle?: string | null
    heroProfileLikes?: string | null
    heroProfileRole?: string | null
    influenceSubtitle?: string | null
    influenceTitle?: string | null
    platformSubtitle?: string | null
    platformTitle?: string | null
    quickStartDescription1?: string | null
    quickStartDescription2?: string | null
    quickStartTitle?: string | null
    whyChooseSubtitle?: string | null
    whyChooseTitle?: string | null
    platformCards?: NullableJsonNullValueInput | InputJsonValue
    heroProfileImage?: string | null
    influenceImage?: string | null
    influenceSteps?: NullableJsonNullValueInput | InputJsonValue
    quickStartButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type HomepageContentUncheckedCreateInput = {
    id?: string
    heroTitle: string
    heroSubtitle: string
    heroRating?: string | null
    heroReviewCount?: string | null
    heroCtaButtons?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    heroProfileEngagement?: string | null
    heroProfileFollowers?: string | null
    heroProfileHandle?: string | null
    heroProfileLikes?: string | null
    heroProfileRole?: string | null
    influenceSubtitle?: string | null
    influenceTitle?: string | null
    platformSubtitle?: string | null
    platformTitle?: string | null
    quickStartDescription1?: string | null
    quickStartDescription2?: string | null
    quickStartTitle?: string | null
    whyChooseSubtitle?: string | null
    whyChooseTitle?: string | null
    platformCards?: NullableJsonNullValueInput | InputJsonValue
    heroProfileImage?: string | null
    influenceImage?: string | null
    influenceSteps?: NullableJsonNullValueInput | InputJsonValue
    quickStartButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type HomepageContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    heroCtaButtons?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    heroProfileEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileFollowers?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileHandle?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileLikes?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileRole?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    influenceTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription1?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription2?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartTitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformCards?: NullableJsonNullValueInput | InputJsonValue
    heroProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSteps?: NullableJsonNullValueInput | InputJsonValue
    quickStartButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type HomepageContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    heroCtaButtons?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    heroProfileEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileFollowers?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileHandle?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileLikes?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileRole?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    influenceTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription1?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription2?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartTitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformCards?: NullableJsonNullValueInput | InputJsonValue
    heroProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSteps?: NullableJsonNullValueInput | InputJsonValue
    quickStartButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type HomepageContentCreateManyInput = {
    id?: string
    heroTitle: string
    heroSubtitle: string
    heroRating?: string | null
    heroReviewCount?: string | null
    heroCtaButtons?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    heroProfileEngagement?: string | null
    heroProfileFollowers?: string | null
    heroProfileHandle?: string | null
    heroProfileLikes?: string | null
    heroProfileRole?: string | null
    influenceSubtitle?: string | null
    influenceTitle?: string | null
    platformSubtitle?: string | null
    platformTitle?: string | null
    quickStartDescription1?: string | null
    quickStartDescription2?: string | null
    quickStartTitle?: string | null
    whyChooseSubtitle?: string | null
    whyChooseTitle?: string | null
    platformCards?: NullableJsonNullValueInput | InputJsonValue
    heroProfileImage?: string | null
    influenceImage?: string | null
    influenceSteps?: NullableJsonNullValueInput | InputJsonValue
    quickStartButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type HomepageContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    heroCtaButtons?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    heroProfileEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileFollowers?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileHandle?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileLikes?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileRole?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    influenceTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription1?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription2?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartTitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformCards?: NullableJsonNullValueInput | InputJsonValue
    heroProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSteps?: NullableJsonNullValueInput | InputJsonValue
    quickStartButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type HomepageContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    heroCtaButtons?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    heroProfileEngagement?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileFollowers?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileHandle?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileLikes?: NullableStringFieldUpdateOperationsInput | string | null
    heroProfileRole?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    influenceTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription1?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartDescription2?: NullableStringFieldUpdateOperationsInput | string | null
    quickStartTitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseSubtitle?: NullableStringFieldUpdateOperationsInput | string | null
    whyChooseTitle?: NullableStringFieldUpdateOperationsInput | string | null
    platformCards?: NullableJsonNullValueInput | InputJsonValue
    heroProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceImage?: NullableStringFieldUpdateOperationsInput | string | null
    influenceSteps?: NullableJsonNullValueInput | InputJsonValue
    quickStartButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TeamMemberCreateInput = {
    id?: string
    name: string
    role: string
    description: string
    twitterUrl?: string | null
    linkedinUrl?: string | null
    avatarUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    description: string
    twitterUrl?: string | null
    linkedinUrl?: string | null
    avatarUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    name: string
    role: string
    description: string
    twitterUrl?: string | null
    linkedinUrl?: string | null
    avatarUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSocialUpdateCreateInput = {
    handle: string
    item: string
    time: string
    displayOrder?: number
    isActive?: boolean
  }

  export type HeroSocialUpdateUncheckedCreateInput = {
    id?: number
    handle: string
    item: string
    time: string
    displayOrder?: number
    isActive?: boolean
  }

  export type HeroSocialUpdateUpdateInput = {
    handle?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HeroSocialUpdateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HeroSocialUpdateCreateManyInput = {
    id?: number
    handle: string
    item: string
    time: string
    displayOrder?: number
    isActive?: boolean
  }

  export type HeroSocialUpdateUpdateManyMutationInput = {
    handle?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HeroSocialUpdateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    handle?: StringFieldUpdateOperationsInput | string
    item?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromoBarCreateInput = {
    id?: string
    messages: JsonNullValueInput | InputJsonValue
    countdownSeconds?: number | null
    isVisible?: boolean
    displayOrder?: number
    updatedAt?: Date | string
  }

  export type PromoBarUncheckedCreateInput = {
    id?: string
    messages: JsonNullValueInput | InputJsonValue
    countdownSeconds?: number | null
    isVisible?: boolean
    displayOrder?: number
    updatedAt?: Date | string
  }

  export type PromoBarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    countdownSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoBarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    countdownSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoBarCreateManyInput = {
    id?: string
    messages: JsonNullValueInput | InputJsonValue
    countdownSeconds?: number | null
    isVisible?: boolean
    displayOrder?: number
    updatedAt?: Date | string
  }

  export type PromoBarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    countdownSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoBarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messages?: JsonNullValueInput | InputJsonValue
    countdownSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedOnCreateInput = {
    brandName: string
    logoUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    pageLinks?: FeaturedOnPageLinkCreateNestedManyWithoutFeaturedOnInput
  }

  export type FeaturedOnUncheckedCreateInput = {
    id?: number
    brandName: string
    logoUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    pageLinks?: FeaturedOnPageLinkUncheckedCreateNestedManyWithoutFeaturedOnInput
  }

  export type FeaturedOnUpdateInput = {
    brandName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pageLinks?: FeaturedOnPageLinkUpdateManyWithoutFeaturedOnNestedInput
  }

  export type FeaturedOnUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    pageLinks?: FeaturedOnPageLinkUncheckedUpdateManyWithoutFeaturedOnNestedInput
  }

  export type FeaturedOnCreateManyInput = {
    id?: number
    brandName: string
    logoUrl?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FeaturedOnUpdateManyMutationInput = {
    brandName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeaturedOnUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeaturedOnPageLinkCreateInput = {
    pagePath: string
    link?: string | null
    nofollow?: boolean
    featuredOn: FeaturedOnCreateNestedOneWithoutPageLinksInput
  }

  export type FeaturedOnPageLinkUncheckedCreateInput = {
    id?: number
    featuredOnId: number
    pagePath: string
    link?: string | null
    nofollow?: boolean
  }

  export type FeaturedOnPageLinkUpdateInput = {
    pagePath?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    nofollow?: BoolFieldUpdateOperationsInput | boolean
    featuredOn?: FeaturedOnUpdateOneRequiredWithoutPageLinksNestedInput
  }

  export type FeaturedOnPageLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    featuredOnId?: IntFieldUpdateOperationsInput | number
    pagePath?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    nofollow?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeaturedOnPageLinkCreateManyInput = {
    id?: number
    featuredOnId: number
    pagePath: string
    link?: string | null
    nofollow?: boolean
  }

  export type FeaturedOnPageLinkUpdateManyMutationInput = {
    pagePath?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    nofollow?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeaturedOnPageLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    featuredOnId?: IntFieldUpdateOperationsInput | number
    pagePath?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    nofollow?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformSectionCreateInput = {
    platform: $Enums.Platform
    title: string
    description: string
    tags: JsonNullValueInput | InputJsonValue
    ctaText: string
    isActive?: boolean
  }

  export type PlatformSectionUncheckedCreateInput = {
    id?: number
    platform: $Enums.Platform
    title: string
    description: string
    tags: JsonNullValueInput | InputJsonValue
    ctaText: string
    isActive?: boolean
  }

  export type PlatformSectionUpdateInput = {
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    ctaText?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformSectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    ctaText?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformSectionCreateManyInput = {
    id?: number
    platform: $Enums.Platform
    title: string
    description: string
    tags: JsonNullValueInput | InputJsonValue
    ctaText: string
    isActive?: boolean
  }

  export type PlatformSectionUpdateManyMutationInput = {
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    ctaText?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformSectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    ctaText?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GetStartedContentCreateInput = {
    platform: $Enums.Platform
    packType: $Enums.ServiceType
    quality: string
    features: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    pricing?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type GetStartedContentUncheckedCreateInput = {
    id?: number
    platform: $Enums.Platform
    packType: $Enums.ServiceType
    quality: string
    features: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    pricing?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type GetStartedContentUpdateInput = {
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    packType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quality?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    pricing?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GetStartedContentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    packType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quality?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    pricing?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GetStartedContentCreateManyInput = {
    id?: number
    platform: $Enums.Platform
    packType: $Enums.ServiceType
    quality: string
    features: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    pricing?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type GetStartedContentUpdateManyMutationInput = {
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    packType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quality?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    pricing?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GetStartedContentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    packType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quality?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    pricing?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InfluenceSectionCreateInput = {
    title: string
    description: string
    steps: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type InfluenceSectionUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    steps: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type InfluenceSectionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InfluenceSectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InfluenceSectionCreateManyInput = {
    id?: number
    title: string
    description: string
    steps: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type InfluenceSectionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InfluenceSectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvantageSectionCreateInput = {
    title: string
    subtitle: string
    items: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type AdvantageSectionUncheckedCreateInput = {
    id?: number
    title: string
    subtitle: string
    items: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type AdvantageSectionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvantageSectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvantageSectionCreateManyInput = {
    id?: number
    title: string
    subtitle: string
    items: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type AdvantageSectionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvantageSectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuickStartSectionCreateInput = {
    title: string
    description: string
    buttons: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type QuickStartSectionUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    buttons: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type QuickStartSectionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttons?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuickStartSectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttons?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuickStartSectionCreateManyInput = {
    id?: number
    title: string
    description: string
    buttons: JsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type QuickStartSectionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttons?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuickStartSectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    buttons?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicePageContentCreateInput = {
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    slug?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    heroTitle: string
    heroSubtitle: string
    heroRating?: string | null
    heroReviewCount?: string | null
    assuranceCardText?: string | null
    learnMoreText?: string | null
    learnMoreModalContent?: string | null
    packages: JsonNullValueInput | InputJsonValue
    qualityCompare?: NullableJsonNullValueInput | InputJsonValue
    howItWorks?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    moreServicesTitle?: string | null
    moreServicesHighlight?: string | null
    moreServicesBody?: string | null
    moreServicesButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServicePageContentUncheckedCreateInput = {
    id?: number
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    slug?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    heroTitle: string
    heroSubtitle: string
    heroRating?: string | null
    heroReviewCount?: string | null
    assuranceCardText?: string | null
    learnMoreText?: string | null
    learnMoreModalContent?: string | null
    packages: JsonNullValueInput | InputJsonValue
    qualityCompare?: NullableJsonNullValueInput | InputJsonValue
    howItWorks?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    moreServicesTitle?: string | null
    moreServicesHighlight?: string | null
    moreServicesBody?: string | null
    moreServicesButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServicePageContentUpdateInput = {
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    assuranceCardText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreModalContent?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    qualityCompare?: NullableJsonNullValueInput | InputJsonValue
    howItWorks?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    moreServicesTitle?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesHighlight?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesBody?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServicePageContentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    assuranceCardText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreModalContent?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    qualityCompare?: NullableJsonNullValueInput | InputJsonValue
    howItWorks?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    moreServicesTitle?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesHighlight?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesBody?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServicePageContentCreateManyInput = {
    id?: number
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    slug?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    heroTitle: string
    heroSubtitle: string
    heroRating?: string | null
    heroReviewCount?: string | null
    assuranceCardText?: string | null
    learnMoreText?: string | null
    learnMoreModalContent?: string | null
    packages: JsonNullValueInput | InputJsonValue
    qualityCompare?: NullableJsonNullValueInput | InputJsonValue
    howItWorks?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    moreServicesTitle?: string | null
    moreServicesHighlight?: string | null
    moreServicesBody?: string | null
    moreServicesButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServicePageContentUpdateManyMutationInput = {
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    assuranceCardText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreModalContent?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    qualityCompare?: NullableJsonNullValueInput | InputJsonValue
    howItWorks?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    moreServicesTitle?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesHighlight?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesBody?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServicePageContentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    heroRating?: NullableStringFieldUpdateOperationsInput | string | null
    heroReviewCount?: NullableStringFieldUpdateOperationsInput | string | null
    assuranceCardText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreText?: NullableStringFieldUpdateOperationsInput | string | null
    learnMoreModalContent?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    qualityCompare?: NullableJsonNullValueInput | InputJsonValue
    howItWorks?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: NullableJsonNullValueInput | InputJsonValue
    moreServicesTitle?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesHighlight?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesBody?: NullableStringFieldUpdateOperationsInput | string | null
    moreServicesButtons?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FAQCreateInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type FAQUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type FAQUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FAQUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FAQCreateManyInput = {
    id?: string
    question: string
    answer: string
    category?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type FAQUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FAQUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutReviewsInput
    user?: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId?: string | null
    orderId?: string | null
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutReviewsNestedInput
    user?: UserUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId?: string | null
    orderId?: string | null
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    id?: string
    handle: string
    text: string
    rating: number
    role?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    isApproved?: boolean
    isFeatured?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    handle: string
    text: string
    rating: number
    role?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    isApproved?: boolean
    isFeatured?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateManyInput = {
    id?: string
    handle: string
    text: string
    rating: number
    role?: string | null
    platform?: $Enums.Platform | null
    serviceType?: $Enums.ServiceType | null
    isApproved?: boolean
    isFeatured?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableEnumPlatformFieldUpdateOperationsInput | $Enums.Platform | null
    serviceType?: NullableEnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    authorId: string
    category?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    authorId: string
    category?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalPageCreateInput = {
    id?: string
    slug: string
    title: string
    sections: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type LegalPageUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    sections: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type LegalPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sections?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sections?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalPageCreateManyInput = {
    id?: string
    slug: string
    title: string
    sections: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type LegalPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sections?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sections?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    type: string
    subject: string
    body: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    type: string
    subject: string
    body: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    type: string
    subject: string
    body: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BellNotificationCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    priority?: string
    category?: string
    iconBg?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BellNotificationUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    priority?: string
    category?: string
    iconBg?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BellNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    iconBg?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BellNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    iconBg?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BellNotificationCreateManyInput = {
    id?: string
    title: string
    description: string
    icon: string
    priority?: string
    category?: string
    iconBg?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BellNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    iconBg?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BellNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    iconBg?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerMessageCreateInput = {
    id?: string
    text: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icon?: string
  }

  export type BannerMessageUncheckedCreateInput = {
    id?: string
    text: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icon?: string
  }

  export type BannerMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type BannerMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type BannerMessageCreateManyInput = {
    id?: string
    text: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icon?: string
  }

  export type BannerMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type BannerMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type IconAssetCreateInput = {
    id?: string
    name: string
    category?: string | null
    url?: string | null
    alt?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IconAssetUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    url?: string | null
    alt?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IconAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IconAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IconAssetCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    url?: string | null
    alt?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IconAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IconAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    type: $Enums.CouponType
    value: number
    currency?: string | null
    status?: $Enums.CouponStatus
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    maxRedemptions?: number | null
    maxRedemptionsPerUser?: number | null
    minOrderAmount?: number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    type: $Enums.CouponType
    value: number
    currency?: string | null
    status?: $Enums.CouponStatus
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    maxRedemptions?: number | null
    maxRedemptionsPerUser?: number | null
    minOrderAmount?: number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    value?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptionsPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    value?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptionsPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    type: $Enums.CouponType
    value: number
    currency?: string | null
    status?: $Enums.CouponStatus
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    maxRedemptions?: number | null
    maxRedemptionsPerUser?: number | null
    minOrderAmount?: number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    value?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptionsPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    value?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptionsPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionCreateInput = {
    id?: string
    userId?: string | null
    orderId?: string | null
    redeemedAt?: Date | string
    coupon: CouponCreateNestedOneWithoutRedemptionsInput
  }

  export type CouponRedemptionUncheckedCreateInput = {
    id?: string
    couponId: string
    userId?: string | null
    orderId?: string | null
    redeemedAt?: Date | string
  }

  export type CouponRedemptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneRequiredWithoutRedemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionCreateManyInput = {
    id?: string
    couponId: string
    userId?: string | null
    orderId?: string | null
    redeemedAt?: Date | string
  }

  export type CouponRedemptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformFilter<$PrismaModel> | $Enums.Platform
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    link?: SortOrder
    japOrderId?: SortOrder
    japStatus?: SortOrder
    upsellData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    link?: SortOrder
    japOrderId?: SortOrder
    japStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    link?: SortOrder
    japOrderId?: SortOrder
    japStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EnumPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformWithAggregatesFilter<$PrismaModel> | $Enums.Platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformFilter<$PrismaModel>
    _max?: NestedEnumPlatformFilter<$PrismaModel>
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ServicePlatformServiceTypeJapServiceIdCompoundUniqueInput = {
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    japServiceId: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    japServiceId?: SortOrder
    basePrice?: SortOrder
    markup?: SortOrder
    finalPrice?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    markup?: SortOrder
    finalPrice?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    japServiceId?: SortOrder
    basePrice?: SortOrder
    markup?: SortOrder
    finalPrice?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    japServiceId?: SortOrder
    basePrice?: SortOrder
    markup?: SortOrder
    finalPrice?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    basePrice?: SortOrder
    markup?: SortOrder
    finalPrice?: SortOrder
    minQuantity?: SortOrder
    maxQuantity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPaymentGatewayFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayFilter<$PrismaModel> | $Enums.PaymentGateway
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    webhookData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentGatewayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayWithAggregatesFilter<$PrismaModel> | $Enums.PaymentGateway
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentGatewayFilter<$PrismaModel>
    _max?: NestedEnumPaymentGatewayFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type EnumPlatformNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel> | null
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlatformNullableFilter<$PrismaModel> | $Enums.Platform | null
  }

  export type EnumServiceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceTypeNullableFilter<$PrismaModel> | $Enums.ServiceType | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UpsellCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceId?: SortOrder
    packageId?: SortOrder
    basePrice?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    badgeText?: SortOrder
    badgeColor?: SortOrder
    badgeIcon?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    minSubtotal?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UpsellAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    discountValue?: SortOrder
    minSubtotal?: SortOrder
    sortOrder?: SortOrder
  }

  export type UpsellMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceId?: SortOrder
    packageId?: SortOrder
    basePrice?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    badgeText?: SortOrder
    badgeColor?: SortOrder
    badgeIcon?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    minSubtotal?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UpsellMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    serviceId?: SortOrder
    packageId?: SortOrder
    basePrice?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    badgeText?: SortOrder
    badgeColor?: SortOrder
    badgeIcon?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    minSubtotal?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UpsellSumOrderByAggregateInput = {
    basePrice?: SortOrder
    discountValue?: SortOrder
    minSubtotal?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type EnumPlatformNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel> | null
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlatformNullableWithAggregatesFilter<$PrismaModel> | $Enums.Platform | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlatformNullableFilter<$PrismaModel>
    _max?: NestedEnumPlatformNullableFilter<$PrismaModel>
  }

  export type EnumServiceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SocialProfilePlatformUsernameCompoundUniqueInput = {
    platform: $Enums.Platform
    username: string
  }

  export type SocialProfileCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    profileData?: SortOrder
    posts?: SortOrder
    cachedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SocialProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    cachedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SocialProfileMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    cachedAt?: SortOrder
    expiresAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SocialProofCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    service?: SortOrder
    timeText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialProofAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type SocialProofMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    service?: SortOrder
    timeText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialProofMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    username?: SortOrder
    service?: SortOrder
    timeText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialProofSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type AdminSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    japApiUrl?: SortOrder
    japApiKey?: SortOrder
    checkoutApiKey?: SortOrder
    checkoutWebhookSecret?: SortOrder
    bigPayMeApiKey?: SortOrder
    bigPayMeWebhookSecret?: SortOrder
    rapidApiKey?: SortOrder
    rapidApiInstagramHost?: SortOrder
    rapidApiTikTokHost?: SortOrder
    rapidApiYouTubeHost?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrder
    smtpPass?: SortOrder
    smtpFrom?: SortOrder
    defaultCurrency?: SortOrder
    cryptomusMerchantId?: SortOrder
    cryptomusApiKey?: SortOrder
    cryptomusDisplayName?: SortOrder
    cryptomusTestMode?: SortOrder
    bigPayMerchantId?: SortOrder
    bigPayDisplayName?: SortOrder
    bigPayApiSecret?: SortOrder
    bigPayTestMode?: SortOrder
    exitIntentEnabled?: SortOrder
    exitIntentTitle?: SortOrder
    exitIntentSubtitle?: SortOrder
    exitIntentDiscountCode?: SortOrder
    newServiceIndicator?: SortOrder
    supportEmail?: SortOrder
    updatedAt?: SortOrder
    bannerDurationHours?: SortOrder
    bannerEnabled?: SortOrder
    inboxCount?: SortOrder
    teamCount?: SortOrder
    faviconUrl?: SortOrder
    footerLogoUrl?: SortOrder
    headerLogoUrl?: SortOrder
    homeMetaDescription?: SortOrder
    homeMetaTitle?: SortOrder
    robotsTxtContent?: SortOrder
    recaptchaSecretKey?: SortOrder
    recaptchaSiteKey?: SortOrder
    googleClientId?: SortOrder
    googleClientSecret?: SortOrder
    facebookClientId?: SortOrder
    facebookClientSecret?: SortOrder
    myFatoorahToken?: SortOrder
    myFatoorahBaseURL?: SortOrder
    myFatoorahTestMode?: SortOrder
    myFatoorahWebhookSecret?: SortOrder
  }

  export type AdminSettingsAvgOrderByAggregateInput = {
    smtpPort?: SortOrder
    bannerDurationHours?: SortOrder
    inboxCount?: SortOrder
    teamCount?: SortOrder
  }

  export type AdminSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    japApiUrl?: SortOrder
    japApiKey?: SortOrder
    checkoutApiKey?: SortOrder
    checkoutWebhookSecret?: SortOrder
    bigPayMeApiKey?: SortOrder
    bigPayMeWebhookSecret?: SortOrder
    rapidApiKey?: SortOrder
    rapidApiInstagramHost?: SortOrder
    rapidApiTikTokHost?: SortOrder
    rapidApiYouTubeHost?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrder
    smtpPass?: SortOrder
    smtpFrom?: SortOrder
    defaultCurrency?: SortOrder
    cryptomusMerchantId?: SortOrder
    cryptomusApiKey?: SortOrder
    cryptomusDisplayName?: SortOrder
    cryptomusTestMode?: SortOrder
    bigPayMerchantId?: SortOrder
    bigPayDisplayName?: SortOrder
    bigPayApiSecret?: SortOrder
    bigPayTestMode?: SortOrder
    exitIntentEnabled?: SortOrder
    exitIntentTitle?: SortOrder
    exitIntentSubtitle?: SortOrder
    exitIntentDiscountCode?: SortOrder
    newServiceIndicator?: SortOrder
    supportEmail?: SortOrder
    updatedAt?: SortOrder
    bannerDurationHours?: SortOrder
    bannerEnabled?: SortOrder
    inboxCount?: SortOrder
    teamCount?: SortOrder
    faviconUrl?: SortOrder
    footerLogoUrl?: SortOrder
    headerLogoUrl?: SortOrder
    homeMetaDescription?: SortOrder
    homeMetaTitle?: SortOrder
    robotsTxtContent?: SortOrder
    recaptchaSecretKey?: SortOrder
    recaptchaSiteKey?: SortOrder
    googleClientId?: SortOrder
    googleClientSecret?: SortOrder
    facebookClientId?: SortOrder
    facebookClientSecret?: SortOrder
    myFatoorahToken?: SortOrder
    myFatoorahBaseURL?: SortOrder
    myFatoorahTestMode?: SortOrder
    myFatoorahWebhookSecret?: SortOrder
  }

  export type AdminSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    japApiUrl?: SortOrder
    japApiKey?: SortOrder
    checkoutApiKey?: SortOrder
    checkoutWebhookSecret?: SortOrder
    bigPayMeApiKey?: SortOrder
    bigPayMeWebhookSecret?: SortOrder
    rapidApiKey?: SortOrder
    rapidApiInstagramHost?: SortOrder
    rapidApiTikTokHost?: SortOrder
    rapidApiYouTubeHost?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrder
    smtpPass?: SortOrder
    smtpFrom?: SortOrder
    defaultCurrency?: SortOrder
    cryptomusMerchantId?: SortOrder
    cryptomusApiKey?: SortOrder
    cryptomusDisplayName?: SortOrder
    cryptomusTestMode?: SortOrder
    bigPayMerchantId?: SortOrder
    bigPayDisplayName?: SortOrder
    bigPayApiSecret?: SortOrder
    bigPayTestMode?: SortOrder
    exitIntentEnabled?: SortOrder
    exitIntentTitle?: SortOrder
    exitIntentSubtitle?: SortOrder
    exitIntentDiscountCode?: SortOrder
    newServiceIndicator?: SortOrder
    supportEmail?: SortOrder
    updatedAt?: SortOrder
    bannerDurationHours?: SortOrder
    bannerEnabled?: SortOrder
    inboxCount?: SortOrder
    teamCount?: SortOrder
    faviconUrl?: SortOrder
    footerLogoUrl?: SortOrder
    headerLogoUrl?: SortOrder
    homeMetaDescription?: SortOrder
    homeMetaTitle?: SortOrder
    robotsTxtContent?: SortOrder
    recaptchaSecretKey?: SortOrder
    recaptchaSiteKey?: SortOrder
    googleClientId?: SortOrder
    googleClientSecret?: SortOrder
    facebookClientId?: SortOrder
    facebookClientSecret?: SortOrder
    myFatoorahToken?: SortOrder
    myFatoorahBaseURL?: SortOrder
    myFatoorahTestMode?: SortOrder
    myFatoorahWebhookSecret?: SortOrder
  }

  export type AdminSettingsSumOrderByAggregateInput = {
    smtpPort?: SortOrder
    bannerDurationHours?: SortOrder
    inboxCount?: SortOrder
    teamCount?: SortOrder
  }

  export type HomepageContentCountOrderByAggregateInput = {
    id?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrder
    heroReviewCount?: SortOrder
    heroCtaButtons?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    benefits?: SortOrder
    heroProfileEngagement?: SortOrder
    heroProfileFollowers?: SortOrder
    heroProfileHandle?: SortOrder
    heroProfileLikes?: SortOrder
    heroProfileRole?: SortOrder
    influenceSubtitle?: SortOrder
    influenceTitle?: SortOrder
    platformSubtitle?: SortOrder
    platformTitle?: SortOrder
    quickStartDescription1?: SortOrder
    quickStartDescription2?: SortOrder
    quickStartTitle?: SortOrder
    whyChooseSubtitle?: SortOrder
    whyChooseTitle?: SortOrder
    platformCards?: SortOrder
    heroProfileImage?: SortOrder
    influenceImage?: SortOrder
    influenceSteps?: SortOrder
    quickStartButtons?: SortOrder
  }

  export type HomepageContentMaxOrderByAggregateInput = {
    id?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrder
    heroReviewCount?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    heroProfileEngagement?: SortOrder
    heroProfileFollowers?: SortOrder
    heroProfileHandle?: SortOrder
    heroProfileLikes?: SortOrder
    heroProfileRole?: SortOrder
    influenceSubtitle?: SortOrder
    influenceTitle?: SortOrder
    platformSubtitle?: SortOrder
    platformTitle?: SortOrder
    quickStartDescription1?: SortOrder
    quickStartDescription2?: SortOrder
    quickStartTitle?: SortOrder
    whyChooseSubtitle?: SortOrder
    whyChooseTitle?: SortOrder
    heroProfileImage?: SortOrder
    influenceImage?: SortOrder
  }

  export type HomepageContentMinOrderByAggregateInput = {
    id?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrder
    heroReviewCount?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    heroProfileEngagement?: SortOrder
    heroProfileFollowers?: SortOrder
    heroProfileHandle?: SortOrder
    heroProfileLikes?: SortOrder
    heroProfileRole?: SortOrder
    influenceSubtitle?: SortOrder
    influenceTitle?: SortOrder
    platformSubtitle?: SortOrder
    platformTitle?: SortOrder
    quickStartDescription1?: SortOrder
    quickStartDescription2?: SortOrder
    quickStartTitle?: SortOrder
    whyChooseSubtitle?: SortOrder
    whyChooseTitle?: SortOrder
    heroProfileImage?: SortOrder
    influenceImage?: SortOrder
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    description?: SortOrder
    twitterUrl?: SortOrder
    linkedinUrl?: SortOrder
    avatarUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    description?: SortOrder
    twitterUrl?: SortOrder
    linkedinUrl?: SortOrder
    avatarUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    description?: SortOrder
    twitterUrl?: SortOrder
    linkedinUrl?: SortOrder
    avatarUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type HeroSocialUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    handle?: SortOrder
    item?: SortOrder
    time?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type HeroSocialUpdateAvgOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type HeroSocialUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    handle?: SortOrder
    item?: SortOrder
    time?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type HeroSocialUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    handle?: SortOrder
    item?: SortOrder
    time?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type HeroSocialUpdateSumOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type PromoBarCountOrderByAggregateInput = {
    id?: SortOrder
    messages?: SortOrder
    countdownSeconds?: SortOrder
    isVisible?: SortOrder
    displayOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoBarAvgOrderByAggregateInput = {
    countdownSeconds?: SortOrder
    displayOrder?: SortOrder
  }

  export type PromoBarMaxOrderByAggregateInput = {
    id?: SortOrder
    countdownSeconds?: SortOrder
    isVisible?: SortOrder
    displayOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoBarMinOrderByAggregateInput = {
    id?: SortOrder
    countdownSeconds?: SortOrder
    isVisible?: SortOrder
    displayOrder?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoBarSumOrderByAggregateInput = {
    countdownSeconds?: SortOrder
    displayOrder?: SortOrder
  }

  export type FeaturedOnPageLinkListRelationFilter = {
    every?: FeaturedOnPageLinkWhereInput
    some?: FeaturedOnPageLinkWhereInput
    none?: FeaturedOnPageLinkWhereInput
  }

  export type FeaturedOnPageLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeaturedOnCountOrderByAggregateInput = {
    id?: SortOrder
    brandName?: SortOrder
    logoUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FeaturedOnAvgOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type FeaturedOnMaxOrderByAggregateInput = {
    id?: SortOrder
    brandName?: SortOrder
    logoUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FeaturedOnMinOrderByAggregateInput = {
    id?: SortOrder
    brandName?: SortOrder
    logoUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
  }

  export type FeaturedOnSumOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type FeaturedOnRelationFilter = {
    is?: FeaturedOnWhereInput
    isNot?: FeaturedOnWhereInput
  }

  export type FeaturedOnPageLinkCountOrderByAggregateInput = {
    id?: SortOrder
    featuredOnId?: SortOrder
    pagePath?: SortOrder
    link?: SortOrder
    nofollow?: SortOrder
  }

  export type FeaturedOnPageLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    featuredOnId?: SortOrder
  }

  export type FeaturedOnPageLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    featuredOnId?: SortOrder
    pagePath?: SortOrder
    link?: SortOrder
    nofollow?: SortOrder
  }

  export type FeaturedOnPageLinkMinOrderByAggregateInput = {
    id?: SortOrder
    featuredOnId?: SortOrder
    pagePath?: SortOrder
    link?: SortOrder
    nofollow?: SortOrder
  }

  export type FeaturedOnPageLinkSumOrderByAggregateInput = {
    id?: SortOrder
    featuredOnId?: SortOrder
  }

  export type PlatformSectionCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    ctaText?: SortOrder
    isActive?: SortOrder
  }

  export type PlatformSectionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlatformSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    isActive?: SortOrder
  }

  export type PlatformSectionMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    isActive?: SortOrder
  }

  export type PlatformSectionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GetStartedContentPlatformPackTypeQualityCompoundUniqueInput = {
    platform: $Enums.Platform
    packType: $Enums.ServiceType
    quality: string
  }

  export type GetStartedContentCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    packType?: SortOrder
    quality?: SortOrder
    features?: SortOrder
    explanation?: SortOrder
    pricing?: SortOrder
    isActive?: SortOrder
  }

  export type GetStartedContentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GetStartedContentMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    packType?: SortOrder
    quality?: SortOrder
    explanation?: SortOrder
    isActive?: SortOrder
  }

  export type GetStartedContentMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    packType?: SortOrder
    quality?: SortOrder
    explanation?: SortOrder
    isActive?: SortOrder
  }

  export type GetStartedContentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InfluenceSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
  }

  export type InfluenceSectionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InfluenceSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type InfluenceSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type InfluenceSectionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdvantageSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    items?: SortOrder
    isActive?: SortOrder
  }

  export type AdvantageSectionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdvantageSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    isActive?: SortOrder
  }

  export type AdvantageSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    isActive?: SortOrder
  }

  export type AdvantageSectionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuickStartSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    buttons?: SortOrder
    isActive?: SortOrder
  }

  export type QuickStartSectionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuickStartSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type QuickStartSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type QuickStartSectionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServicePageContentPlatformServiceTypeCompoundUniqueInput = {
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
  }

  export type ServicePageContentCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrder
    heroReviewCount?: SortOrder
    assuranceCardText?: SortOrder
    learnMoreText?: SortOrder
    learnMoreModalContent?: SortOrder
    packages?: SortOrder
    qualityCompare?: SortOrder
    howItWorks?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    benefits?: SortOrder
    moreServicesTitle?: SortOrder
    moreServicesHighlight?: SortOrder
    moreServicesBody?: SortOrder
    moreServicesButtons?: SortOrder
  }

  export type ServicePageContentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServicePageContentMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrder
    heroReviewCount?: SortOrder
    assuranceCardText?: SortOrder
    learnMoreText?: SortOrder
    learnMoreModalContent?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    moreServicesTitle?: SortOrder
    moreServicesHighlight?: SortOrder
    moreServicesBody?: SortOrder
  }

  export type ServicePageContentMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    heroRating?: SortOrder
    heroReviewCount?: SortOrder
    assuranceCardText?: SortOrder
    learnMoreText?: SortOrder
    learnMoreModalContent?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    moreServicesTitle?: SortOrder
    moreServicesHighlight?: SortOrder
    moreServicesBody?: SortOrder
  }

  export type ServicePageContentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    authorName?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    authorName?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    authorName?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    handle?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    role?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    rating?: SortOrder
    displayOrder?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    handle?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    role?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    handle?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    role?: SortOrder
    platform?: SortOrder
    serviceType?: SortOrder
    isApproved?: SortOrder
    isFeatured?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    rating?: SortOrder
    displayOrder?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    authorId?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    authorId?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    authorId?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalPageCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    sections?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalPageMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalPageMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BellNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    iconBg?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BellNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    iconBg?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BellNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    iconBg?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMessageCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icon?: SortOrder
  }

  export type BannerMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icon?: SortOrder
  }

  export type BannerMessageMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icon?: SortOrder
  }

  export type IconAssetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IconAssetAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type IconAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IconAssetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IconAssetSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type EnumCouponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeFilter<$PrismaModel> | $Enums.CouponType
  }

  export type EnumCouponStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusFilter<$PrismaModel> | $Enums.CouponStatus
  }

  export type CouponRedemptionListRelationFilter = {
    every?: CouponRedemptionWhereInput
    some?: CouponRedemptionWhereInput
    none?: CouponRedemptionWhereInput
  }

  export type CouponRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    maxRedemptions?: SortOrder
    maxRedemptionsPerUser?: SortOrder
    minOrderAmount?: SortOrder
    applicableServices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    value?: SortOrder
    maxRedemptions?: SortOrder
    maxRedemptionsPerUser?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    maxRedemptions?: SortOrder
    maxRedemptionsPerUser?: SortOrder
    minOrderAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    maxRedemptions?: SortOrder
    maxRedemptionsPerUser?: SortOrder
    minOrderAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    value?: SortOrder
    maxRedemptions?: SortOrder
    maxRedemptionsPerUser?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type EnumCouponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel> | $Enums.CouponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponTypeFilter<$PrismaModel>
    _max?: NestedEnumCouponTypeFilter<$PrismaModel>
  }

  export type EnumCouponStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusWithAggregatesFilter<$PrismaModel> | $Enums.CouponStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponStatusFilter<$PrismaModel>
    _max?: NestedEnumCouponStatusFilter<$PrismaModel>
  }

  export type CouponRelationFilter = {
    is?: CouponWhereInput
    isNot?: CouponWhereInput
  }

  export type CouponRedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type CouponRedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type CouponRedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumPlatformFieldUpdateOperationsInput = {
    set?: $Enums.Platform
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type ServiceUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput
    upsert?: ServiceUpsertWithoutOrdersInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutOrdersInput, ServiceUpdateWithoutOrdersInput>, ServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type PaymentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderInput | ReviewUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderInput | ReviewUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderInput | ReviewUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderInput | ReviewUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderInput | ReviewUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderInput | ReviewUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutServiceInput | OrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutServiceInput | OrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutServiceInput | OrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput> | OrderCreateWithoutServiceInput[] | OrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServiceInput | OrderCreateOrConnectWithoutServiceInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutServiceInput | OrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: OrderCreateManyServiceInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutServiceInput | OrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutServiceInput | OrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumPaymentGatewayFieldUpdateOperationsInput = {
    set?: $Enums.PaymentGateway
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type OrderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    upsert?: OrderUpsertWithoutPaymentInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type NullableEnumPlatformFieldUpdateOperationsInput = {
    set?: $Enums.Platform | null
  }

  export type NullableEnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FeaturedOnPageLinkCreateNestedManyWithoutFeaturedOnInput = {
    create?: XOR<FeaturedOnPageLinkCreateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput> | FeaturedOnPageLinkCreateWithoutFeaturedOnInput[] | FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput[]
    connectOrCreate?: FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput | FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput[]
    createMany?: FeaturedOnPageLinkCreateManyFeaturedOnInputEnvelope
    connect?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
  }

  export type FeaturedOnPageLinkUncheckedCreateNestedManyWithoutFeaturedOnInput = {
    create?: XOR<FeaturedOnPageLinkCreateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput> | FeaturedOnPageLinkCreateWithoutFeaturedOnInput[] | FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput[]
    connectOrCreate?: FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput | FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput[]
    createMany?: FeaturedOnPageLinkCreateManyFeaturedOnInputEnvelope
    connect?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
  }

  export type FeaturedOnPageLinkUpdateManyWithoutFeaturedOnNestedInput = {
    create?: XOR<FeaturedOnPageLinkCreateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput> | FeaturedOnPageLinkCreateWithoutFeaturedOnInput[] | FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput[]
    connectOrCreate?: FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput | FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput[]
    upsert?: FeaturedOnPageLinkUpsertWithWhereUniqueWithoutFeaturedOnInput | FeaturedOnPageLinkUpsertWithWhereUniqueWithoutFeaturedOnInput[]
    createMany?: FeaturedOnPageLinkCreateManyFeaturedOnInputEnvelope
    set?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    disconnect?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    delete?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    connect?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    update?: FeaturedOnPageLinkUpdateWithWhereUniqueWithoutFeaturedOnInput | FeaturedOnPageLinkUpdateWithWhereUniqueWithoutFeaturedOnInput[]
    updateMany?: FeaturedOnPageLinkUpdateManyWithWhereWithoutFeaturedOnInput | FeaturedOnPageLinkUpdateManyWithWhereWithoutFeaturedOnInput[]
    deleteMany?: FeaturedOnPageLinkScalarWhereInput | FeaturedOnPageLinkScalarWhereInput[]
  }

  export type FeaturedOnPageLinkUncheckedUpdateManyWithoutFeaturedOnNestedInput = {
    create?: XOR<FeaturedOnPageLinkCreateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput> | FeaturedOnPageLinkCreateWithoutFeaturedOnInput[] | FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput[]
    connectOrCreate?: FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput | FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput[]
    upsert?: FeaturedOnPageLinkUpsertWithWhereUniqueWithoutFeaturedOnInput | FeaturedOnPageLinkUpsertWithWhereUniqueWithoutFeaturedOnInput[]
    createMany?: FeaturedOnPageLinkCreateManyFeaturedOnInputEnvelope
    set?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    disconnect?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    delete?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    connect?: FeaturedOnPageLinkWhereUniqueInput | FeaturedOnPageLinkWhereUniqueInput[]
    update?: FeaturedOnPageLinkUpdateWithWhereUniqueWithoutFeaturedOnInput | FeaturedOnPageLinkUpdateWithWhereUniqueWithoutFeaturedOnInput[]
    updateMany?: FeaturedOnPageLinkUpdateManyWithWhereWithoutFeaturedOnInput | FeaturedOnPageLinkUpdateManyWithWhereWithoutFeaturedOnInput[]
    deleteMany?: FeaturedOnPageLinkScalarWhereInput | FeaturedOnPageLinkScalarWhereInput[]
  }

  export type FeaturedOnCreateNestedOneWithoutPageLinksInput = {
    create?: XOR<FeaturedOnCreateWithoutPageLinksInput, FeaturedOnUncheckedCreateWithoutPageLinksInput>
    connectOrCreate?: FeaturedOnCreateOrConnectWithoutPageLinksInput
    connect?: FeaturedOnWhereUniqueInput
  }

  export type FeaturedOnUpdateOneRequiredWithoutPageLinksNestedInput = {
    create?: XOR<FeaturedOnCreateWithoutPageLinksInput, FeaturedOnUncheckedCreateWithoutPageLinksInput>
    connectOrCreate?: FeaturedOnCreateOrConnectWithoutPageLinksInput
    upsert?: FeaturedOnUpsertWithoutPageLinksInput
    connect?: FeaturedOnWhereUniqueInput
    update?: XOR<XOR<FeaturedOnUpdateToOneWithWhereWithoutPageLinksInput, FeaturedOnUpdateWithoutPageLinksInput>, FeaturedOnUncheckedUpdateWithoutPageLinksInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrderCreateNestedOneWithoutReviewsInput = {
    create?: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewsInput
    upsert?: OrderUpsertWithoutReviewsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReviewsInput, OrderUpdateWithoutReviewsInput>, OrderUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type CouponRedemptionCreateNestedManyWithoutCouponInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type EnumCouponTypeFieldUpdateOperationsInput = {
    set?: $Enums.CouponType
  }

  export type EnumCouponStatusFieldUpdateOperationsInput = {
    set?: $Enums.CouponStatus
  }

  export type CouponRedemptionUpdateManyWithoutCouponNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput | CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput | CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutCouponInput | CouponRedemptionUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput | CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput | CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutCouponInput | CouponRedemptionUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type CouponCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutRedemptionsInput
    connect?: CouponWhereUniqueInput
  }

  export type CouponUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutRedemptionsInput
    upsert?: CouponUpsertWithoutRedemptionsInput
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutRedemptionsInput, CouponUpdateWithoutRedemptionsInput>, CouponUncheckedUpdateWithoutRedemptionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformFilter<$PrismaModel> | $Enums.Platform
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformWithAggregatesFilter<$PrismaModel> | $Enums.Platform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformFilter<$PrismaModel>
    _max?: NestedEnumPlatformFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPaymentGatewayFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayFilter<$PrismaModel> | $Enums.PaymentGateway
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentGatewayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayWithAggregatesFilter<$PrismaModel> | $Enums.PaymentGateway
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentGatewayFilter<$PrismaModel>
    _max?: NestedEnumPaymentGatewayFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumPlatformNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel> | null
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlatformNullableFilter<$PrismaModel> | $Enums.Platform | null
  }

  export type NestedEnumServiceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceTypeNullableFilter<$PrismaModel> | $Enums.ServiceType | null
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedEnumPlatformNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Platform | EnumPlatformFieldRefInput<$PrismaModel> | null
    in?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Platform[] | ListEnumPlatformFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlatformNullableWithAggregatesFilter<$PrismaModel> | $Enums.Platform | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlatformNullableFilter<$PrismaModel>
    _max?: NestedEnumPlatformNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumServiceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCouponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeFilter<$PrismaModel> | $Enums.CouponType
  }

  export type NestedEnumCouponStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusFilter<$PrismaModel> | $Enums.CouponStatus
  }

  export type NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel> | $Enums.CouponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponTypeFilter<$PrismaModel>
    _max?: NestedEnumCouponTypeFilter<$PrismaModel>
  }

  export type NestedEnumCouponStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusWithAggregatesFilter<$PrismaModel> | $Enums.CouponStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponStatusFilter<$PrismaModel>
    _max?: NestedEnumCouponStatusFilter<$PrismaModel>
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    orderId?: string | null
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    excerpt?: StringNullableFilter<"BlogPost"> | string | null
    coverImage?: StringNullableFilter<"BlogPost"> | string | null
    authorId?: StringFilter<"BlogPost"> | string
    category?: StringNullableFilter<"BlogPost"> | string | null
    metaTitle?: StringNullableFilter<"BlogPost"> | string | null
    metaDescription?: StringNullableFilter<"BlogPost"> | string | null
    isPublished?: BoolFilter<"BlogPost"> | boolean
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    serviceId?: StringFilter<"Order"> | string
    platform?: EnumPlatformFilter<"Order"> | $Enums.Platform
    serviceType?: EnumServiceTypeFilter<"Order"> | $Enums.ServiceType
    quantity?: IntFilter<"Order"> | number
    price?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    link?: StringNullableFilter<"Order"> | string | null
    japOrderId?: StringNullableFilter<"Order"> | string | null
    japStatus?: StringNullableFilter<"Order"> | string | null
    upsellData?: JsonNullableFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringNullableFilter<"Review"> | string | null
    orderId?: StringNullableFilter<"Review"> | string | null
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    authorName?: StringNullableFilter<"Review"> | string | null
    isPublished?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    tokenHash?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type ServiceCreateWithoutOrdersInput = {
    id?: string
    name: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    japServiceId?: string | null
    basePrice: number
    markup?: number
    finalPrice: number
    minQuantity?: number | null
    maxQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    japServiceId?: string | null
    basePrice: number
    markup?: number
    finalPrice: number
    minQuantity?: number | null
    maxQuantity?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCreateOrConnectWithoutOrdersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    gateway: $Enums.PaymentGateway
    transactionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    gateway: $Enums.PaymentGateway
    transactionId?: string | null
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type ReviewCreateWithoutOrderInput = {
    id?: string
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutOrderInput = {
    id?: string
    userId?: string | null
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type ReviewCreateManyOrderInputEnvelope = {
    data: ReviewCreateManyOrderInput | ReviewCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutOrdersInput = {
    update: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type ServiceUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    japServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    markup?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    japServiceId?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    markup?: FloatFieldUpdateOperationsInput | number
    finalPrice?: FloatFieldUpdateOperationsInput | number
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    maxQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithoutOrderInput = {
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUpdateManyWithWhereWithoutOrderInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutServiceInput = {
    id?: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutServiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
  }

  export type OrderCreateManyServiceInputEnvelope = {
    data: OrderCreateManyServiceInput | OrderCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutServiceInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutServiceInput, OrderUncheckedUpdateWithoutServiceInput>
    create: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutServiceInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutServiceInput, OrderUncheckedUpdateWithoutServiceInput>
  }

  export type OrderUpdateManyWithWhereWithoutServiceInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutServiceInput>
  }

  export type OrderCreateWithoutPaymentInput = {
    id?: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    serviceId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
  }

  export type OrderUpsertWithoutPaymentInput = {
    update: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type FeaturedOnPageLinkCreateWithoutFeaturedOnInput = {
    pagePath: string
    link?: string | null
    nofollow?: boolean
  }

  export type FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput = {
    id?: number
    pagePath: string
    link?: string | null
    nofollow?: boolean
  }

  export type FeaturedOnPageLinkCreateOrConnectWithoutFeaturedOnInput = {
    where: FeaturedOnPageLinkWhereUniqueInput
    create: XOR<FeaturedOnPageLinkCreateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput>
  }

  export type FeaturedOnPageLinkCreateManyFeaturedOnInputEnvelope = {
    data: FeaturedOnPageLinkCreateManyFeaturedOnInput | FeaturedOnPageLinkCreateManyFeaturedOnInput[]
    skipDuplicates?: boolean
  }

  export type FeaturedOnPageLinkUpsertWithWhereUniqueWithoutFeaturedOnInput = {
    where: FeaturedOnPageLinkWhereUniqueInput
    update: XOR<FeaturedOnPageLinkUpdateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedUpdateWithoutFeaturedOnInput>
    create: XOR<FeaturedOnPageLinkCreateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedCreateWithoutFeaturedOnInput>
  }

  export type FeaturedOnPageLinkUpdateWithWhereUniqueWithoutFeaturedOnInput = {
    where: FeaturedOnPageLinkWhereUniqueInput
    data: XOR<FeaturedOnPageLinkUpdateWithoutFeaturedOnInput, FeaturedOnPageLinkUncheckedUpdateWithoutFeaturedOnInput>
  }

  export type FeaturedOnPageLinkUpdateManyWithWhereWithoutFeaturedOnInput = {
    where: FeaturedOnPageLinkScalarWhereInput
    data: XOR<FeaturedOnPageLinkUpdateManyMutationInput, FeaturedOnPageLinkUncheckedUpdateManyWithoutFeaturedOnInput>
  }

  export type FeaturedOnPageLinkScalarWhereInput = {
    AND?: FeaturedOnPageLinkScalarWhereInput | FeaturedOnPageLinkScalarWhereInput[]
    OR?: FeaturedOnPageLinkScalarWhereInput[]
    NOT?: FeaturedOnPageLinkScalarWhereInput | FeaturedOnPageLinkScalarWhereInput[]
    id?: IntFilter<"FeaturedOnPageLink"> | number
    featuredOnId?: IntFilter<"FeaturedOnPageLink"> | number
    pagePath?: StringFilter<"FeaturedOnPageLink"> | string
    link?: StringNullableFilter<"FeaturedOnPageLink"> | string | null
    nofollow?: BoolFilter<"FeaturedOnPageLink"> | boolean
  }

  export type FeaturedOnCreateWithoutPageLinksInput = {
    brandName: string
    logoUrl?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FeaturedOnUncheckedCreateWithoutPageLinksInput = {
    id?: number
    brandName: string
    logoUrl?: string | null
    displayOrder?: number
    isActive?: boolean
  }

  export type FeaturedOnCreateOrConnectWithoutPageLinksInput = {
    where: FeaturedOnWhereUniqueInput
    create: XOR<FeaturedOnCreateWithoutPageLinksInput, FeaturedOnUncheckedCreateWithoutPageLinksInput>
  }

  export type FeaturedOnUpsertWithoutPageLinksInput = {
    update: XOR<FeaturedOnUpdateWithoutPageLinksInput, FeaturedOnUncheckedUpdateWithoutPageLinksInput>
    create: XOR<FeaturedOnCreateWithoutPageLinksInput, FeaturedOnUncheckedCreateWithoutPageLinksInput>
    where?: FeaturedOnWhereInput
  }

  export type FeaturedOnUpdateToOneWithWhereWithoutPageLinksInput = {
    where?: FeaturedOnWhereInput
    data: XOR<FeaturedOnUpdateWithoutPageLinksInput, FeaturedOnUncheckedUpdateWithoutPageLinksInput>
  }

  export type FeaturedOnUpdateWithoutPageLinksInput = {
    brandName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeaturedOnUncheckedUpdateWithoutPageLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderCreateWithoutReviewsInput = {
    id?: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    serviceId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReviewsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type OrderUpsertWithoutReviewsInput = {
    update: XOR<OrderUpdateWithoutReviewsInput, OrderUncheckedUpdateWithoutReviewsInput>
    create: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReviewsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReviewsInput, OrderUncheckedUpdateWithoutReviewsInput>
  }

  export type OrderUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    role?: $Enums.UserRole
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CouponRedemptionCreateWithoutCouponInput = {
    id?: string
    userId?: string | null
    orderId?: string | null
    redeemedAt?: Date | string
  }

  export type CouponRedemptionUncheckedCreateWithoutCouponInput = {
    id?: string
    userId?: string | null
    orderId?: string | null
    redeemedAt?: Date | string
  }

  export type CouponRedemptionCreateOrConnectWithoutCouponInput = {
    where: CouponRedemptionWhereUniqueInput
    create: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput>
  }

  export type CouponRedemptionCreateManyCouponInputEnvelope = {
    data: CouponRedemptionCreateManyCouponInput | CouponRedemptionCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput = {
    where: CouponRedemptionWhereUniqueInput
    update: XOR<CouponRedemptionUpdateWithoutCouponInput, CouponRedemptionUncheckedUpdateWithoutCouponInput>
    create: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput>
  }

  export type CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput = {
    where: CouponRedemptionWhereUniqueInput
    data: XOR<CouponRedemptionUpdateWithoutCouponInput, CouponRedemptionUncheckedUpdateWithoutCouponInput>
  }

  export type CouponRedemptionUpdateManyWithWhereWithoutCouponInput = {
    where: CouponRedemptionScalarWhereInput
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyWithoutCouponInput>
  }

  export type CouponRedemptionScalarWhereInput = {
    AND?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
    OR?: CouponRedemptionScalarWhereInput[]
    NOT?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
    id?: StringFilter<"CouponRedemption"> | string
    couponId?: StringFilter<"CouponRedemption"> | string
    userId?: StringNullableFilter<"CouponRedemption"> | string | null
    orderId?: StringNullableFilter<"CouponRedemption"> | string | null
    redeemedAt?: DateTimeFilter<"CouponRedemption"> | Date | string
  }

  export type CouponCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    type: $Enums.CouponType
    value: number
    currency?: string | null
    status?: $Enums.CouponStatus
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    maxRedemptions?: number | null
    maxRedemptionsPerUser?: number | null
    minOrderAmount?: number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    type: $Enums.CouponType
    value: number
    currency?: string | null
    status?: $Enums.CouponStatus
    startsAt?: Date | string | null
    expiresAt?: Date | string | null
    maxRedemptions?: number | null
    maxRedemptionsPerUser?: number | null
    minOrderAmount?: number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateOrConnectWithoutRedemptionsInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
  }

  export type CouponUpsertWithoutRedemptionsInput = {
    update: XOR<CouponUpdateWithoutRedemptionsInput, CouponUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutRedemptionsInput, CouponUncheckedUpdateWithoutRedemptionsInput>
  }

  export type CouponUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    value?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptionsPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    value?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxRedemptions?: NullableIntFieldUpdateOperationsInput | number | null
    maxRedemptionsPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    minOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    applicableServices?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    serviceId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    orderId?: string | null
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyOrderInput = {
    id?: string
    userId?: string | null
    rating: number
    comment: string
    authorName?: string | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyServiceInput = {
    id?: string
    userId: string
    platform: $Enums.Platform
    serviceType: $Enums.ServiceType
    quantity: number
    price: number
    currency?: string
    status?: $Enums.OrderStatus
    link?: string | null
    japOrderId?: string | null
    japStatus?: string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformFieldUpdateOperationsInput | $Enums.Platform
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    link?: NullableStringFieldUpdateOperationsInput | string | null
    japOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    japStatus?: NullableStringFieldUpdateOperationsInput | string | null
    upsellData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedOnPageLinkCreateManyFeaturedOnInput = {
    id?: number
    pagePath: string
    link?: string | null
    nofollow?: boolean
  }

  export type FeaturedOnPageLinkUpdateWithoutFeaturedOnInput = {
    pagePath?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    nofollow?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeaturedOnPageLinkUncheckedUpdateWithoutFeaturedOnInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagePath?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    nofollow?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeaturedOnPageLinkUncheckedUpdateManyWithoutFeaturedOnInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagePath?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    nofollow?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CouponRedemptionCreateManyCouponInput = {
    id?: string
    userId?: string | null
    orderId?: string | null
    redeemedAt?: Date | string
  }

  export type CouponRedemptionUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeaturedOnCountOutputTypeDefaultArgs instead
     */
    export type FeaturedOnCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeaturedOnCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponCountOutputTypeDefaultArgs instead
     */
    export type CouponCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UpsellDefaultArgs instead
     */
    export type UpsellArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UpsellDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SocialProfileDefaultArgs instead
     */
    export type SocialProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SocialProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SocialProofDefaultArgs instead
     */
    export type SocialProofArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SocialProofDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminSettingsDefaultArgs instead
     */
    export type AdminSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HomepageContentDefaultArgs instead
     */
    export type HomepageContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HomepageContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamMemberDefaultArgs instead
     */
    export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HeroSocialUpdateDefaultArgs instead
     */
    export type HeroSocialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HeroSocialUpdateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromoBarDefaultArgs instead
     */
    export type PromoBarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromoBarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeaturedOnDefaultArgs instead
     */
    export type FeaturedOnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeaturedOnDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeaturedOnPageLinkDefaultArgs instead
     */
    export type FeaturedOnPageLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeaturedOnPageLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlatformSectionDefaultArgs instead
     */
    export type PlatformSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlatformSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GetStartedContentDefaultArgs instead
     */
    export type GetStartedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GetStartedContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InfluenceSectionDefaultArgs instead
     */
    export type InfluenceSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InfluenceSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvantageSectionDefaultArgs instead
     */
    export type AdvantageSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvantageSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuickStartSectionDefaultArgs instead
     */
    export type QuickStartSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuickStartSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicePageContentDefaultArgs instead
     */
    export type ServicePageContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicePageContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FAQDefaultArgs instead
     */
    export type FAQArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FAQDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestimonialDefaultArgs instead
     */
    export type TestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestimonialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogPostDefaultArgs instead
     */
    export type BlogPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LegalPageDefaultArgs instead
     */
    export type LegalPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LegalPageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateDefaultArgs instead
     */
    export type EmailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BellNotificationDefaultArgs instead
     */
    export type BellNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BellNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BannerMessageDefaultArgs instead
     */
    export type BannerMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BannerMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IconAssetDefaultArgs instead
     */
    export type IconAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IconAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponDefaultArgs instead
     */
    export type CouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponRedemptionDefaultArgs instead
     */
    export type CouponRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponRedemptionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}